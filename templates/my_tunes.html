{% extends "base.html" %}

{% block title %}My Tunes - Personal Tune Collection{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/my_tunes_mobile.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/tune_detail_modal.css') }}">
{% endblock %}

{% block content %}
<div class="my-tunes-container">
    <div class="my-tunes-header-section">
        <div class="page-header">
            <h1>
                My Tunes
                <a href="/help/my-tunes" class="help-icon" title="How to use My Tunes">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </a>
            </h1>
            <div class="page-actions">
                <a href="/my-tunes/add" class="btn" id="add-tune-btn" onclick="handleAddTuneClick(event)">Add</a>
                <a href="/my-tunes/sync" class="btn btn-secondary">Sync</a>
            </div>
        </div>

        <div class="filters-container">
            <div class="filter-row">
                <div class="filter-group">
                    <input
                        type="text"
                        id="search-input"
                        class="filter-input"
                        placeholder="Search"
                        title="Search tunes"
                        autocomplete="off"
                    >
                </div>
                <div class="filter-group">
                    <select id="type-filter" class="filter-select" title="Tune type">
                        <option value="">All Types</option>
                    </select>
                </div>
                <div class="filter-group">
                    <select id="status-filter-select" class="filter-select status-filter-select" title="Filter by learning status">
                        <option value="">All Tunes</option>
                        <option value="learned">Learned</option>
                        <option value="learning">Learning</option>
                        <option value="want to learn">Want To Learn</option>
                    </select>
                    <button id="status-filter-btn" class="status-filter-btn" onclick="cycleStatusFilter()" title="Filter by learning status">
                        <span id="status-filter-icon">All</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="results-count">
            <span id="results-count-text"></span>
            <button id="sort-toggle" class="sort-toggle" onclick="cycleSortMode()" title="Toggle sort order">
                <span id="sort-icon">‚Üì</span>
            </button>
        </div>
    </div>

    <div id="loading" class="loading" style="display: none;">
        <p>Loading your tunes...</p>
    </div>

    <div id="no-results" class="no-results" style="display: none;">
        <h3>No tunes found</h3>
        <p id="no-results-message">Try adjusting your filters or add your first tune to get started!</p>
        <div id="no-results-action" style="margin-top: 15px;"></div>
    </div>

    <div class="tunes-grid" id="tunes-grid">
        <!-- Tune cards will be inserted here by JavaScript -->
    </div>

    <div id="loading-more" class="loading-more">
        <span class="loading-spinner"></span>
        <span>Loading more tunes...</span>
    </div>
</div>

<!-- Unified Tune Detail Modal -->
{% include 'tune_detail_modal.html' %}

<script>
// Helper functions for API calls
function fetchWithRetry(url, options = {}) {
    return fetch(url, options);
}

function handleApiError(error, response = null) {
    if (response) {
        if (response.status === 401) {
            return { message: 'Please log in again', action: () => window.location.href = '/login' };
        }
        if (response.status === 404) {
            return { message: 'Not found', retryable: false };
        }
        if (response.status >= 500) {
            return { message: 'Server error. Please try again.', retryable: true };
        }
        return { message: 'An error occurred. Please try again.', retryable: true };
    }
    return { message: error?.message || 'An error occurred', retryable: true };
}

function showLoading(message = 'Loading...') {
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loading-overlay';
    loadingDiv.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(255,255,255,0.9); z-index: 9999;
        display: flex; align-items: center; justify-content: center;
        flex-direction: column; gap: 15px;
    `;
    loadingDiv.innerHTML = `
        <div style="width: 40px; height: 40px; border: 4px solid #ddd;
                    border-top-color: #007bff; border-radius: 50%;
                    animation: spin 0.8s linear infinite;"></div>
        <div style="color: #333; font-size: 16px;">${message}</div>
    `;
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
    document.body.appendChild(loadingDiv);
    return {
        hide: () => {
            if (loadingDiv.parentNode) loadingDiv.parentNode.removeChild(loadingDiv);
            if (style.parentNode) style.parentNode.removeChild(style);
        }
    };
}

// Build a thesession.org URL with optional setting parameter
// Format: https://thesession.org/tunes/{tune_id}?setting={setting_id}#setting{setting_id}
function buildTheSessionUrl(tuneId, settingId) {
    if (!tuneId) return '';

    const baseUrl = `https://thesession.org/tunes/${tuneId}`;

    if (settingId) {
        return `${baseUrl}?setting=${settingId}#setting${settingId}`;
    }

    return baseUrl;
}

// Extract setting ID from thesession.org URL or plain number
// Handles formats:
// - Plain number: 123
// - Query param: ?setting=123 or &setting=123
// - Hash anchor: #setting123
// - Combined: ?setting=123#setting123
function extractSettingId(input) {
    if (!input || input.trim() === '') {
        return null;
    }

    const trimmed = input.trim();

    // If it's already just a number, return it
    if (/^\d+$/.test(trimmed)) {
        return parseInt(trimmed);
    }

    // Try to extract from URL query param format first: ?setting=123 or &setting=123
    // This is the authoritative source if present
    const queryMatch = trimmed.match(/[?&]setting=(\d+)/);
    if (queryMatch) {
        return parseInt(queryMatch[1]);
    }

    // Fall back to hash format: #setting123
    const hashMatch = trimmed.match(/#setting(\d+)/);
    if (hashMatch) {
        return parseInt(hashMatch[1]);
    }

    // Couldn't parse - return null
    return null;
}

// Validate that input is either empty, a number, or a valid thesession.org URL
function validateSettingId(input) {
    if (!input || input.trim() === '') {
        return { valid: true, settingId: null };
    }

    const trimmed = input.trim();

    // Check if it's just a number
    if (/^\d+$/.test(trimmed)) {
        return { valid: true, settingId: parseInt(trimmed) };
    }

    // Check if it's a valid thesession.org URL
    if (trimmed.includes('thesession.org')) {
        const settingId = extractSettingId(trimmed);
        if (settingId !== null) {
            return { valid: true, settingId: settingId };
        }
    }

    // Invalid input
    return { valid: false, settingId: null, error: 'Please enter a number or paste a valid TheSession.org URL' };
}

// Handle setting ID input with instant parsing and validation
function onSettingIdInput() {
    const input = document.getElementById('modal-setting-id-input');
    const errorDiv = document.getElementById('modal-setting-id-error');

    if (!input || !errorDiv) return;

    const value = input.value;
    const validation = validateSettingId(value);

    if (!validation.valid) {
        // Show error
        errorDiv.textContent = validation.error;
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';

        // Disable save button
        const saveBtn = document.getElementById('modal-save-btn');
        if (saveBtn) {
            saveBtn.disabled = true;
        }
    } else {
        // Clear error
        errorDiv.style.display = 'none';
        input.style.borderColor = '';

        // If we extracted a setting ID from a URL, replace the input with just the number
        if (validation.settingId !== null && value !== validation.settingId.toString()) {
            input.value = validation.settingId.toString();
        }

        // Trigger field change detection
        onModalFieldChange();
    }
}

let allTunes = [];
let filteredTunes = [];
let currentFilters = {
    search: '',
    type: '',
    status: ''
};
let modalShowTime = 0;
let modalFetchController = null; // AbortController for modal fetch requests
let isLoadingFullTunes = false; // Track if full tune list is still loading
let fullTunesLoaded = false; // Track if we have all tunes

// Status filter cycle states
const statusFilterStates = [
    { value: '', label: 'All', icon: 'All' },
    { value: 'learned', label: 'Learned', icon: '‚úì' },
    { value: 'learning', label: 'Learning', icon: '‚ãØ' },
    { value: 'want to learn', label: 'Want to Learn', icon: '‚óè' }
];
let currentStatusFilterIndex = 0;

// Sort mode cycle states
const sortModes = [
    { id: 'alpha-asc', label: 'a-z', icon: '‚Üì', sortFn: (a, b) => (a.tune_name || '').localeCompare(b.tune_name || '') },
    { id: 'alpha-desc', label: 'z-a', icon: '‚Üë', sortFn: (a, b) => (b.tune_name || '').localeCompare(a.tune_name || '') },
    { id: 'popularity-desc', label: 'popularity high', icon: '#', sortFn: (a, b) => (b.tunebook_count || 0) - (a.tunebook_count || 0) },
    { id: 'heard-desc', label: 'heard high', icon: 'üëÇ', sortFn: (a, b) => {
        const heardDiff = (b.heard_count || 0) - (a.heard_count || 0);
        if (heardDiff !== 0) return heardDiff;
        return (b.tunebook_count || 0) - (a.tunebook_count || 0);
    }}
];
let currentSortModeIndex = 0;

// Helper function to normalize strings by removing accents and normalizing quotes
function normalizeString(str) {
    if (!str) return '';
    // Remove accents
    let normalized = str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    // Normalize smart quotes to straight quotes
    normalized = normalized
        .replace(/['']/g, "'")  // Single smart quotes to straight quote
        .replace(/[""]/g, '"'); // Double smart quotes to straight quote
    return normalized;
}

// Extract tune ID from TheSession.org URL or plain number
// Handles formats:
// - Plain number: 123
// - Full URL: https://thesession.org/tunes/123
// - With querystring: https://thesession.org/tunes/123?setting=456
// - With hash: https://thesession.org/tunes/123#setting456
function extractTuneId(input) {
    if (!input) return null;

    const trimmed = input.trim();

    // If it's already just a number, return it
    if (/^\d+$/.test(trimmed)) {
        return parseInt(trimmed);
    }

    // Try to extract from URL: https://thesession.org/tunes/123
    const urlMatch = trimmed.match(/thesession\.org\/tunes\/(\d+)/i);
    if (urlMatch) {
        return parseInt(urlMatch[1]);
    }

    return null;
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadTunes();
    setupEventListeners();
    loadFiltersFromURL();
    checkForSuccessMessage();
    setupScrollDetection();

    // Check for tune parameter in URL and open modal if present
    const tuneId = TuneDetailModal.getTuneIdFromUrl();
    if (tuneId) {
        // Wait for tunes to load before opening modal
        waitForTuneAndOpen(tuneId);
    }
});

function setupScrollDetection() {
    // Detect scroll to show loading indicator if still loading
    window.addEventListener('scroll', function() {
        if (!isLoadingFullTunes || fullTunesLoaded) {
            return;
        }

        const tunesGrid = document.getElementById('tunes-grid');
        const loadingMore = document.getElementById('loading-more');

        if (!tunesGrid || !loadingMore) {
            return;
        }

        // Get the bottom position of the tunes grid
        const gridRect = tunesGrid.getBoundingClientRect();
        const gridBottom = gridRect.bottom;

        // Get viewport height
        const viewportHeight = window.innerHeight;

        // If we're within 200px of the bottom of the grid, show loading indicator
        if (gridBottom < viewportHeight + 200) {
            loadingMore.classList.add('visible');
        }
    });
}

function checkForSuccessMessage() {
    const params = new URLSearchParams(window.location.search);
    if (params.has('added')) {
        const tuneName = params.get('added');
        showMessage(`Successfully added "${tuneName}" to your collection!`, 'success');
        // Clean up URL
        params.delete('added');
        const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
        window.history.replaceState({}, '', newURL);
    }
}

function setupEventListeners() {
    // Search input with debounce
    let searchTimeout;
    document.getElementById('search-input').addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            currentFilters.search = e.target.value.toLowerCase().trim();
            applyFilters();
        }, 300);
    });

    // Filter dropdowns
    document.getElementById('type-filter').addEventListener('change', function(e) {
        currentFilters.type = e.target.value;
        applyFilters();
    });

    // Status filter dropdown (desktop)
    const statusFilterSelect = document.getElementById('status-filter-select');
    if (statusFilterSelect) {
        statusFilterSelect.addEventListener('change', function(e) {
            currentFilters.status = e.target.value;
            applyFilters();
        });
    }

    // Setup swipe-to-close for mobile
    setupSwipeToClose();

    // Setup swipe-right for heard count on tune cards
    setupTuneCardSwipe();
}

function setupTuneCardSwipe() {
    // This will be called after each render to attach swipe handlers to tune cards
    // We'll set up a delegated event listener on the grid
    const grid = document.getElementById('tunes-grid');
    if (!grid) return;

    let touchStartX = 0;
    let touchStartY = 0;
    let swipedCard = null;

    grid.addEventListener('touchstart', function(e) {
        // Check if touch is on a tune card with "want to learn" status
        const card = e.target.closest('.tune-card[data-can-swipe="true"]');
        if (!card) return;

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        swipedCard = card;
    }, { passive: true });

    grid.addEventListener('touchmove', function(e) {
        if (!swipedCard) return;

        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Check if it's a right swipe (and mostly horizontal)
        if (deltaX > 20 && Math.abs(deltaX) > Math.abs(deltaY) * 2) {
            swipedCard.classList.add('swiping');
        } else {
            swipedCard.classList.remove('swiping');
        }
    }, { passive: true });

    grid.addEventListener('touchend', function(e) {
        if (!swipedCard) return;

        const touchEndX = e.changedTouches[0].clientX;
        const deltaX = touchEndX - touchStartX;

        // If swiped far enough to the right, trigger the heard count increment
        if (deltaX > 80) {
            const personTuneId = parseInt(swipedCard.dataset.personTuneId);
            if (personTuneId) {
                incrementHeardCount(personTuneId);
            }
        }

        // Reset
        if (swipedCard) {
            swipedCard.classList.remove('swiping');
        }
        swipedCard = null;
        touchStartX = 0;
        touchStartY = 0;
    }, { passive: true });
}

function setupSwipeToClose() {
    const modalDialog = document.querySelector('.modal-dialog');
    if (!modalDialog) return;

    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let isSwiping = false;

    modalDialog.addEventListener('touchstart', function(e) {
        // Don't intercept touches on input controls
        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            return;
        }

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        isSwiping = false;
    }, { passive: true });

    modalDialog.addEventListener('touchmove', function(e) {
        if (!touchStartX) return;

        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            return;
        }

        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Detect horizontal swipe (more horizontal than vertical)
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            isSwiping = true;
        }
    }, { passive: true });

    modalDialog.addEventListener('touchend', function(e) {
        if (!touchStartX || !isSwiping) {
            touchStartX = 0;
            touchStartY = 0;
            return;
        }

        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            touchStartX = 0;
            touchStartY = 0;
            isSwiping = false;
            return;
        }

        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const deltaTime = Date.now() - touchStartTime;

        // Swipe right: deltaX > 0 and significant horizontal movement
        // Must be mostly horizontal (not diagonal) and fast enough or far enough
        if (deltaX > 50 && Math.abs(deltaX) > Math.abs(deltaY) * 2) {
            // Swipe right detected - close modal
            console.log('Swipe right detected, closing modal');
            closeTuneDetailModal();
        }

        touchStartX = 0;
        touchStartY = 0;
        isSwiping = false;
    }, { passive: true });
}

function cycleStatusFilter() {
    currentStatusFilterIndex = (currentStatusFilterIndex + 1) % statusFilterStates.length;
    const state = statusFilterStates[currentStatusFilterIndex];
    currentFilters.status = state.value;

    // Update button display
    const btn = document.getElementById('status-filter-btn');
    const icon = document.getElementById('status-filter-icon');
    icon.textContent = state.icon;

    // Add active class and set icon color if filtering
    if (state.value) {
        btn.classList.add('active');

        // Set icon color based on status
        if (state.value === 'learned') {
            icon.style.color = '#5cb85c'; // green
        } else if (state.value === 'learning') {
            icon.style.color = '#5bc0de'; // blue
        } else if (state.value === 'want to learn') {
            icon.style.color = '#f0ad4e'; // yellow
        }
    } else {
        btn.classList.remove('active');
        icon.style.color = ''; // reset color for "All"
    }

    applyFilters();
}

function cycleSortMode() {
    currentSortModeIndex = (currentSortModeIndex + 1) % sortModes.length;
    const mode = sortModes[currentSortModeIndex];

    // Update button display
    const icon = document.getElementById('sort-icon');
    icon.textContent = mode.icon;

    // Re-apply filters and sorting (no DB reload needed)
    applyFilters();
}

function loadFiltersFromURL() {
    const params = new URLSearchParams(window.location.search);

    if (params.has('search')) {
        currentFilters.search = params.get('search');
        document.getElementById('search-input').value = params.get('search');
    }

    if (params.has('type')) {
        currentFilters.type = params.get('type');
        document.getElementById('type-filter').value = params.get('type');
    }

    if (params.has('status')) {
        const status = params.get('status');
        currentFilters.status = status;

        // Set desktop dropdown
        const statusFilterSelect = document.getElementById('status-filter-select');
        if (statusFilterSelect) {
            statusFilterSelect.value = status;
        }

        // Set mobile button (find the matching status filter state)
        const index = statusFilterStates.findIndex(s => s.value === status);
        if (index >= 0) {
            currentStatusFilterIndex = index;
            const state = statusFilterStates[index];
            const icon = document.getElementById('status-filter-icon');
            icon.textContent = state.icon;

            if (state.value) {
                document.getElementById('status-filter-btn').classList.add('active');

                // Set icon color based on status
                if (state.value === 'learned') {
                    icon.style.color = '#5cb85c'; // green
                } else if (state.value === 'learning') {
                    icon.style.color = '#5bc0de'; // blue
                } else if (state.value === 'want to learn') {
                    icon.style.color = '#f0ad4e'; // yellow
                }
            }
        }
    }

    if (params.has('sort')) {
        const sortId = params.get('sort');
        const index = sortModes.findIndex(s => s.id === sortId);
        if (index >= 0) {
            currentSortModeIndex = index;
            const mode = sortModes[index];
            document.getElementById('sort-icon').textContent = mode.icon;
        }
    }
}

function updateURL() {
    const params = new URLSearchParams();

    if (currentFilters.search) params.set('search', currentFilters.search);
    if (currentFilters.type) params.set('type', currentFilters.type);
    if (currentFilters.status) params.set('status', currentFilters.status);

    // Only add sort param if not default (alpha-asc)
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.id !== 'alpha-asc') {
        params.set('sort', sortMode.id);
    }

    const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
    window.history.replaceState({}, '', newURL);
}

function loadTunes() {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('tunes-grid').style.display = 'none';
    document.getElementById('no-results').style.display = 'none';
    document.getElementById('loading-more').classList.remove('visible');

    // Reset state
    fullTunesLoaded = false;
    isLoadingFullTunes = true;

    // Get current sort mode for API query
    const sortMode = sortModes[currentSortModeIndex];
    const sortParam = sortMode ? sortMode.id : 'alpha-asc';

    // First, fetch initial 20 tunes for fast display
    fetchWithRetry(`/api/my-tunes?per_page=20&sort=${sortParam}`)
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                if (errorInfo.action) {
                    errorInfo.action();
                    return Promise.reject(new Error(errorInfo.message));
                }
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            // Only update if we don't already have the full tune list
            // This prevents the 20-tune response from overwriting the 2000-tune response
            if (!fullTunesLoaded) {
                allTunes = data.tunes || [];
                populateTuneTypes();
                applyFilters();

                // If we got fewer than 20, we have all tunes
                if (allTunes.length < 20) {
                    fullTunesLoaded = true;
                    isLoadingFullTunes = false;
                }
            }
        })
        .catch(error => {
            console.error('Error loading initial tunes:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');

            // Show retry option if retryable
            if (errorInfo.retryable) {
                showRetryOption();
            }

            document.getElementById('loading').style.display = 'none';
            isLoadingFullTunes = false;
        });

    // In parallel, fetch all tunes (up to 2000)
    fetchWithRetry(`/api/my-tunes?per_page=2000&sort=${sortParam}`)
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            // Replace with full tune list - this should always take precedence
            allTunes = data.tunes || [];
            fullTunesLoaded = true;
            isLoadingFullTunes = false;

            // Hide loading-more indicator
            document.getElementById('loading-more').classList.remove('visible');

            populateTuneTypes();
            applyFilters();
        })
        .catch(error => {
            console.error('Error loading full tune list:', error);
            isLoadingFullTunes = false;
            // Don't show error if we already have initial tunes
            if (allTunes.length === 0) {
                const errorInfo = handleApiError(error);
                showMessage(errorInfo.message, 'error');
            }
            document.getElementById('loading-more').classList.remove('visible');
        });
}

function showRetryOption() {
    const grid = document.getElementById('tunes-grid');
    grid.innerHTML = `
        <div class="error-state">
            <div class="error-state-icon">‚ö†Ô∏è</div>
            <div class="error-state-title">Failed to Load Tunes</div>
            <div class="error-state-message">There was a problem loading your tune collection.</div>
            <div class="error-state-action">
                <button class="retry-btn" onclick="loadTunes()">
                    <span class="retry-icon">‚Üª</span>
                    Retry
                </button>
            </div>
        </div>
    `;
    grid.style.display = 'grid';
}

function populateTuneTypes() {
    const types = [...new Set(allTunes.map(tune => tune.tune_type).filter(Boolean))];
    types.sort();
    
    const typeFilter = document.getElementById('type-filter');
    const currentValue = typeFilter.value;
    
    // Keep "All Types" option and add tune types
    typeFilter.innerHTML = '<option value="">All Types</option>';
    types.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        typeFilter.appendChild(option);
    });
    
    // Restore selected value if it still exists
    if (currentValue && types.includes(currentValue)) {
        typeFilter.value = currentValue;
    }
}

function applyFilters() {
    filteredTunes = allTunes.filter(tune => {
        // Search filter (accent-insensitive, and also handles tune IDs/URLs)
        if (currentFilters.search) {
            // Check if the search query is a tune ID or URL
            const tuneId = extractTuneId(currentFilters.search);

            // Always do text search on tune name and notes
            const searchNormalized = normalizeString(currentFilters.search.toLowerCase());
            const nameNormalized = normalizeString(tune.tune_name ? tune.tune_name.toLowerCase() : '');
            const notesNormalized = normalizeString(tune.notes ? tune.notes.toLowerCase() : '');
            const nameMatch = nameNormalized.includes(searchNormalized);
            const notesMatch = notesNormalized.includes(searchNormalized);

            // If search looks like a tune ID, also check tune_id
            const tuneIdMatch = tuneId && tune.tune_id === tuneId;

            // Match if ANY of these are true: tune ID match, name match, or notes match
            if (!tuneIdMatch && !nameMatch && !notesMatch) return false;
        }

        // Type filter
        if (currentFilters.type && tune.tune_type !== currentFilters.type) {
            return false;
        }

        // Status filter
        if (currentFilters.status && tune.learn_status !== currentFilters.status) {
            return false;
        }

        return true;
    });

    // Apply client-side sorting
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.sortFn) {
        filteredTunes.sort(sortMode.sortFn);
    }

    updateURL();
    renderTunes();
}

function renderTunes() {
    document.getElementById('loading').style.display = 'none';

    const grid = document.getElementById('tunes-grid');
    const noResults = document.getElementById('no-results');
    const resultsCountText = document.getElementById('results-count-text');

    if (filteredTunes.length === 0) {
        // Only show "No matching tunes" if the full tune list has been loaded
        // This prevents the flash when filtering before all tunes are fetched
        if (fullTunesLoaded) {
            grid.style.display = 'none';
            noResults.style.display = 'block';
            resultsCountText.textContent = '';

            // Build a descriptive message based on active filters
            let message;

            // Check if search is a tune ID or URL
            const searchedTuneId = currentFilters.search ? extractTuneId(currentFilters.search) : null;

            if (searchedTuneId) {
                // Special message for tune ID/URL searches
                message = `No tune with ID ${searchedTuneId} found`;
            } else {
                // Build regular message for text searches and filters
                const messageParts = [];

                if (currentFilters.type) {
                    const typeCapitalized = currentFilters.type.charAt(0).toUpperCase() + currentFilters.type.slice(1);
                    messageParts.push(typeCapitalized + 's');
                } else {
                    messageParts.push('tunes');
                }

                if (currentFilters.search) {
                    messageParts.push(`containing '${currentFilters.search}'`);
                }

                if (currentFilters.status) {
                    const statusLabels = {
                        'learned': 'Learned',
                        'learning': 'Learning',
                        'want to learn': 'Want To Learn'
                    };
                    const statusLabel = statusLabels[currentFilters.status] || currentFilters.status;
                    messageParts.push(`in '${statusLabel}' status`);
                }

                // Build the final message
                message = 'No ' + messageParts[0];
                if (messageParts.length > 1) {
                    message += ' ' + messageParts.slice(1).join(' ');
                }
                message += ' found';
            }

            // Update the no-results message
            const noResultsMessage = document.getElementById('no-results-message');
            if (noResultsMessage) {
                noResultsMessage.textContent = message;
            }

            // Check if any filters are active (excluding search for button logic)
            const hasActiveFilters = currentFilters.type || currentFilters.status;
            const actionDiv = document.getElementById('no-results-action');

            if (hasActiveFilters) {
                // Show "Clear Filters" link
                actionDiv.innerHTML = '<a href="#" onclick="clearFilters(); return false;" class="btn">Clear Filters</a>';
            } else {
                // Show "Add Tune" link - include search query if present
                const searchInput = document.getElementById('search-input');
                const searchValue = searchInput ? searchInput.value.trim() : '';
                const addTuneUrl = searchValue.length > 0
                    ? `/my-tunes/add?q=${encodeURIComponent(searchValue)}`
                    : '/my-tunes/add';
                actionDiv.innerHTML = `<a href="${addTuneUrl}" class="btn">Add Tune</a>`;
            }
        } else {
            // Still loading - keep showing loading state
            grid.style.display = 'none';
            noResults.style.display = 'none';
            resultsCountText.textContent = '';
        }

        return;
    }

    grid.style.display = 'grid';
    noResults.style.display = 'none';

    // Update results count - only show if full tunes are loaded
    if (fullTunesLoaded) {
        const total = allTunes.length;
        const filtered = filteredTunes.length;
        if (filtered < total) {
            resultsCountText.textContent = `Showing ${filtered} of ${total} tunes`;
        } else {
            resultsCountText.textContent = `${total} tune${total !== 1 ? 's' : ''}`;
        }
    } else {
        // Don't show count until full data is loaded
        resultsCountText.textContent = '';
    }

    // Render tune cards
    console.log('Rendering', filteredTunes.length, 'tunes. Window width:', window.innerWidth);
    const wantToLearnCount = filteredTunes.filter(t => t.learn_status === 'want to learn').length;
    console.log('Want to learn tunes:', wantToLearnCount);

    grid.innerHTML = filteredTunes.map(tune => createTuneCard(tune)).join('');

    // Initialize swipe listeners for mobile
    if (window.innerWidth <= 768) {
        initializeSwipeListeners();
    }
}

function initializeSwipeListeners() {
    const swipeContainers = document.querySelectorAll('.tune-card-swipe-container');

    console.log('Initializing swipe listeners for', swipeContainers.length, 'containers');

    // Global variable to track currently revealed row
    let currentlyRevealed = null;

    swipeContainers.forEach((container, index) => {
        const card = container.querySelector('.tune-card-swipeable');
        const button = container.querySelector('.swipe-action-btn');
        const actionDiv = container.querySelector('.tune-card-swipe-action');

        if (!card || !button || !actionDiv) {
            console.error('Missing elements in container', index);
            return;
        }

        const buttonWidth = 80; // matches CSS
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let isDragging = false;
        let isRevealed = false;
        let swipeDirection = null; // 'horizontal' or 'vertical'

        // Track touch/mouse position during swipe
        card.addEventListener('touchstart', (e) => {
            console.log('touchstart');
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            currentX = 0;
            isDragging = true;
            swipeDirection = null;

            // Close any previously revealed row (different from current)
            if (currentlyRevealed && currentlyRevealed !== container) {
                const prevCard = currentlyRevealed.querySelector('.tune-card-swipeable');
                const prevActionDiv = currentlyRevealed.querySelector('.tune-card-swipe-action');
                if (prevCard && prevActionDiv) {
                    prevCard.classList.remove('revealed');
                    prevCard.style.transform = '';
                    prevActionDiv.style.width = '0px';
                }
                currentlyRevealed = null;
            }

            // If this card was previously revealed, close it immediately when starting new drag
            if (isRevealed) {
                card.classList.remove('revealed');
                isRevealed = false;
                card.style.transform = '';
                actionDiv.style.width = '0px';
            }
        }, { passive: true });

        card.addEventListener('touchmove', (e) => {
            if (!isDragging) return;

            const touch = e.touches[0];
            const diffX = touch.clientX - startX; // Changed: now positive when moving right
            const diffY = touch.clientY - startY;

            // Determine swipe direction on first move
            if (swipeDirection === null && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    swipeDirection = 'horizontal';
                    card.classList.add('swiping');
                } else {
                    swipeDirection = 'vertical';
                }
            }

            // Only handle horizontal swipes
            if (swipeDirection === 'horizontal') {
                // Only allow right swipe (positive diffX means finger moving right)
                if (diffX > 0) {
                    currentX = Math.min(diffX, buttonWidth * 2); // Allow swipe up to 2x button width

                    // Update card position - move card right
                    card.style.transform = `translateX(${currentX}px)`;

                    // Button width matches drag distance (so it reveals progressively)
                    actionDiv.style.width = `${currentX}px`;

                    // Prevent scrolling for horizontal swipes
                    e.preventDefault();
                }
            }
        }, { passive: false });

        card.addEventListener('touchend', (e) => {
            console.log('touchend - swipeDirection:', swipeDirection, 'currentX:', currentX);
            if (!isDragging) return;
            isDragging = false;
            card.classList.remove('swiping');

            // Only process horizontal swipes
            if (swipeDirection === 'horizontal') {
                // Determine action based on swipe distance
                if (currentX > buttonWidth) {
                    // Swiped past button width - trigger increment
                    console.log('Triggering increment (swiped past button width)');
                    currentlyRevealed = null; // Clear global tracking
                    triggerIncrementWithAnimation(container, button);
                } else if (currentX > buttonWidth * 0.25) {
                    // Swiped more than 25% - stay revealed
                    console.log('Staying revealed');
                    // Set transform to current position, force reflow, then add class to animate
                    const currentPosition = currentX;
                    card.style.transform = `translateX(${currentPosition}px)`;
                    card.offsetHeight; // Force reflow
                    card.classList.add('revealed');
                    isRevealed = true;
                    currentlyRevealed = container; // Track globally
                    // Clear inline transform so class takes over
                    setTimeout(() => {
                        card.style.transform = '';
                    }, 0);
                    actionDiv.style.width = `${buttonWidth}px`;
                } else {
                    // Swiped less than 25% - slide back
                    console.log('Sliding back');
                    card.classList.remove('revealed');
                    isRevealed = false;
                    currentlyRevealed = null; // Clear global tracking
                    card.style.transform = '';
                    actionDiv.style.width = '0px';
                }
            }

            currentX = 0;
            swipeDirection = null;
        }, { passive: true });

        // Handle button click
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Button clicked');
            currentlyRevealed = null; // Clear global tracking
            triggerIncrementWithAnimation(container, button);
        });

        // Close revealed state when tapping elsewhere
        document.addEventListener('click', (e) => {
            if (isRevealed && !container.contains(e.target)) {
                card.classList.remove('revealed');
                isRevealed = false;
                currentlyRevealed = null; // Clear global tracking
                actionDiv.style.width = '0px';
            }
        });
    });
}

function triggerIncrementWithAnimation(container, button) {
    const personTuneId = parseInt(button.dataset.personTuneId);
    const card = container.querySelector('.tune-card-swipeable');

    // Get current heard count
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    const oldCount = tune ? tune.heard_count : 0;

    // Animate button click
    button.style.backgroundColor = '#218838';
    setTimeout(() => {
        button.style.backgroundColor = '';
    }, 200);

    // Slide card back
    card.classList.remove('revealed');
    card.style.transform = '';

    // Call increment function with old count for toast message
    incrementHeardCountWithToast(personTuneId, oldCount);
}

function createTuneCard(tune) {
    const statusClass = `status-${tune.learn_status.replace(/ /g, '-')}`;
    const heardCountHTML = tune.learn_status === 'want to learn' && tune.heard_count > 0
        ? `<div class="heard-count-container">
               <span>Heard at sessions:</span>
               <span class="heard-count">${tune.heard_count}</span>
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Increment heard count">+</button>
           </div>`
        : tune.learn_status === 'want to learn'
        ? `<div class="heard-count-container">
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Mark as heard">+</button>
               <span style="font-size: 12px;">Mark as heard</span>
           </div>`
        : '';

    const thesessionUrl = buildTheSessionUrl(tune.tune_id, tune.setting_id);
    const thesessionLink = thesessionUrl
        ? `<a href="${thesessionUrl}" target="_blank" class="tune-action-btn" onclick="event.stopPropagation();">View on TheSession.org</a>`
        : '';

    // Determine what to show in the tune type badge based on sort mode
    const sortMode = sortModes[currentSortModeIndex];
    const isPopularityMode = sortMode.id === 'popularity-desc' || sortMode.id === 'popularity-asc';
    const isHeardMode = sortMode.id === 'heard-desc';
    const typeLabel = isPopularityMode
        ? (tune.tunebook_count || 0).toString()
        : isHeardMode
        ? (tune.heard_count || 0).toString()
        : tune.tune_type || '';

    // Add data attribute for swipe functionality on mobile
    const swipeAttr = `data-person-tune-id="${tune.person_tune_id}"`;

    // Show increment button for all tunes on mobile
    const canIncrement = true;

    // For mobile, wrap all cards in a container with the action button
    const isMobile = window.innerWidth <= 768;
    if (isMobile) {
        return `
            <div class="tune-card-swipe-container" ${swipeAttr}>
                <div class="tune-card-swipe-action">
                    <button class="swipe-action-btn" data-action="increment" data-person-tune-id="${tune.person_tune_id}">
                        <span class="swipe-action-icon">+</span>
                    </button>
                </div>
                <div class="tune-card tune-card-swipeable" onclick="showTuneDetail(${tune.person_tune_id}, event)">
                    <div class="tune-card-header">
                        <h3 class="tune-name">${tune.tune_name || 'Unknown'}</h3>
                        ${typeLabel ? `<span class="tune-type">${typeLabel}</span>` : ''}
                    </div>
                    <div class="tune-meta">
                        <div class="tune-meta-item">
                            <span class="status-badge ${statusClass}">${tune.learn_status}</span>
                        </div>
                        ${tune.tune_key ? `<div class="tune-meta-item">Key: ${tune.tune_key}</div>` : ''}
                    </div>
                    ${heardCountHTML}
                    <div class="tune-actions">
                        ${thesessionLink}
                    </div>
                </div>
            </div>
        `;
    } else {
        return `
            <div class="tune-card" ${swipeAttr} onclick="showTuneDetail(${tune.person_tune_id}, event)">
                <div class="tune-card-header">
                    <h3 class="tune-name">${tune.tune_name || 'Unknown'}</h3>
                    ${typeLabel ? `<span class="tune-type">${typeLabel}</span>` : ''}
                </div>
                <div class="tune-meta">
                    <div class="tune-meta-item">
                        <span class="status-badge ${statusClass}">${tune.learn_status}</span>
                    </div>
                    ${tune.tune_key ? `<div class="tune-meta-item">Key: ${tune.tune_key}</div>` : ''}
                </div>
                ${heardCountHTML}
                <div class="tune-actions">
                    ${thesessionLink}
                </div>
            </div>
        `;
    }
}

function clearFilters() {
    // Preserve the current search query
    const currentSearch = currentFilters.search;

    currentFilters = {
        search: currentSearch,  // Keep the search
        type: '',
        status: ''
    };

    // Don't clear the search input - keep it as is
    // document.getElementById('search-input').value = '';
    document.getElementById('type-filter').value = '';

    // Reset desktop dropdown
    const statusFilterSelect = document.getElementById('status-filter-select');
    if (statusFilterSelect) {
        statusFilterSelect.value = '';
    }

    // Reset mobile button to "All"
    currentStatusFilterIndex = 0;
    document.getElementById('status-filter-icon').textContent = 'All';
    document.getElementById('status-filter-btn').classList.remove('active');

    applyFilters();
}

function incrementHeardCount(personTuneId) {
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    const oldCount = tune ? tune.heard_count : 0;
    incrementHeardCountWithToast(personTuneId, oldCount);
}

function incrementHeardCountWithToast(personTuneId, oldCount) {
    // Optimistically update UI and show toast immediately
    const newCount = oldCount + 1;
    showMessage(`Heard count: ${oldCount} ‚Üí ${newCount}`, 'success');

    // Update local data immediately
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (tune) {
        tune.heard_count = newCount;
        applyFilters(); // Re-render
    }

    // Send update to server in background
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        // Silently sync the actual count from server
        if (tune && data.heard_count !== newCount) {
            tune.heard_count = data.heard_count;
            applyFilters(); // Re-render with actual count
        }
    })
    .catch(error => {
        console.error('Error incrementing heard count:', error);
        // Revert the optimistic update on error
        if (tune) {
            tune.heard_count = oldCount;
            applyFilters();
        }
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

// Wait for tunes to load, then open modal for specific tune
function waitForTuneAndOpen(personTuneId, attempts = 0) {
    const maxAttempts = 20; // 20 attempts * 250ms = 5 seconds max

    // Check if tune exists in allTunes
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);

    if (tune) {
        // Tune found, open modal
        showTuneDetail(personTuneId, null);
    } else if (attempts < maxAttempts) {
        // Keep waiting
        setTimeout(() => {
            waitForTuneAndOpen(personTuneId, attempts + 1);
        }, 250);
    } else {
        // Timeout - tune not found in local array after 5 seconds
        // Just open the modal anyway - it will fetch its own data from API
        showTuneDetail(personTuneId, null);
    }
}

function showTuneDetail(personTuneId, event) {
    // Stop the click from propagating
    if (event) {
        event.stopPropagation();
    }

    // Find the tune in our local data to get basic info for loading state
    // This is just for the initial display - the modal will fetch full data from API
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);

    // Use the unified tune detail modal
    // The modal will fetch its own data, so we don't need to fail if tune isn't in local array
    TuneDetailModal.show({
        context: 'my_tunes',
        tuneId: tune ? tune.tune_id : null,
        apiEndpoint: `/api/my-tunes/${personTuneId}`,
        onSave: function() {
            // Refresh the tunes list
            loadTunes();
        },
        additionalData: {
            personTuneId: personTuneId,
            tuneName: tune ? tune.tune_name : 'Loading...',
            tuneType: tune ? tune.tune_type : '',
            isUserLoggedIn: true
        }
    });
}

function displayTuneDetailModalBasic(tune) {
    console.log('=== displayTuneDetailModalBasic called ===');
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon - we can show this immediately if we have tune_id
    // Use setting_id if available to link to specific setting
    const thesessionUrl = buildTheSessionUrl(tune.tune_id, tune.setting_id);
    const thesessionLinkIcon = thesessionUrl
        ? `<a href="${thesessionUrl}" target="_blank" class="thesession-link-icon" title="View on TheSession.org" onclick="event.stopPropagation();">üîó</a>`
        : '';

    // Show basic info with notes populated from local data
    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title modal-tune-title-editable" id="modal-tune-title" onclick="toggleNameAliasEdit()" title="Click to set custom name">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-field-section" id="name-alias-section" style="display: none;">
            <label class="modal-field-label">I call this:</label>
            <input type="text" id="modal-name-alias-input" class="modal-field-input" placeholder="Enter your custom name for this tune" value="${tune.name_alias || ''}" oninput="onModalFieldChange()">
            <div class="name-alias-hint">Click title again to hide this field</div>
        </div>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="onModalFieldChange()">
                ${statusOptions}
            </select>
        </div>
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <textarea id="modal-notes-textarea" class="modal-notes-textarea" placeholder="Add notes about this tune..." oninput="onModalFieldChange()">${tune.notes || ''}</textarea>
        </div>
        <div class="modal-field-section">
            <label class="modal-field-label">If you play a specific setting of the tune, enter the URL or setting ID here:</label>
            <input type="text" id="modal-setting-id-input" class="modal-field-input" placeholder="e.g., 123 or paste URL" value="${tune.setting_id || ''}" oninput="onSettingIdInput()">
            <div id="modal-setting-id-error" class="modal-field-error" style="display: none;"></div>
        </div>
        <div class="heard-count-row">
            <div class="heard-count-label">I've heard this <span id="modal-heard-count-value">${tune.heard_count || 0}</span> <span id="modal-heard-count-unit">${(tune.heard_count || 0) === 1 ? 'time' : 'times'}</span></div>
            <div class="heard-count-controls">
                <button class="heard-count-btn heard-count-btn-decrement" onclick="decrementHeardCountModal()" title="Decrement heard count" ${(tune.heard_count || 0) === 0 ? 'disabled' : ''}>-</button>
                <button class="heard-count-btn heard-count-btn-increment" onclick="incrementHeardCountModal()" title="Increment heard count">+</button>
            </div>
        </div>
        <div class="modal-button-group">
            <button id="modal-cancel-btn" class="modal-cancel-btn" onclick="closeTuneDetailModal()">Cancel</button>
            <button id="modal-save-btn" class="modal-save-btn" onclick="saveModalChanges()" disabled>Save</button>
        </div>
        <div class="modal-remove-link-container">
            <a href="#" id="modal-remove-link" class="modal-remove-link" onclick="removeTuneFromMyTunes(); return false;">Remove From My Tunes</a>
        </div>
        <div id="modal-additional-info">
            <div class="modal-info-line">TheSession.org Tunebooks: <span class="loading-dots">...</span></div>
            <div class="modal-info-line">Play count at your sessions: <span class="loading-dots">...</span></div>
        </div>
    `;

    // Store current tune ID and original values for updates (from local data)
    modal.dataset.personTuneId = tune.person_tune_id;
    modal.dataset.originalStatus = tune.learn_status;
    modal.dataset.originalNotes = tune.notes || '';
    modal.dataset.originalSettingId = tune.setting_id || '';
    modal.dataset.originalNameAlias = tune.name_alias || '';
    modal.dataset.currentHeardCount = tune.heard_count || 0;

    // Show modal
    console.log('SHOWING MODAL - setting display = flex');
    console.log('Modal current display:', modal.style.display);
    modal.style.display = 'flex';
    console.log('Modal display after setting:', modal.style.display);

    // Add 'show' class after a small delay to trigger slide-in animation
    setTimeout(() => {
        modal.classList.add('show');
    }, 10);

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('modalShowTime set to:', modalShowTime);
    console.log('=== END displayTuneDetailModalBasic ===');
}

function displayTuneDetailModalFull(tune) {
    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">üîó</a>`
        : '';

    // Update the title to include the link - show name_alias if it exists, otherwise tune_name
    const displayName = tune.name_alias || tune.tune_name || 'Unknown Tune';
    const modalTitle = document.querySelector('.modal-tune-title');
    if (modalTitle) {
        modalTitle.innerHTML = `${displayName} ${thesessionLinkIcon}`;
    }

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    // Don't update any editable fields (notes, setting_id, name_alias) - they're already populated
    // from local data and the user may have started editing them

    // Build full additional info (just the read-only stats)
    const additionalInfo = `
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}
    `;

    // Replace the loading dots with the full info
    const additionalInfoDiv = document.getElementById('modal-additional-info');
    if (additionalInfoDiv) {
        additionalInfoDiv.innerHTML = additionalInfo;
    }

    // Update heard count display
    updateHeardCountDisplay(tune.heard_count || 0);

    // Update button states
    updateHeardCountButtonStates();

    // Update heard count in dataset (this can change via the API)
    // Don't update other original values - they're already set from local data
    const modal = document.getElementById('tune-detail-modal');
    modal.dataset.currentHeardCount = tune.heard_count || 0;
}

function displayTuneDetailModal(tune) {
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">üîó</a>`
        : '';

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="updateStatusFromModal(${tune.person_tune_id})">
                ${statusOptions}
            </select>
        </div>
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}

        ${tune.notes ? `
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <p>${tune.notes}</p>
        </div>` : ''}
    `;

    // Store current tune ID for updates
    modal.dataset.personTuneId = tune.person_tune_id;

    // Show modal
    console.log('Showing modal - display: flex');
    modal.style.display = 'flex';

    // Add 'show' class after a small delay to trigger slide-in animation
    setTimeout(() => {
        modal.classList.add('show');
    }, 10);

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('Set modalShowTime to', modalShowTime);
}

function closeTuneDetailModal() {
    console.log('=== closeTuneDetailModal called ===');
    console.log('Stack trace:');
    console.trace();

    // Abort any in-progress modal fetch
    if (modalFetchController) {
        console.log('Aborting modal fetch request due to modal close');
        modalFetchController.abort();
        modalFetchController = null;
    }

    const modal = document.getElementById('tune-detail-modal');

    // Remove 'show' class to trigger slide-out animation
    modal.classList.remove('show');

    // Wait for animation to complete before hiding
    setTimeout(() => {
        modal.style.display = 'none';
        console.log('Modal closed');
    }, 300); // Match the CSS transition duration
}

function incrementHeardCountFromModal(personTuneId) {
    const loading = showLoading('Updating heard count...');
    
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        loading.hide();
        showMessage('Heard count updated!', 'success');
        
        // Update the tune in our local data
        const tune = allTunes.find(t => t.person_tune_id === personTuneId);
        if (tune) {
            tune.heard_count = data.heard_count;
            applyFilters(); // Re-render
        }
        
        // Update the modal display
        const heardCountSpan = document.getElementById('modal-heard-count');
        if (heardCountSpan) {
            heardCountSpan.textContent = data.heard_count;
        }
    })
    .catch(error => {
        loading.hide();
        console.error('Error incrementing heard count:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function toggleNameAliasEdit() {
    const section = document.getElementById('name-alias-section');
    if (section) {
        const isHidden = section.style.display === 'none';
        section.style.display = isHidden ? 'block' : 'none';
        if (isHidden) {
            // Focus the input when shown
            const input = document.getElementById('modal-name-alias-input');
            if (input) {
                setTimeout(() => input.focus(), 100);
            }
        }
    }
}

function updateHeardCountDisplay(count) {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const heardCountUnit = document.getElementById('modal-heard-count-unit');

    if (heardCountValue) {
        heardCountValue.textContent = count;
    }

    if (heardCountUnit) {
        heardCountUnit.textContent = count === 1 ? 'time' : 'times';
    }
}

function updateHeardCountButtonStates() {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const decrementBtn = document.querySelector('.heard-count-btn-decrement');
    const incrementBtn = document.querySelector('.heard-count-btn-increment');

    if (heardCountValue && decrementBtn && incrementBtn) {
        const currentCount = parseInt(heardCountValue.textContent) || 0;

        // Enable both buttons (data is loaded)
        incrementBtn.disabled = false;

        // Disable decrement only if count is 0
        decrementBtn.disabled = currentCount === 0;
    }
}

function incrementHeardCountModal() {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const modal = document.getElementById('tune-detail-modal');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    if (!heardCountValue) return;

    const currentCount = parseInt(heardCountValue.textContent) || 0;
    const newCount = currentCount + 1;

    // Update UI immediately
    updateHeardCountDisplay(newCount);
    updateHeardCountButtonStates();

    // Update the tune in our local data
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (tune) {
        tune.heard_count = newCount;
        applyFilters(); // Re-render
    }

    // Update stored count
    modal.dataset.currentHeardCount = newCount;

    // Send update to server in background
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ heard_count: newCount })
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        if (!data.success) {
            throw new Error(data.error || 'Failed to update heard count');
        }
        // Success - no toast, already updated UI
    })
    .catch(error => {
        console.error('Error incrementing heard count:', error);
        // Revert the change on error
        updateHeardCountDisplay(currentCount);
        updateHeardCountButtonStates();
        if (tune) {
            tune.heard_count = currentCount;
            applyFilters();
        }
        modal.dataset.currentHeardCount = currentCount;

        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function decrementHeardCountModal() {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const modal = document.getElementById('tune-detail-modal');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    if (!heardCountValue) return;

    const currentCount = parseInt(heardCountValue.textContent) || 0;
    if (currentCount === 0) return; // Can't go below zero

    const newCount = currentCount - 1;

    // Update UI immediately
    updateHeardCountDisplay(newCount);
    updateHeardCountButtonStates();

    // Update the tune in our local data
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (tune) {
        tune.heard_count = newCount;
        applyFilters(); // Re-render
    }

    // Update stored count
    modal.dataset.currentHeardCount = newCount;

    // Send update to server in background
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ heard_count: newCount })
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        if (!data.success) {
            throw new Error(data.error || 'Failed to update heard count');
        }
        // Success - no toast, already updated UI
    })
    .catch(error => {
        console.error('Error decrementing heard count:', error);
        // Revert the change on error
        updateHeardCountDisplay(currentCount);
        updateHeardCountButtonStates();
        if (tune) {
            tune.heard_count = currentCount;
            applyFilters();
        }
        modal.dataset.currentHeardCount = currentCount;

        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function onModalFieldChange() {
    // Enable/disable the Save button based on whether any field changed
    const modal = document.getElementById('tune-detail-modal');
    const statusSelect = document.getElementById('modal-status-select');
    const textarea = document.getElementById('modal-notes-textarea');
    const settingIdInput = document.getElementById('modal-setting-id-input');
    const nameAliasInput = document.getElementById('modal-name-alias-input');
    const saveBtn = document.getElementById('modal-save-btn');

    const originalStatus = modal.dataset.originalStatus || '';
    const originalNotes = modal.dataset.originalNotes || '';
    const originalSettingId = modal.dataset.originalSettingId || '';
    const originalNameAlias = modal.dataset.originalNameAlias || '';

    if (saveBtn) {
        const statusChanged = statusSelect && (statusSelect.value !== originalStatus);
        const notesChanged = textarea && (textarea.value !== originalNotes);

        // For setting ID, extract the numeric value and compare
        const currentSettingId = settingIdInput ? extractSettingId(settingIdInput.value) : null;
        const originalSettingIdNum = originalSettingId ? parseInt(originalSettingId) : null;
        const settingIdChanged = (currentSettingId !== originalSettingIdNum);

        const nameAliasChanged = nameAliasInput && (nameAliasInput.value !== originalNameAlias);

        const anyChanges = statusChanged || notesChanged || settingIdChanged || nameAliasChanged;

        saveBtn.disabled = !anyChanges;

        // Make button blue when enabled
        if (anyChanges) {
            saveBtn.style.backgroundColor = 'var(--primary)';
            saveBtn.style.opacity = '1';
        } else {
            saveBtn.style.backgroundColor = '';
            saveBtn.style.opacity = '';
        }
    }
}

function saveModalChanges() {
    const modal = document.getElementById('tune-detail-modal');
    const statusSelect = document.getElementById('modal-status-select');
    const textarea = document.getElementById('modal-notes-textarea');
    const settingIdInput = document.getElementById('modal-setting-id-input');
    const nameAliasInput = document.getElementById('modal-name-alias-input');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    const newStatus = statusSelect ? statusSelect.value : '';
    const newNotes = textarea ? textarea.value : '';
    const newSettingIdRaw = settingIdInput ? settingIdInput.value : '';
    const newNameAlias = nameAliasInput ? nameAliasInput.value : '';

    // Validate setting ID before proceeding
    const settingIdValidation = validateSettingId(newSettingIdRaw);
    if (!settingIdValidation.valid) {
        const errorDiv = document.getElementById('modal-setting-id-error');
        if (errorDiv) {
            errorDiv.textContent = settingIdValidation.error;
            errorDiv.style.display = 'block';
        }
        if (settingIdInput) {
            settingIdInput.style.borderColor = '#dc3545';
        }
        return; // Don't proceed with save
    }

    const originalStatus = modal.dataset.originalStatus || '';
    const originalNotes = modal.dataset.originalNotes || '';
    const originalSettingId = modal.dataset.originalSettingId || '';
    const originalNameAlias = modal.dataset.originalNameAlias || '';

    const statusChanged = (newStatus !== originalStatus);
    const notesChanged = (newNotes !== originalNotes);

    // Extract numeric setting ID
    const newSettingId = settingIdValidation.settingId;
    const originalSettingIdNum = originalSettingId ? parseInt(originalSettingId) : null;
    const settingIdChanged = (newSettingId !== originalSettingIdNum);

    const nameAliasChanged = (newNameAlias !== originalNameAlias);

    // Don't save if nothing changed
    if (!statusChanged && !notesChanged && !settingIdChanged && !nameAliasChanged) {
        return;
    }

    // Disable save button while saving
    const saveBtn = document.getElementById('modal-save-btn');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
    }

    // Build update payload - only include changed fields
    const updates = {};
    if (statusChanged) updates.learn_status = newStatus;
    if (notesChanged) updates.notes = newNotes;
    if (settingIdChanged) updates.setting_id = newSettingId;
    if (nameAliasChanged) updates.name_alias = newNameAlias || null; // Convert empty string to null

    // Call unified API endpoint
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updates)
    })
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                showMessage('Changes saved successfully!', 'success');

                // Update original values in modal
                modal.dataset.originalStatus = newStatus;
                modal.dataset.originalNotes = newNotes;
                modal.dataset.originalSettingId = newSettingId || '';
                modal.dataset.originalNameAlias = newNameAlias;

                // Update the tune in our local data
                const tune = allTunes.find(t => t.person_tune_id === personTuneId);
                if (tune) {
                    if (statusChanged) {
                        tune.learn_status = newStatus;
                        if (newStatus === 'learned') {
                            tune.learned_date = new Date().toISOString();
                        }
                    }
                    if (notesChanged) tune.notes = newNotes;
                    if (settingIdChanged) tune.setting_id = newSettingId;
                    if (nameAliasChanged) {
                        tune.name_alias = newNameAlias || null;
                        // Update tune_name to reflect the change
                        // The backend returns the updated tune with the correct tune_name,
                        // but we need to update it locally for immediate display
                        if (data.person_tune && data.person_tune.tune_name) {
                            tune.tune_name = data.person_tune.tune_name;
                        }
                    }
                }

                // Update the modal title if name alias or setting changed
                if (nameAliasChanged || settingIdChanged) {
                    const modalTitle = document.querySelector('.modal-tune-title');
                    if (modalTitle && tune) {
                        const displayName = tune.name_alias || tune.tune_name || 'Unknown Tune';
                        const thesessionUrl = buildTheSessionUrl(tune.tune_id, tune.setting_id);
                        const linkHtml = thesessionUrl
                            ? `<a href="${thesessionUrl}" target="_blank" class="thesession-link-icon" title="View on TheSession.org" onclick="event.stopPropagation();">üîó</a>`
                            : '';
                        modalTitle.innerHTML = `${displayName} ${linkHtml}`;
                    }
                }

                // Re-render the grid to show changes
                applyFilters();

                // Reset button
                if (saveBtn) {
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Save';
                    saveBtn.style.backgroundColor = '';
                    saveBtn.style.opacity = '';
                }

                // Close modal after successful save
                closeTuneDetailModal();
            } else {
                throw new Error(data.error || 'Failed to save changes');
            }
        })
        .catch(error => {
            console.error('Error saving changes:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');

            // Re-enable button
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save';
            }
        });
}

function removeTuneFromMyTunes() {
    const modal = document.getElementById('tune-detail-modal');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    // Get tune name for confirmation
    const tuneName = document.querySelector('.modal-tune-title').textContent.replace('üîó', '').trim();

    // Confirm deletion
    if (!confirm(`Are you sure you want to remove "${tuneName}" from your tune collection? This action cannot be undone.`)) {
        return;
    }

    // Disable the remove link during deletion
    const removeLink = document.getElementById('modal-remove-link');
    if (removeLink) {
        removeLink.style.opacity = '0.5';
        removeLink.style.pointerEvents = 'none';
    }

    // Call DELETE endpoint
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        method: 'DELETE'
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            showMessage(`"${tuneName}" removed from your collection`, 'success');

            // Remove from local allTunes array
            const index = allTunes.findIndex(t => t.person_tune_id === personTuneId);
            if (index >= 0) {
                allTunes.splice(index, 1);
            }

            // Close modal
            closeTuneDetailModal();

            // Re-render the grid
            applyFilters();
        } else {
            throw new Error(data.error || 'Failed to remove tune');
        }
    })
    .catch(error => {
        console.error('Error removing tune:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');

        // Re-enable the remove link
        if (removeLink) {
            removeLink.style.opacity = '';
            removeLink.style.pointerEvents = '';
        }
    });
}

function showMessage(message, type) {
    // Create a temporary message element
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        border-radius: 4px;
        z-index: 10002;
        max-width: 500px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        animation: slideDown 0.3s ease-out;
    `;

    if (type === 'success') {
        messageDiv.style.backgroundColor = '#d4edda';
        messageDiv.style.color = '#155724';
        messageDiv.style.border = '1px solid #c3e6cb';
    } else if (type === 'error') {
        messageDiv.style.backgroundColor = '#f8d7da';
        messageDiv.style.color = '#721c24';
        messageDiv.style.border = '1px solid #f5c6cb';
    } else {
        messageDiv.style.backgroundColor = '#d1ecf1';
        messageDiv.style.color = '#0c5460';
        messageDiv.style.border = '1px solid #bee5eb';
    }

    messageDiv.textContent = message;
    document.body.appendChild(messageDiv);

    // Remove after 5 seconds
    setTimeout(() => {
        messageDiv.style.animation = 'slideUp 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(messageDiv);
        }, 300);
    }, 5000);
}

// Handle Add button click to pass search query as URL parameter
function handleAddTuneClick(event) {
    // Get current search value
    const searchInput = document.getElementById('search-input');
    const searchValue = searchInput ? searchInput.value.trim() : '';

    // If there's a search query, pass it along to the add page
    if (searchValue.length > 0) {
        event.preventDefault();
        window.location.href = `/my-tunes/add?q=${encodeURIComponent(searchValue)}`;
        return;
    }

    // Otherwise, just navigate normally (event will not be prevented)
}
</script>

{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/swipe-listener.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/my_tunes_mobile.js') }}"></script>
<script src="{{ url_for('static', filename='js/tune_detail_modal.js') }}"></script>
{% endblock %}
