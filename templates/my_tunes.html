{% extends "base.html" %}

{% block title %}My Tunes - Personal Tune Collection{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/my_tunes_mobile.css') }}">
<style>
    .my-tunes-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    /* Mobile compact view */
    @media (max-width: 768px) {
        /* Override parent container padding */
        .docs-content {
            padding: 0 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        .my-tunes-container {
            padding: 0;
            max-width: 100%;
            margin-top: 0;
            margin-left: 0;
            margin-right: 0;
        }

        .page-header {
            margin-bottom: 4px;
            padding: 0 2px;
        }

        .filters-container {
            margin-bottom: 6px;
            padding: 0 2px;
        }

        .results-count {
            margin-bottom: 4px;
            font-size: 12px;
            padding: 0 2px;
        }
    }

    .page-header {
        margin-bottom: 30px;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }

    .page-header h1 {
        margin: 0;
    }

    .page-actions {
        display: flex;
        flex-direction: row;
        gap: 8px;
        align-items: center;
        margin-left: auto;
    }

    .btn {
        padding: 4px 12px;
        background-color: var(--primary);
        color: white !important;
        text-decoration: none;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 13px;
        transition: background-color 0.2s;
        white-space: nowrap;
        line-height: 1.2;
    }

    .btn:hover {
        background-color: var(--primary-dark, #0056b3);
        color: white !important;
        text-decoration: none;
    }

    .btn-secondary {
        background-color: var(--secondary, #6c757d);
        color: white !important;
    }

    .btn-secondary:hover {
        background-color: var(--secondary-dark, #5a6268);
        color: white !important;
    }

    .filters-container {
        margin-bottom: 20px;
    }

    .filter-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: nowrap;
    }

    .filter-group {
        display: flex;
        align-items: center;
        min-width: 0;
    }

    .filter-group:first-child {
        flex: 1;
        min-width: 0;
    }

    .filter-group label {
        display: none;
    }

    .filter-input {
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        width: 100%;
        min-width: 0;
        max-width: 200px;
    }

    .filter-select {
        padding: 8px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        width: 110px;
        flex-shrink: 0;
    }

    .status-filter-btn {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 60px;
        justify-content: center;
        flex-shrink: 0;
    }

    .status-filter-btn:hover {
        background-color: var(--hover-bg);
    }

    .status-filter-btn.active {
        background-color: var(--primary);
        color: white;
        border-color: var(--primary);
    }

    .tunes-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    /* Mobile compact tune list */
    @media (max-width: 768px) {
        .tunes-grid {
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-bottom: 10px;
        }
    }

    .tune-card {
        background-color: var(--bg-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        transition: box-shadow 0.2s, transform 0.2s;
        cursor: pointer;
    }

    @media (max-width: 768px) {
        .tune-card {
            border-radius: 0;
            border-left: none;
            border-right: none;
            border-top: none;
            padding: 6px 2px;
            display: grid;
            grid-template-columns: 20px 1fr auto;
            grid-template-rows: auto; /* Single row only */
            grid-auto-rows: 0; /* Make any extra rows have 0 height */
            align-items: center;
            gap: 6px;
            max-width: 100%;
            overflow: hidden;
            min-height: 0; /* Prevent extra height */
        }

        .tune-card:first-child {
            border-top: 1px solid var(--border-color);
        }

        /* Force all direct children to be on row 1 or hidden */
        .tune-card > * {
            grid-row: 1;
        }
    }

    .tune-card:hover {
        box-shadow: 0 4px 12px var(--dropdown-shadow);
        transform: translateY(-2px);
    }

    @media (max-width: 768px) {
        .tune-card:hover {
            box-shadow: none;
            transform: none;
            background-color: var(--hover-bg);
        }
    }

    .tune-card-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        margin-bottom: 15px;
    }

    @media (max-width: 768px) {
        .tune-card-header {
            /* Span columns 2-3, contains both tune-name and tune-type */
            grid-column: 2 / 4;
            grid-row: 1;
            margin-bottom: 0;
            min-width: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 6px;
        }
    }

    .tune-name {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-color);
        margin: 0;
        flex: 1;
    }

    @media (max-width: 768px) {
        .tune-name {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
            max-width: calc(100vw - 135px); /* Reserve space for status (26px with gap) + tune type ("Barndance" ~90px with padding) + gaps (~19px) */
            flex: 0 1 auto; /* Don't grow, allow shrink */
        }
    }

    .tune-type {
        font-size: 12px;
        padding: 4px 8px;
        background-color: var(--primary);
        color: white;
        border-radius: 4px;
        text-transform: capitalize;
        white-space: nowrap;
        margin-left: 10px;
    }

    @media (max-width: 768px) {
        .tune-type {
            font-size: 10px;
            padding: 2px 6px;
            margin-left: 0;
            flex-shrink: 0; /* Never shrink */
            white-space: nowrap;
        }
    }

    .tune-meta {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 15px;
        font-size: 14px;
        color: var(--text-muted, #6c757d);
    }

    @media (max-width: 768px) {
        .tune-meta {
            /* Don't participate in grid - let status-badge position itself */
            display: contents; /* Make children direct grid participants */
        }
    }

    .tune-meta-item {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    @media (max-width: 768px) {
        .tune-meta-item {
            /* Don't participate in grid - let status-badge position itself */
            display: contents; /* Make children direct grid participants */
        }

        /* Hide the "Key: X" meta item on mobile */
        .tune-meta-item:not(:first-child) {
            display: none !important;
        }

        /* Ensure only the first meta-item participates */
        .tune-meta-item:first-child {
            display: contents;
        }
    }

    .status-badge {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        text-transform: capitalize;
    }

    @media (max-width: 768px) {
        .status-badge {
            /* Grid column 1: fixed 20px column */
            grid-column: 1;
            grid-row: 1;
            padding: 0;
            border-radius: 0;
            font-size: 16px;
            background-color: transparent !important;
            width: 20px;
            height: 20px;
            min-width: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .status-badge::before {
            font-size: 16px;
        }

        .status-want-to-learn::before {
            content: '‚òÖ';
            color: #f0ad4e;
        }

        .status-learning::before {
            content: '‚ãØ';
            color: #5bc0de;
        }

        .status-learned::before {
            content: '‚úì';
            color: #5cb85c;
        }

        /* Hide the text on mobile */
        .status-badge {
            font-size: 0;
        }
    }

    .status-want-to-learn {
        background-color: #fff3cd;
        color: #856404;
    }

    .status-learning {
        background-color: #d1ecf1;
        color: #0c5460;
    }

    .status-learned {
        background-color: #d4edda;
        color: #155724;
    }

    .tune-actions {
        display: flex;
        gap: 10px;
        margin-top: 15px;
    }

    @media (max-width: 768px) {
        .tune-actions {
            display: none !important; /* Force hide completely */
        }
    }

    .tune-action-btn {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        background-color: var(--bg-color);
        color: var(--text-color);
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: background-color 0.2s;
        text-align: center;
        text-decoration: none;
    }

    .tune-action-btn:hover {
        background-color: var(--hover-bg);
        text-decoration: none;
        color: var(--text-color);
    }

    .heard-count-container {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 10px;
        padding: 8px;
        background-color: var(--light);
        border-radius: 4px;
    }

    @media (max-width: 768px) {
        .heard-count-container {
            display: none !important; /* Force hide completely */
        }
    }

    .heard-count {
        font-weight: 600;
        color: var(--primary);
    }

    .increment-heard-btn {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 1px solid var(--primary);
        background-color: var(--bg-color);
        color: var(--primary);
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .increment-heard-btn:hover {
        background-color: var(--primary);
        color: white;
    }

    .no-results {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted, #6c757d);
    }

    .no-results h3 {
        margin-bottom: 10px;
    }

    .loading {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted, #6c757d);
    }

    .results-count {
        margin-bottom: 15px;
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
    }

    .sort-toggle {
        padding: 4px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        user-select: none;
    }

    .sort-toggle:hover {
        background-color: var(--hover-bg);
    }

    .sort-toggle.active {
        background-color: var(--primary);
        color: white;
        border-color: var(--primary);
    }

    @media (max-width: 768px) {
        .results-count {
            font-size: 12px;
            gap: 6px;
            flex-wrap: wrap;
        }

        .sort-toggle {
            font-size: 11px;
            padding: 3px 6px;
        }
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
        .my-tunes-container {
            padding: 15px;
        }

        .page-header {
            gap: 6px;
        }

        .page-header h1 {
            font-size: 22px;
        }

        .btn {
            padding: 4px 10px;
            font-size: 12px;
        }

        .page-actions {
            gap: 6px;
        }

        .tunes-grid {
            grid-template-columns: 1fr;
            gap: 0; /* No gap between rows in mobile */
        }

        .filters-container {
            margin-bottom: 15px;
        }

        .filter-row {
            gap: 5px;
        }

        .filter-input {
            font-size: 14px;
            padding: 8px 6px;
            max-width: none;
        }

        .filter-select {
            width: 85px;
            font-size: 13px;
            padding: 8px 4px;
        }

        .status-filter-btn {
            padding: 8px 6px;
            font-size: 13px;
            min-width: 45px;
            gap: 4px;
        }

        /* Touch-friendly button sizes */
        .tune-action-btn,
        .increment-heard-btn {
            min-height: 44px;
            min-width: 44px;
        }
    }

    /* Dark mode adjustments */
    [data-theme="dark"] .status-want-to-learn {
        background-color: #664d03;
        color: #ffecb5;
    }

    [data-theme="dark"] .status-learning {
        background-color: #055160;
        color: #b6effb;
    }

    [data-theme="dark"] .status-learned {
        background-color: #0f5132;
        color: #badbcc;
    }

    /* Loading dots animation */
    .loading-dots {
        font-weight: bold;
        display: inline-block;
        animation: pulse-dots 1.5s ease-in-out infinite;
    }

    @keyframes pulse-dots {
        0%, 100% {
            opacity: 0.3;
        }
        50% {
            opacity: 1;
        }
    }

    /* Tune Detail Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 10000;
        display: none;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
    }

    .modal-dialog {
        background: var(--bg-color, white);
        border-radius: 8px;
        padding: 0;
        max-width: 600px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        color: var(--text-color);
        position: relative;
        pointer-events: auto;
        z-index: 1;
    }

    #tune-detail-content {
        padding: 20px;
    }

    .modal-close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 28px;
        color: var(--text-muted, #999);
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }

    .modal-close-btn:hover {
        color: var(--text-color);
    }

    .modal-tune-title {
        margin: 0 32px 12px 0;
        color: var(--text-color);
        font-size: 22px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .thesession-link-icon {
        font-size: 18px;
        text-decoration: none;
        color: var(--primary);
        opacity: 0.8;
    }

    .thesession-link-icon:hover {
        opacity: 1;
    }

    .modal-header-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
        width: 100%;
    }

    .modal-status-select {
        padding: 6px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        flex: 1;
        min-width: 0;
    }

    .modal-save-btn {
        padding: 6px 16px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
    }

    .modal-save-btn:hover:not(:disabled) {
        background-color: var(--primary-dark, #0056b3);
    }

    .modal-save-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        opacity: 0.6;
    }

    .modal-info-line {
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        margin-bottom: 8px;
    }

    .modal-session-play-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
    }

    .modal-view-btn {
        padding: 4px 12px;
        background-color: var(--primary);
        color: white !important;
        text-decoration: none;
        border-radius: 4px;
        font-size: 13px;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .modal-view-btn:hover {
        background-color: var(--primary-dark, #0056b3);
        color: white !important;
        text-decoration: none;
    }

    .modal-notes-section {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--border-color);
    }

    .modal-notes-label {
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--text-color);
    }

    .modal-notes-section p {
        margin: 0;
        color: var(--text-color);
        font-size: 14px;
        line-height: 1.5;
    }

    /* Mobile adjustments for modal */
    @media (max-width: 768px) {
        .modal-dialog {
            width: 95%;
            max-height: 95vh;
        }

        #tune-detail-content {
            padding: 16px;
        }

        .modal-tune-title {
            font-size: 18px;
            margin-right: 28px;
        }

        .modal-close-btn {
            font-size: 24px;
            width: 28px;
            height: 28px;
        }

        .modal-header-row {
            flex-wrap: wrap;
        }

        .modal-status-select {
            max-width: none;
        }

        .modal-info-line {
            font-size: 13px;
        }

        .modal-session-play-row {
            flex-direction: row;
            align-items: center;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="my-tunes-container">
    <div class="page-header">
        <h1>My Tunes</h1>
        <div class="page-actions">
            <a href="/my-tunes/add" class="btn">Add</a>
            <a href="/my-tunes/sync" class="btn btn-secondary">Sync</a>
        </div>
    </div>

    <div class="filters-container">
        <div class="filter-row">
            <div class="filter-group">
                <input
                    type="text"
                    id="search-input"
                    class="filter-input"
                    placeholder="Search"
                    title="Search tunes"
                    autocomplete="off"
                >
            </div>
            <div class="filter-group">
                <select id="type-filter" class="filter-select" title="Tune type">
                    <option value="">All Types</option>
                </select>
            </div>
            <div class="filter-group">
                <button id="status-filter-btn" class="status-filter-btn" onclick="cycleStatusFilter()" title="Filter by learning status">
                    <span id="status-filter-icon">All</span>
                </button>
            </div>
        </div>
    </div>

    <div class="results-count">
        <span id="results-count-text"></span>
        <button id="sort-toggle" class="sort-toggle" onclick="cycleSortMode()" title="Toggle sort order">
            <span id="sort-icon">a-z</span>
        </button>
    </div>

    <div id="loading" class="loading" style="display: none;">
        <p>Loading your tunes...</p>
    </div>

    <div id="no-results" class="no-results" style="display: none;">
        <h3>No tunes found</h3>
        <p>Try adjusting your filters or add your first tune to get started!</p>
    </div>

    <div class="tunes-grid" id="tunes-grid">
        <!-- Tune cards will be inserted here by JavaScript -->
    </div>
</div>

<!-- Tune Detail Modal -->
<div id="tune-detail-modal" class="modal-overlay">
    <div class="modal-dialog">
        <div id="tune-detail-content">
            <!-- Content will be inserted by JavaScript -->
        </div>
    </div>
</div>

<script>
// Helper functions for API calls
function fetchWithRetry(url, options = {}) {
    return fetch(url, options);
}

function handleApiError(error, response = null) {
    if (response) {
        if (response.status === 401) {
            return { message: 'Please log in again', action: () => window.location.href = '/login' };
        }
        if (response.status === 404) {
            return { message: 'Not found', retryable: false };
        }
        if (response.status >= 500) {
            return { message: 'Server error. Please try again.', retryable: true };
        }
        return { message: 'An error occurred. Please try again.', retryable: true };
    }
    return { message: error?.message || 'An error occurred', retryable: true };
}

function showLoading(message = 'Loading...') {
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loading-overlay';
    loadingDiv.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(255,255,255,0.9); z-index: 9999;
        display: flex; align-items: center; justify-content: center;
        flex-direction: column; gap: 15px;
    `;
    loadingDiv.innerHTML = `
        <div style="width: 40px; height: 40px; border: 4px solid #ddd;
                    border-top-color: #007bff; border-radius: 50%;
                    animation: spin 0.8s linear infinite;"></div>
        <div style="color: #333; font-size: 16px;">${message}</div>
    `;
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
    document.body.appendChild(loadingDiv);
    return {
        hide: () => {
            if (loadingDiv.parentNode) loadingDiv.parentNode.removeChild(loadingDiv);
            if (style.parentNode) style.parentNode.removeChild(style);
        }
    };
}

let allTunes = [];
let filteredTunes = [];
let currentFilters = {
    search: '',
    type: '',
    status: ''
};
let modalShowTime = 0;
let modalFetchController = null; // AbortController for modal fetch requests

// Status filter cycle states
const statusFilterStates = [
    { value: '', label: 'All', icon: 'All' },
    { value: 'learned', label: 'Learned', icon: '‚úì' },
    { value: 'learning', label: 'Learning', icon: '‚ãØ' },
    { value: 'want to learn', label: 'Want to Learn', icon: '‚òÖ' }
];
let currentStatusFilterIndex = 0;

// Sort mode cycle states
const sortModes = [
    { id: 'alpha-asc', label: 'a-z', icon: 'a-z', sortFn: (a, b) => (a.tune_name || '').localeCompare(b.tune_name || '') },
    { id: 'alpha-desc', label: 'z-a', icon: 'z-a', sortFn: (a, b) => (b.tune_name || '').localeCompare(a.tune_name || '') },
    { id: 'popularity-desc', label: 'popularity high', icon: '#', sortFn: (a, b) => (b.tunebook_count || 0) - (a.tunebook_count || 0) },
    { id: 'popularity-asc', label: 'popularity low', icon: '#Íúú', sortFn: (a, b) => (a.tunebook_count || 0) - (b.tunebook_count || 0) }
];
let currentSortModeIndex = 0;

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadTunes();
    setupEventListeners();
    loadFiltersFromURL();
    checkForSuccessMessage();
});

function checkForSuccessMessage() {
    const params = new URLSearchParams(window.location.search);
    if (params.has('added')) {
        const tuneName = params.get('added');
        showMessage(`Successfully added "${tuneName}" to your collection!`, 'success');
        // Clean up URL
        params.delete('added');
        const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
        window.history.replaceState({}, '', newURL);
    }
}

function setupEventListeners() {
    // Search input with debounce
    let searchTimeout;
    document.getElementById('search-input').addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            currentFilters.search = e.target.value.toLowerCase().trim();
            applyFilters();
        }, 300);
    });

    // Filter dropdowns
    document.getElementById('type-filter').addEventListener('change', function(e) {
        currentFilters.type = e.target.value;
        applyFilters();
    });

    // Modal overlay click handler - close when clicking outside
    const modalOverlay = document.getElementById('tune-detail-modal');

    // Add click handler to modal dialog to stop propagation
    const setupModalDialogHandler = () => {
        const modalDialog = modalOverlay.querySelector('.modal-dialog');
        if (modalDialog) {
            modalDialog.addEventListener('click', function(event) {
                console.log('Click inside modal-dialog, stopping propagation');
                console.log('Clicked element:', event.target.tagName, event.target.className);
                event.stopPropagation();
            });
            console.log('Modal dialog click handler attached');
        } else {
            console.log('Modal dialog not found yet, will retry');
            // Try again after a short delay (in case modal hasn't been rendered yet)
            setTimeout(setupModalDialogHandler, 100);
        }
    };

    // Initial setup
    setupModalDialogHandler();

    modalOverlay.addEventListener('click', function(event) {
        console.log('=== MODAL OVERLAY CLICK EVENT ===');
        console.log('event.target:', event.target);
        console.log('event.target.tagName:', event.target.tagName);
        console.log('event.target.className:', event.target.className);
        console.log('event.target.id:', event.target.id);
        console.log('event.target.classList:', event.target.classList);
        console.log('Has modal-overlay class:', event.target.classList.contains('modal-overlay'));
        console.log('event.currentTarget:', event.currentTarget);
        console.log('event.currentTarget.id:', event.currentTarget.id);
        console.log('Time since modal shown:', Date.now() - modalShowTime, 'ms');
        console.log('Event detail (click count):', event.detail);
        console.log('Event isTrusted:', event.isTrusted);
        console.log('Event type:', event.type);
        console.log('Event bubbles:', event.bubbles);
        console.log('Event cancelable:', event.cancelable);
        console.log('Event defaultPrevented:', event.defaultPrevented);

        // Log parent elements to understand the hierarchy
        let parent = event.target.parentElement;
        let depth = 0;
        console.log('Parent chain:');
        while (parent && depth < 5) {
            console.log(`  ${depth}: ${parent.tagName}.${parent.className} #${parent.id}`);
            parent = parent.parentElement;
            depth++;
        }

        // Ignore clicks that happen too soon after modal opens (within 500ms)
        // This prevents the synthesized click from touch events from closing the modal
        const timeSinceShown = Date.now() - modalShowTime;
        if (timeSinceShown < 500) {
            console.log('RESULT: Ignoring click - modal just opened', timeSinceShown, 'ms ago');
            return;
        }

        // Only close if clicking directly on the overlay (not on the modal dialog or its children)
        // event.target is the overlay AND event.currentTarget is the overlay means we clicked
        // directly on the overlay background, not on any child elements
        if (event.target === event.currentTarget && event.target.classList.contains('modal-overlay')) {
            console.log('RESULT: Closing modal - clicked directly on overlay background');
            closeTuneDetailModal();
        } else {
            console.log('RESULT: NOT closing modal - clicked inside modal dialog');
            console.log('  Clicked element:', event.target.tagName, event.target.className);
        }
        console.log('=== END MODAL CLICK EVENT ===');
    });
}

function cycleStatusFilter() {
    currentStatusFilterIndex = (currentStatusFilterIndex + 1) % statusFilterStates.length;
    const state = statusFilterStates[currentStatusFilterIndex];
    currentFilters.status = state.value;

    // Update button display
    const btn = document.getElementById('status-filter-btn');
    const icon = document.getElementById('status-filter-icon');
    icon.textContent = state.icon;

    // Add active class if filtering
    if (state.value) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }

    applyFilters();
}

function cycleSortMode() {
    currentSortModeIndex = (currentSortModeIndex + 1) % sortModes.length;
    const mode = sortModes[currentSortModeIndex];

    // Update button display
    const icon = document.getElementById('sort-icon');
    icon.textContent = mode.icon;

    applyFilters();
}

function loadFiltersFromURL() {
    const params = new URLSearchParams(window.location.search);

    if (params.has('search')) {
        currentFilters.search = params.get('search');
        document.getElementById('search-input').value = params.get('search');
    }

    if (params.has('type')) {
        currentFilters.type = params.get('type');
        document.getElementById('type-filter').value = params.get('type');
    }

    if (params.has('status')) {
        const status = params.get('status');
        currentFilters.status = status;

        // Find the matching status filter state
        const index = statusFilterStates.findIndex(s => s.value === status);
        if (index >= 0) {
            currentStatusFilterIndex = index;
            const state = statusFilterStates[index];
            document.getElementById('status-filter-icon').textContent = state.icon;

            if (state.value) {
                document.getElementById('status-filter-btn').classList.add('active');
            }
        }
    }

    if (params.has('sort')) {
        const sortId = params.get('sort');
        const index = sortModes.findIndex(s => s.id === sortId);
        if (index >= 0) {
            currentSortModeIndex = index;
            const mode = sortModes[index];
            document.getElementById('sort-icon').textContent = mode.icon;
        }
    }
}

function updateURL() {
    const params = new URLSearchParams();

    if (currentFilters.search) params.set('search', currentFilters.search);
    if (currentFilters.type) params.set('type', currentFilters.type);
    if (currentFilters.status) params.set('status', currentFilters.status);

    // Only add sort param if not default (alpha-asc)
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.id !== 'alpha-asc') {
        params.set('sort', sortMode.id);
    }

    const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
    window.history.replaceState({}, '', newURL);
}

function loadTunes() {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('tunes-grid').style.display = 'none';
    document.getElementById('no-results').style.display = 'none';

    fetchWithRetry('/api/my-tunes?per_page=2000')
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                if (errorInfo.action) {
                    errorInfo.action();
                    return Promise.reject(new Error(errorInfo.message));
                }
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            allTunes = data.tunes || [];
            populateTuneTypes();
            applyFilters();
        })
        .catch(error => {
            console.error('Error loading tunes:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');
            
            // Show retry option if retryable
            if (errorInfo.retryable) {
                showRetryOption();
            }
            
            document.getElementById('loading').style.display = 'none';
        });
}

function showRetryOption() {
    const grid = document.getElementById('tunes-grid');
    grid.innerHTML = `
        <div class="error-state">
            <div class="error-state-icon">‚ö†Ô∏è</div>
            <div class="error-state-title">Failed to Load Tunes</div>
            <div class="error-state-message">There was a problem loading your tune collection.</div>
            <div class="error-state-action">
                <button class="retry-btn" onclick="loadTunes()">
                    <span class="retry-icon">‚Üª</span>
                    Retry
                </button>
            </div>
        </div>
    `;
    grid.style.display = 'grid';
}

function populateTuneTypes() {
    const types = [...new Set(allTunes.map(tune => tune.tune_type).filter(Boolean))];
    types.sort();
    
    const typeFilter = document.getElementById('type-filter');
    const currentValue = typeFilter.value;
    
    // Keep "All Types" option and add tune types
    typeFilter.innerHTML = '<option value="">All Types</option>';
    types.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        typeFilter.appendChild(option);
    });
    
    // Restore selected value if it still exists
    if (currentValue && types.includes(currentValue)) {
        typeFilter.value = currentValue;
    }
}

function applyFilters() {
    filteredTunes = allTunes.filter(tune => {
        // Search filter
        if (currentFilters.search) {
            const searchLower = currentFilters.search.toLowerCase();
            const nameMatch = tune.tune_name && tune.tune_name.toLowerCase().includes(searchLower);
            if (!nameMatch) return false;
        }

        // Type filter
        if (currentFilters.type && tune.tune_type !== currentFilters.type) {
            return false;
        }

        // Status filter
        if (currentFilters.status && tune.learn_status !== currentFilters.status) {
            return false;
        }

        return true;
    });

    // Apply sorting
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.sortFn) {
        filteredTunes.sort(sortMode.sortFn);
    }

    updateURL();
    renderTunes();
}

function renderTunes() {
    document.getElementById('loading').style.display = 'none';

    const grid = document.getElementById('tunes-grid');
    const noResults = document.getElementById('no-results');
    const resultsCountText = document.getElementById('results-count-text');

    if (filteredTunes.length === 0) {
        grid.style.display = 'none';
        noResults.style.display = 'block';
        resultsCountText.textContent = '';
        return;
    }

    grid.style.display = 'grid';
    noResults.style.display = 'none';

    // Update results count
    const total = allTunes.length;
    const filtered = filteredTunes.length;
    if (filtered < total) {
        resultsCountText.textContent = `Showing ${filtered} of ${total} tunes`;
    } else {
        resultsCountText.textContent = `${total} tune${total !== 1 ? 's' : ''}`;
    }

    // Render tune cards
    grid.innerHTML = filteredTunes.map(tune => createTuneCard(tune)).join('');
}

function createTuneCard(tune) {
    const statusClass = `status-${tune.learn_status.replace(/ /g, '-')}`;
    const heardCountHTML = tune.learn_status === 'want to learn' && tune.heard_before_learning_count > 0
        ? `<div class="heard-count-container">
               <span>Heard at sessions:</span>
               <span class="heard-count">${tune.heard_before_learning_count}</span>
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Increment heard count">+</button>
           </div>`
        : tune.learn_status === 'want to learn'
        ? `<div class="heard-count-container">
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Mark as heard">+</button>
               <span style="font-size: 12px;">Mark as heard</span>
           </div>`
        : '';

    const thesessionLink = tune.tune_id
        ? `<a href="https://thesession.org/tunes/${tune.tune_id}" target="_blank" class="tune-action-btn" onclick="event.stopPropagation();">View on TheSession.org</a>`
        : '';

    // Determine what to show in the tune type badge based on sort mode
    const sortMode = sortModes[currentSortModeIndex];
    const isPopularityMode = sortMode.id === 'popularity-desc' || sortMode.id === 'popularity-asc';
    const typeLabel = isPopularityMode
        ? (tune.tunebook_count || 0).toString()
        : tune.tune_type || '';

    return `
        <div class="tune-card" onclick="showTuneDetail(${tune.person_tune_id}, event)">
            <div class="tune-card-header">
                <h3 class="tune-name">${tune.tune_name || 'Unknown'}</h3>
                ${typeLabel ? `<span class="tune-type">${typeLabel}</span>` : ''}
            </div>
            <div class="tune-meta">
                <div class="tune-meta-item">
                    <span class="status-badge ${statusClass}">${tune.learn_status}</span>
                </div>
                ${tune.tune_key ? `<div class="tune-meta-item">Key: ${tune.tune_key}</div>` : ''}
            </div>
            ${heardCountHTML}
            <div class="tune-actions">
                ${thesessionLink}
            </div>
        </div>
    `;
}

function clearFilters() {
    currentFilters = {
        search: '',
        type: '',
        status: ''
    };

    document.getElementById('search-input').value = '';
    document.getElementById('type-filter').value = '';

    // Reset status filter to "All"
    currentStatusFilterIndex = 0;
    document.getElementById('status-filter-icon').textContent = 'All';
    document.getElementById('status-filter-btn').classList.remove('active');

    applyFilters();
}

function incrementHeardCount(personTuneId) {
    const loading = showLoading('Updating heard count...');
    
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        loading.hide();
        showMessage('Heard count updated!', 'success');
        // Update the tune in our local data
        const tune = allTunes.find(t => t.person_tune_id === personTuneId);
        if (tune) {
            tune.heard_before_learning_count = data.heard_before_learning_count;
            applyFilters(); // Re-render
        }
    })
    .catch(error => {
        loading.hide();
        console.error('Error incrementing heard count:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function showTuneDetail(personTuneId, event) {
    console.log('=== showTuneDetail called ===');
    console.log('personTuneId:', personTuneId);
    console.log('Event passed to showTuneDetail:', event);
    if (event) {
        console.log('Event type:', event.type);
        console.log('Event target:', event.target);
        console.log('Event currentTarget:', event.currentTarget);
        console.log('Event bubbles:', event.bubbles);
        console.log('Event isTrusted:', event.isTrusted);
    }

    // Stop the click from propagating to prevent it from immediately closing the modal
    if (event) {
        console.log('Calling event.stopPropagation()');
        event.stopPropagation();
        console.log('After stopPropagation');
    } else {
        console.log('WARNING: No event passed to showTuneDetail');
    }

    // Find the tune in our local data to get basic info
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (!tune) {
        showMessage('Tune not found', 'error');
        return;
    }

    // Cancel any in-progress modal fetch
    if (modalFetchController) {
        console.log('Aborting previous modal fetch request');
        modalFetchController.abort();
    }

    // Create new AbortController for this fetch
    modalFetchController = new AbortController();
    console.log('Created new AbortController for modal fetch');

    // Show modal immediately with basic info
    displayTuneDetailModalBasic(tune);

    // Fetch full details in the background with abort signal
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        signal: modalFetchController.signal
    })
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                if (errorInfo.action) {
                    errorInfo.action();
                    return Promise.reject(new Error(errorInfo.message));
                }
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Update modal with full details
                displayTuneDetailModalFull(data.person_tune);
            } else {
                showMessage(data.error || 'Failed to load tune details', 'error');
            }
        })
        .catch(error => {
            // Don't show error if request was aborted
            if (error.name === 'AbortError') {
                console.log('Modal fetch request was aborted');
                return;
            }
            console.error('Error loading tune details:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');
        });
}

function displayTuneDetailModalBasic(tune) {
    console.log('=== displayTuneDetailModalBasic called ===');
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon - we can show this immediately if we have tune_id
    const thesessionLinkIcon = tune.tune_id
        ? `<a href="https://thesession.org/tunes/${tune.tune_id}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">üîó</a>`
        : '';

    // Show basic info with inline loading dots for numbers
    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="onModalStatusChange()">
                ${statusOptions}
            </select>
            <button id="modal-save-btn" class="modal-save-btn" onclick="saveStatusFromModal()" disabled>Save</button>
        </div>
        <div id="modal-additional-info">
            <div class="modal-info-line">TheSession.org Tunebooks: <span class="loading-dots">...</span></div>
            <div class="modal-info-line">Play count at your sessions: <span class="loading-dots">...</span></div>
        </div>
    `;

    // Store current tune ID and original status for updates
    modal.dataset.personTuneId = tune.person_tune_id;
    modal.dataset.originalStatus = tune.learn_status;

    // Show modal
    console.log('SHOWING MODAL - setting display = flex');
    console.log('Modal current display:', modal.style.display);
    modal.style.display = 'flex';
    console.log('Modal display after setting:', modal.style.display);

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('modalShowTime set to:', modalShowTime);
    console.log('=== END displayTuneDetailModalBasic ===');
}

function displayTuneDetailModalFull(tune) {
    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">üîó</a>`
        : '';

    // Update the title to include the link
    const modalTitle = document.querySelector('.modal-tune-title');
    if (modalTitle) {
        modalTitle.innerHTML = `${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}`;
    }

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    // Build full additional info
    const additionalInfo = `
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}

        ${tune.notes ? `
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <p>${tune.notes}</p>
        </div>` : ''}
    `;

    // Replace the loading dots with the full info
    const additionalInfoDiv = document.getElementById('modal-additional-info');
    if (additionalInfoDiv) {
        additionalInfoDiv.innerHTML = additionalInfo;
    }
}

function displayTuneDetailModal(tune) {
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">üîó</a>`
        : '';

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="updateStatusFromModal(${tune.person_tune_id})">
                ${statusOptions}
            </select>
        </div>
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}

        ${tune.notes ? `
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <p>${tune.notes}</p>
        </div>` : ''}
    `;

    // Store current tune ID for updates
    modal.dataset.personTuneId = tune.person_tune_id;

    // Show modal
    console.log('Showing modal - display: flex');
    modal.style.display = 'flex';

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('Set modalShowTime to', modalShowTime);
}

function closeTuneDetailModal() {
    console.log('=== closeTuneDetailModal called ===');
    console.log('Stack trace:');
    console.trace();

    // Abort any in-progress modal fetch
    if (modalFetchController) {
        console.log('Aborting modal fetch request due to modal close');
        modalFetchController.abort();
        modalFetchController = null;
    }

    const modal = document.getElementById('tune-detail-modal');
    modal.style.display = 'none';
    console.log('Modal closed');
}

function onModalStatusChange() {
    // Enable/disable the Save button based on whether status changed
    const modal = document.getElementById('tune-detail-modal');
    const select = document.getElementById('modal-status-select');
    const saveBtn = document.getElementById('modal-save-btn');
    const originalStatus = modal.dataset.originalStatus;

    if (select && saveBtn && originalStatus) {
        saveBtn.disabled = (select.value === originalStatus);
    }
}

function saveStatusFromModal() {
    const modal = document.getElementById('tune-detail-modal');
    const select = document.getElementById('modal-status-select');
    const personTuneId = parseInt(modal.dataset.personTuneId);
    const newStatus = select.value;
    const originalStatus = modal.dataset.originalStatus;

    // Don't save if nothing changed
    if (newStatus === originalStatus) {
        return;
    }

    // Update the tune in local data immediately (optimistic update)
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (tune) {
        tune.learn_status = newStatus;
        if (newStatus === 'learned') {
            tune.learned_date = new Date().toISOString();
        }
        applyFilters(); // Re-render grid immediately
    }

    // Close the modal immediately
    closeTuneDetailModal();

    // Save to server in the background
    fetchWithRetry(`/api/my-tunes/${personTuneId}/status`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ learn_status: newStatus })
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        showMessage('Learning status updated!', 'success');

        // Update with server response (in case learned_date differs)
        if (tune && data.person_tune) {
            if (data.person_tune.learned_date) {
                tune.learned_date = data.person_tune.learned_date;
            }
            applyFilters(); // Re-render with accurate data
        }
    })
    .catch(error => {
        console.error('Error updating status:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');

        // Revert to original status on error
        if (tune) {
            tune.learn_status = originalStatus;
            applyFilters(); // Re-render with reverted data
        }
    });
}

// Keep old function for backward compatibility if needed elsewhere
function updateStatusFromModal(personTuneId) {
    saveStatusFromModal();
}

function incrementHeardCountFromModal(personTuneId) {
    const loading = showLoading('Updating heard count...');
    
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        loading.hide();
        showMessage('Heard count updated!', 'success');
        
        // Update the tune in our local data
        const tune = allTunes.find(t => t.person_tune_id === personTuneId);
        if (tune) {
            tune.heard_before_learning_count = data.heard_before_learning_count;
            applyFilters(); // Re-render
        }
        
        // Update the modal display
        const heardCountSpan = document.getElementById('modal-heard-count');
        if (heardCountSpan) {
            heardCountSpan.textContent = data.heard_before_learning_count;
        }
    })
    .catch(error => {
        loading.hide();
        console.error('Error incrementing heard count:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function showMessage(message, type) {
    // Create a temporary message element
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        border-radius: 4px;
        z-index: 10000;
        max-width: 500px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        animation: slideDown 0.3s ease-out;
    `;
    
    if (type === 'success') {
        messageDiv.style.backgroundColor = '#d4edda';
        messageDiv.style.color = '#155724';
        messageDiv.style.border = '1px solid #c3e6cb';
    } else if (type === 'error') {
        messageDiv.style.backgroundColor = '#f8d7da';
        messageDiv.style.color = '#721c24';
        messageDiv.style.border = '1px solid #f5c6cb';
    } else {
        messageDiv.style.backgroundColor = '#d1ecf1';
        messageDiv.style.color = '#0c5460';
        messageDiv.style.border = '1px solid #bee5eb';
    }
    
    messageDiv.textContent = message;
    document.body.appendChild(messageDiv);
    
    // Remove after 5 seconds
    setTimeout(() => {
        messageDiv.style.animation = 'slideUp 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(messageDiv);
        }, 300);
    }, 5000);
}
</script>

<style>
@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

@keyframes slideUp {
    from {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
    to {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
}
</style>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/my_tunes_mobile.js') }}"></script>
{% endblock %}
