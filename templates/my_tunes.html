{% extends "base.html" %}

{% block title %}My Tunes - Personal Tune Collection{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/my_tunes_mobile.css') }}">
<style>
    .my-tunes-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    /* Mobile compact view */
    @media (max-width: 768px) {
        /* Override parent container padding */
        .docs-content {
            padding: 0 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        .my-tunes-container {
            padding: 0;
            max-width: 100%;
            margin-top: 0;
            margin-left: 0;
            margin-right: 0;
        }

        .my-tunes-header-section {
            padding: 10px;
        }

        .page-header {
            margin-bottom: 4px;
            padding: 0;
        }

        .filters-container {
            margin-bottom: 6px;
            padding: 0;
        }

        .results-count {
            margin-bottom: 4px;
            font-size: 12px;
            padding: 0;
        }
    }

    .page-header {
        margin-bottom: 30px;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }

    .page-header h1 {
        margin: 0;
    }

    .page-actions {
        display: flex;
        flex-direction: row;
        gap: 8px;
        align-items: center;
        margin-left: auto;
    }

    .btn {
        padding: 4px 12px;
        background-color: var(--primary);
        color: white !important;
        text-decoration: none;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 13px;
        transition: background-color 0.2s;
        white-space: nowrap;
        line-height: 1.2;
    }

    .btn:hover {
        background-color: var(--primary-dark, #0056b3);
        color: white !important;
        text-decoration: none;
    }

    .btn-secondary {
        background-color: var(--secondary, #6c757d);
        color: white !important;
    }

    .btn-secondary:hover {
        background-color: var(--secondary-dark, #5a6268);
        color: white !important;
    }

    .filters-container {
        margin-bottom: 20px;
    }

    .filter-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: nowrap;
    }

    .filter-group {
        display: flex;
        align-items: center;
        min-width: 0;
    }

    .filter-group:first-child {
        flex: 1;
        min-width: 0;
    }

    .filter-group label {
        display: none;
    }

    .filter-input {
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        width: 100%;
        min-width: 0;
        max-width: 200px;
    }

    .filter-select {
        padding: 8px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        width: 110px;
        flex-shrink: 0;
    }

    .status-filter-btn {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 60px;
        justify-content: center;
        flex-shrink: 0;
    }

    .status-filter-btn:hover {
        background-color: var(--hover-bg);
    }

    .status-filter-btn.active {
        background-color: var(--primary);
        color: white;
        border-color: var(--primary);
    }

    .tunes-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    /* Mobile compact tune list */
    @media (max-width: 768px) {
        .tunes-grid {
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-bottom: 10px;
        }
    }

    .tune-card {
        background-color: var(--bg-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        transition: box-shadow 0.2s, transform 0.2s;
        cursor: pointer;
    }

    @media (max-width: 768px) {
        .tune-card {
            border-radius: 0;
            border-left: none;
            border-right: none;
            border-top: none;
            padding: 6px 2px; /* Keep small padding for content */
            margin: 0; /* No margin - border goes to edge */
            display: grid;
            grid-template-columns: 20px 1fr auto;
            grid-template-rows: auto; /* Single row only */
            grid-auto-rows: 0; /* Make any extra rows have 0 height */
            align-items: center;
            gap: 6px;
            max-width: 100%;
            overflow: hidden;
            min-height: 0; /* Prevent extra height */
        }

        .tune-card:first-child {
            border-top: 1px solid var(--border-color);
        }

        /* Force all direct children to be on row 1 or hidden */
        .tune-card > * {
            grid-row: 1;
        }
    }

    .tune-card:hover {
        box-shadow: 0 4px 12px var(--dropdown-shadow);
        transform: translateY(-2px);
    }

    @media (max-width: 768px) {
        .tune-card:hover {
            box-shadow: none;
            transform: none;
            background-color: transparent;
        }
    }

    .tune-card-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        margin-bottom: 15px;
    }

    @media (max-width: 768px) {
        .tune-card-header {
            /* Span columns 2-3, contains both tune-name and tune-type */
            grid-column: 2 / 4;
            grid-row: 1;
            margin-bottom: 0;
            min-width: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 6px;
        }
    }

    .tune-name {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-color);
        margin: 0;
        flex: 1;
    }

    @media (max-width: 768px) {
        .tune-name {
            font-size: 16px; /* Increased from 14px */
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
            max-width: calc(100vw - 135px); /* Reserve space for status (26px with gap) + tune type ("Barndance" ~90px with padding) + gaps (~19px) */
            flex: 0 1 auto; /* Don't grow, allow shrink */
        }
    }

    .tune-type {
        font-size: 12px;
        padding: 4px 8px;
        background-color: var(--primary);
        color: white;
        border-radius: 4px;
        text-transform: capitalize;
        white-space: nowrap;
        margin-left: 10px;
    }

    @media (max-width: 768px) {
        .tune-type {
            font-size: 12px; /* Increased from 10px */
            padding: 2px 6px;
            margin-left: 0;
            flex-shrink: 0; /* Never shrink */
            white-space: nowrap;
        }
    }

    .tune-meta {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 15px;
        font-size: 14px;
        color: var(--text-muted, #6c757d);
    }

    @media (max-width: 768px) {
        .tune-meta {
            /* Don't participate in grid - let status-badge position itself */
            display: contents; /* Make children direct grid participants */
        }
    }

    .tune-meta-item {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    @media (max-width: 768px) {
        .tune-meta-item {
            /* Don't participate in grid - let status-badge position itself */
            display: contents; /* Make children direct grid participants */
        }

        /* Hide the "Key: X" meta item on mobile */
        .tune-meta-item:not(:first-child) {
            display: none !important;
        }

        /* Ensure only the first meta-item participates */
        .tune-meta-item:first-child {
            display: contents;
        }
    }

    .status-badge {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        text-transform: capitalize;
    }

    @media (max-width: 768px) {
        .status-badge {
            /* Grid column 1: fixed 20px column */
            grid-column: 1;
            grid-row: 1;
            padding: 0;
            border-radius: 0;
            font-size: 16px;
            background-color: transparent !important;
            width: 20px;
            height: 20px;
            min-width: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .status-badge::before {
            font-size: 16px;
        }

        .status-want-to-learn::before {
            content: '★';
            color: #f0ad4e;
        }

        .status-learning::before {
            content: '⋯';
            color: #5bc0de;
        }

        .status-learned::before {
            content: '✓';
            color: #5cb85c;
        }

        /* Hide the text on mobile */
        .status-badge {
            font-size: 0;
        }
    }

    .status-want-to-learn {
        background-color: #fff3cd;
        color: #856404;
    }

    .status-learning {
        background-color: #d1ecf1;
        color: #0c5460;
    }

    .status-learned {
        background-color: #d4edda;
        color: #155724;
    }

    .tune-actions {
        display: flex;
        gap: 10px;
        margin-top: 15px;
    }

    @media (max-width: 768px) {
        .tune-actions {
            display: none !important; /* Force hide completely */
        }
    }

    .tune-action-btn {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        background-color: var(--bg-color);
        color: var(--text-color);
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: background-color 0.2s;
        text-align: center;
        text-decoration: none;
    }

    .tune-action-btn:hover {
        background-color: var(--hover-bg);
        text-decoration: none;
        color: var(--text-color);
    }

    .heard-count-container {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 10px;
        padding: 8px;
        background-color: var(--light);
        border-radius: 4px;
    }

    @media (max-width: 768px) {
        .heard-count-container {
            display: none !important; /* Force hide completely */
        }
    }

    .heard-count {
        font-weight: 600;
        color: var(--primary);
    }

    .increment-heard-btn {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 1px solid var(--primary);
        background-color: var(--bg-color);
        color: var(--primary);
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .increment-heard-btn:hover {
        background-color: var(--primary);
        color: white;
    }

    .no-results {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted, #6c757d);
    }

    .no-results h3 {
        margin-bottom: 10px;
    }

    .loading {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted, #6c757d);
    }

    .loading-more {
        text-align: center;
        padding: 20px;
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        display: none;
    }

    .loading-more.visible {
        display: block;
    }

    .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .results-count {
        margin-bottom: 15px;
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
    }

    .sort-toggle {
        padding: 4px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        user-select: none;
    }

    .sort-toggle:hover {
        background-color: var(--hover-bg);
    }

    .sort-toggle.active {
        background-color: var(--primary);
        color: white;
        border-color: var(--primary);
    }

    @media (max-width: 768px) {
        .results-count {
            font-size: 12px;
            gap: 6px;
            flex-wrap: wrap;
        }

        .sort-toggle {
            font-size: 11px;
            padding: 3px 6px;
        }
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
        .my-tunes-container {
            padding: 0;
        }

        .page-header {
            gap: 6px;
        }

        .page-header h1 {
            font-size: 22px;
        }

        .btn {
            padding: 4px 10px;
            font-size: 12px;
        }

        .page-actions {
            gap: 6px;
        }

        .tunes-grid {
            grid-template-columns: 1fr;
            gap: 0; /* No gap between rows in mobile */
        }

        .filters-container {
            margin-bottom: 15px;
        }

        .filter-row {
            gap: 5px;
        }

        .filter-input {
            font-size: 16px;
            padding: 8px 6px;
            max-width: none;
            height: 40px;
            box-sizing: border-box;
        }

        .filter-select {
            width: 85px;
            font-size: 13px;
            padding: 8px 4px;
            height: 40px;
            box-sizing: border-box;
        }

        .status-filter-btn {
            padding: 8px 6px;
            font-size: 13px;
            min-width: 45px;
            gap: 4px;
            height: 40px;
            box-sizing: border-box;
        }

        /* Touch-friendly button sizes */
        .tune-action-btn,
        .increment-heard-btn {
            min-height: 44px;
            min-width: 44px;
        }
    }

    /* Dark mode adjustments */
    [data-theme="dark"] .status-want-to-learn {
        background-color: #664d03;
        color: #ffecb5;
    }

    [data-theme="dark"] .status-learning {
        background-color: #055160;
        color: #b6effb;
    }

    [data-theme="dark"] .status-learned {
        background-color: #0f5132;
        color: #badbcc;
    }

    /* Loading dots animation */
    .loading-dots {
        font-weight: bold;
        display: inline-block;
        animation: pulse-dots 1.5s ease-in-out infinite;
    }

    @keyframes pulse-dots {
        0%, 100% {
            opacity: 0.3;
        }
        50% {
            opacity: 1;
        }
    }

    /* Tune Detail Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 10000;
        display: none;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
    }

    .modal-dialog {
        background: var(--bg-color, white);
        border-radius: 8px;
        padding: 0;
        max-width: 600px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        color: var(--text-color);
        position: relative;
        pointer-events: auto;
        z-index: 1;
    }

    #tune-detail-content {
        padding: 20px;
    }

    .modal-close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 28px;
        color: var(--text-muted, #999);
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }

    .modal-close-btn:hover {
        color: var(--text-color);
    }

    .modal-tune-title {
        margin: 0 32px 12px 0;
        color: var(--text-color);
        font-size: 22px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .thesession-link-icon {
        font-size: 18px;
        text-decoration: none;
        color: var(--primary);
        opacity: 0.8;
    }

    .thesession-link-icon:hover {
        opacity: 1;
    }

    .modal-header-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
        width: 100%;
    }

    .modal-status-select {
        padding: 6px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        flex: 1;
        min-width: 0;
    }

    .modal-save-btn {
        padding: 6px 16px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    .modal-save-btn:hover:not(:disabled) {
        background-color: var(--primary-dark, #0056b3);
    }

    .modal-save-btn:disabled {
        background-color: var(--secondary, #6c757d);
        cursor: not-allowed;
        opacity: 0.5;
    }

    [data-theme="dark"] .modal-save-btn:disabled {
        background-color: #555;
    }

    .modal-info-line {
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        margin-bottom: 8px;
    }

    .modal-session-play-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
    }

    .modal-view-btn {
        padding: 4px 12px;
        background-color: var(--primary);
        color: white !important;
        text-decoration: none;
        border-radius: 4px;
        font-size: 13px;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .modal-view-btn:hover {
        background-color: var(--primary-dark, #0056b3);
        color: white !important;
        text-decoration: none;
    }

    .modal-notes-section {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--border-color);
    }

    .modal-notes-label {
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--text-color);
    }

    .modal-notes-section p {
        margin: 0;
        color: var(--text-color);
        font-size: 14px;
        line-height: 1.5;
    }

    .modal-notes-textarea {
        width: 100%;
        min-height: 80px;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        font-family: inherit;
        background-color: var(--bg-color);
        color: var(--text-color);
        resize: vertical;
        box-sizing: border-box;
    }

    .modal-notes-textarea:focus {
        outline: none;
        border-color: var(--primary);
    }

    .modal-notes-textarea:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: var(--light, #f8f9fa);
    }

    [data-theme="dark"] .modal-notes-textarea:disabled {
        background-color: #2a2a2a;
    }

    /* Mobile adjustments for modal - full page slide-in */
    @media (max-width: 768px) {
        .modal-overlay {
            background-color: transparent;
            align-items: flex-start;
            justify-content: flex-end;
            pointer-events: none; /* Allow clicks through to header */
        }

        .modal-dialog {
            width: 100%;
            max-width: 100%;
            height: calc(100vh - 68px); /* Account for header height */
            max-height: calc(100vh - 68px);
            margin: 0;
            margin-top: 68px; /* Start below header */
            border-radius: 0;
            position: fixed;
            right: 0;
            top: 0;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            box-shadow: -4px 0 12px rgba(0,0,0,0.2);
            pointer-events: auto; /* Re-enable clicks on the dialog */
        }

        .modal-overlay.show .modal-dialog {
            transform: translateX(0);
        }

        #tune-detail-content {
            padding: 16px;
            padding-top: 16px; /* No extra space at top */
        }

        .modal-tune-title {
            font-size: 18px;
            margin-right: 48px; /* Space for back button */
            margin-top: 0;
            margin-left: 0;
        }

        .modal-close-btn {
            position: fixed;
            top: 8px; /* Top corner of screen */
            right: 8px; /* Right corner of screen */
            left: auto;
            font-size: 0; /* Hide the × */
            width: 40px;
            height: 40px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            z-index: 10001; /* Above modal */
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close-btn::before {
            content: '>';
            font-size: 24px;
            font-weight: bold;
            color: var(--text-color);
        }

        .modal-close-btn:hover {
            background-color: var(--hover-bg);
        }

        .modal-header-row {
            flex-wrap: wrap;
        }

        .modal-status-select {
            max-width: none;
        }

        .modal-info-line {
            font-size: 13px;
        }

        .modal-session-play-row {
            flex-direction: row;
            align-items: center;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="my-tunes-container">
    <div class="my-tunes-header-section">
        <div class="page-header">
            <h1>My Tunes</h1>
            <div class="page-actions">
                <a href="/my-tunes/add" class="btn">Add</a>
                <a href="/my-tunes/sync" class="btn btn-secondary">Sync</a>
            </div>
        </div>

        <div class="filters-container">
            <div class="filter-row">
                <div class="filter-group">
                    <input
                        type="text"
                        id="search-input"
                        class="filter-input"
                        placeholder="Search"
                        title="Search tunes"
                        autocomplete="off"
                    >
                </div>
                <div class="filter-group">
                    <select id="type-filter" class="filter-select" title="Tune type">
                        <option value="">All Types</option>
                    </select>
                </div>
                <div class="filter-group">
                    <button id="status-filter-btn" class="status-filter-btn" onclick="cycleStatusFilter()" title="Filter by learning status">
                        <span id="status-filter-icon">All</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="results-count">
            <span id="results-count-text"></span>
            <button id="sort-toggle" class="sort-toggle" onclick="cycleSortMode()" title="Toggle sort order">
                <span id="sort-icon">a-z</span>
            </button>
        </div>
    </div>

    <div id="loading" class="loading" style="display: none;">
        <p>Loading your tunes...</p>
    </div>

    <div id="no-results" class="no-results" style="display: none;">
        <h3>No tunes found</h3>
        <p>Try adjusting your filters or add your first tune to get started!</p>
    </div>

    <div class="tunes-grid" id="tunes-grid">
        <!-- Tune cards will be inserted here by JavaScript -->
    </div>

    <div id="loading-more" class="loading-more">
        <span class="loading-spinner"></span>
        <span>Loading more tunes...</span>
    </div>
</div>

<!-- Tune Detail Modal -->
<div id="tune-detail-modal" class="modal-overlay">
    <div class="modal-dialog">
        <div id="tune-detail-content">
            <!-- Content will be inserted by JavaScript -->
        </div>
    </div>
</div>

<script>
// Helper functions for API calls
function fetchWithRetry(url, options = {}) {
    return fetch(url, options);
}

function handleApiError(error, response = null) {
    if (response) {
        if (response.status === 401) {
            return { message: 'Please log in again', action: () => window.location.href = '/login' };
        }
        if (response.status === 404) {
            return { message: 'Not found', retryable: false };
        }
        if (response.status >= 500) {
            return { message: 'Server error. Please try again.', retryable: true };
        }
        return { message: 'An error occurred. Please try again.', retryable: true };
    }
    return { message: error?.message || 'An error occurred', retryable: true };
}

function showLoading(message = 'Loading...') {
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loading-overlay';
    loadingDiv.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(255,255,255,0.9); z-index: 9999;
        display: flex; align-items: center; justify-content: center;
        flex-direction: column; gap: 15px;
    `;
    loadingDiv.innerHTML = `
        <div style="width: 40px; height: 40px; border: 4px solid #ddd;
                    border-top-color: #007bff; border-radius: 50%;
                    animation: spin 0.8s linear infinite;"></div>
        <div style="color: #333; font-size: 16px;">${message}</div>
    `;
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
    document.body.appendChild(loadingDiv);
    return {
        hide: () => {
            if (loadingDiv.parentNode) loadingDiv.parentNode.removeChild(loadingDiv);
            if (style.parentNode) style.parentNode.removeChild(style);
        }
    };
}

let allTunes = [];
let filteredTunes = [];
let currentFilters = {
    search: '',
    type: '',
    status: ''
};
let modalShowTime = 0;
let modalFetchController = null; // AbortController for modal fetch requests
let isLoadingFullTunes = false; // Track if full tune list is still loading
let fullTunesLoaded = false; // Track if we have all tunes

// Status filter cycle states
const statusFilterStates = [
    { value: '', label: 'All', icon: 'All' },
    { value: 'learned', label: 'Learned', icon: '✓' },
    { value: 'learning', label: 'Learning', icon: '⋯' },
    { value: 'want to learn', label: 'Want to Learn', icon: '★' }
];
let currentStatusFilterIndex = 0;

// Sort mode cycle states
const sortModes = [
    { id: 'alpha-asc', label: 'a-z', icon: 'a-z', sortFn: (a, b) => (a.tune_name || '').localeCompare(b.tune_name || '') },
    { id: 'alpha-desc', label: 'z-a', icon: 'z-a', sortFn: (a, b) => (b.tune_name || '').localeCompare(a.tune_name || '') },
    { id: 'popularity-desc', label: 'popularity high', icon: '#', sortFn: (a, b) => (b.tunebook_count || 0) - (a.tunebook_count || 0) },
    { id: 'popularity-asc', label: 'popularity low', icon: '#ꜜ', sortFn: (a, b) => (a.tunebook_count || 0) - (b.tunebook_count || 0) }
];
let currentSortModeIndex = 0;

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadTunes();
    setupEventListeners();
    loadFiltersFromURL();
    checkForSuccessMessage();
    setupScrollDetection();
});

function setupScrollDetection() {
    // Detect scroll to show loading indicator if still loading
    window.addEventListener('scroll', function() {
        if (!isLoadingFullTunes || fullTunesLoaded) {
            return;
        }

        const tunesGrid = document.getElementById('tunes-grid');
        const loadingMore = document.getElementById('loading-more');

        if (!tunesGrid || !loadingMore) {
            return;
        }

        // Get the bottom position of the tunes grid
        const gridRect = tunesGrid.getBoundingClientRect();
        const gridBottom = gridRect.bottom;

        // Get viewport height
        const viewportHeight = window.innerHeight;

        // If we're within 200px of the bottom of the grid, show loading indicator
        if (gridBottom < viewportHeight + 200) {
            loadingMore.classList.add('visible');
        }
    });
}

function checkForSuccessMessage() {
    const params = new URLSearchParams(window.location.search);
    if (params.has('added')) {
        const tuneName = params.get('added');
        showMessage(`Successfully added "${tuneName}" to your collection!`, 'success');
        // Clean up URL
        params.delete('added');
        const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
        window.history.replaceState({}, '', newURL);
    }
}

function setupEventListeners() {
    // Search input with debounce
    let searchTimeout;
    document.getElementById('search-input').addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            currentFilters.search = e.target.value.toLowerCase().trim();
            applyFilters();
        }, 300);
    });

    // Filter dropdowns
    document.getElementById('type-filter').addEventListener('change', function(e) {
        currentFilters.type = e.target.value;
        applyFilters();
    });

    // Modal overlay click handler - close when clicking outside
    const modalOverlay = document.getElementById('tune-detail-modal');

    // Add click handler to modal dialog to stop propagation
    const setupModalDialogHandler = () => {
        const modalDialog = modalOverlay.querySelector('.modal-dialog');
        if (modalDialog) {
            modalDialog.addEventListener('click', function(event) {
                console.log('Click inside modal-dialog, stopping propagation');
                console.log('Clicked element:', event.target.tagName, event.target.className);
                event.stopPropagation();
            });
            console.log('Modal dialog click handler attached');
        } else {
            console.log('Modal dialog not found yet, will retry');
            // Try again after a short delay (in case modal hasn't been rendered yet)
            setTimeout(setupModalDialogHandler, 100);
        }
    };

    // Initial setup
    setupModalDialogHandler();

    modalOverlay.addEventListener('click', function(event) {
        console.log('=== MODAL OVERLAY CLICK EVENT ===');
        console.log('event.target:', event.target);
        console.log('event.target.tagName:', event.target.tagName);
        console.log('event.target.className:', event.target.className);
        console.log('event.target.id:', event.target.id);
        console.log('event.target.classList:', event.target.classList);
        console.log('Has modal-overlay class:', event.target.classList.contains('modal-overlay'));
        console.log('event.currentTarget:', event.currentTarget);
        console.log('event.currentTarget.id:', event.currentTarget.id);
        console.log('Time since modal shown:', Date.now() - modalShowTime, 'ms');
        console.log('Event detail (click count):', event.detail);
        console.log('Event isTrusted:', event.isTrusted);
        console.log('Event type:', event.type);
        console.log('Event bubbles:', event.bubbles);
        console.log('Event cancelable:', event.cancelable);
        console.log('Event defaultPrevented:', event.defaultPrevented);

        // Log parent elements to understand the hierarchy
        let parent = event.target.parentElement;
        let depth = 0;
        console.log('Parent chain:');
        while (parent && depth < 5) {
            console.log(`  ${depth}: ${parent.tagName}.${parent.className} #${parent.id}`);
            parent = parent.parentElement;
            depth++;
        }

        // Ignore clicks that happen too soon after modal opens (within 500ms)
        // This prevents the synthesized click from touch events from closing the modal
        const timeSinceShown = Date.now() - modalShowTime;
        if (timeSinceShown < 500) {
            console.log('RESULT: Ignoring click - modal just opened', timeSinceShown, 'ms ago');
            return;
        }

        // Only close if clicking directly on the overlay (not on the modal dialog or its children)
        // event.target is the overlay AND event.currentTarget is the overlay means we clicked
        // directly on the overlay background, not on any child elements
        if (event.target === event.currentTarget && event.target.classList.contains('modal-overlay')) {
            console.log('RESULT: Closing modal - clicked directly on overlay background');
            closeTuneDetailModal();
        } else {
            console.log('RESULT: NOT closing modal - clicked inside modal dialog');
            console.log('  Clicked element:', event.target.tagName, event.target.className);
        }
        console.log('=== END MODAL CLICK EVENT ===');
    });

    // Setup swipe-to-close for mobile
    setupSwipeToClose();
}

function setupSwipeToClose() {
    const modalDialog = document.querySelector('.modal-dialog');
    if (!modalDialog) return;

    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let isSwiping = false;

    modalDialog.addEventListener('touchstart', function(e) {
        // Don't intercept touches on input controls
        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            return;
        }

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        isSwiping = false;
    }, { passive: true });

    modalDialog.addEventListener('touchmove', function(e) {
        if (!touchStartX) return;

        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            return;
        }

        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Detect horizontal swipe (more horizontal than vertical)
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            isSwiping = true;
        }
    }, { passive: true });

    modalDialog.addEventListener('touchend', function(e) {
        if (!touchStartX || !isSwiping) {
            touchStartX = 0;
            touchStartY = 0;
            return;
        }

        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            touchStartX = 0;
            touchStartY = 0;
            isSwiping = false;
            return;
        }

        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const deltaTime = Date.now() - touchStartTime;

        // Swipe right: deltaX > 0 and significant horizontal movement
        // Must be mostly horizontal (not diagonal) and fast enough or far enough
        if (deltaX > 50 && Math.abs(deltaX) > Math.abs(deltaY) * 2) {
            // Swipe right detected - close modal
            console.log('Swipe right detected, closing modal');
            closeTuneDetailModal();
        }

        touchStartX = 0;
        touchStartY = 0;
        isSwiping = false;
    }, { passive: true });
}

function cycleStatusFilter() {
    currentStatusFilterIndex = (currentStatusFilterIndex + 1) % statusFilterStates.length;
    const state = statusFilterStates[currentStatusFilterIndex];
    currentFilters.status = state.value;

    // Update button display
    const btn = document.getElementById('status-filter-btn');
    const icon = document.getElementById('status-filter-icon');
    icon.textContent = state.icon;

    // Add active class if filtering
    if (state.value) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }

    applyFilters();
}

function cycleSortMode() {
    currentSortModeIndex = (currentSortModeIndex + 1) % sortModes.length;
    const mode = sortModes[currentSortModeIndex];

    // Update button display
    const icon = document.getElementById('sort-icon');
    icon.textContent = mode.icon;

    // Re-apply filters and sorting (no DB reload needed)
    applyFilters();
}

function loadFiltersFromURL() {
    const params = new URLSearchParams(window.location.search);

    if (params.has('search')) {
        currentFilters.search = params.get('search');
        document.getElementById('search-input').value = params.get('search');
    }

    if (params.has('type')) {
        currentFilters.type = params.get('type');
        document.getElementById('type-filter').value = params.get('type');
    }

    if (params.has('status')) {
        const status = params.get('status');
        currentFilters.status = status;

        // Find the matching status filter state
        const index = statusFilterStates.findIndex(s => s.value === status);
        if (index >= 0) {
            currentStatusFilterIndex = index;
            const state = statusFilterStates[index];
            document.getElementById('status-filter-icon').textContent = state.icon;

            if (state.value) {
                document.getElementById('status-filter-btn').classList.add('active');
            }
        }
    }

    if (params.has('sort')) {
        const sortId = params.get('sort');
        const index = sortModes.findIndex(s => s.id === sortId);
        if (index >= 0) {
            currentSortModeIndex = index;
            const mode = sortModes[index];
            document.getElementById('sort-icon').textContent = mode.icon;
        }
    }
}

function updateURL() {
    const params = new URLSearchParams();

    if (currentFilters.search) params.set('search', currentFilters.search);
    if (currentFilters.type) params.set('type', currentFilters.type);
    if (currentFilters.status) params.set('status', currentFilters.status);

    // Only add sort param if not default (alpha-asc)
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.id !== 'alpha-asc') {
        params.set('sort', sortMode.id);
    }

    const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
    window.history.replaceState({}, '', newURL);
}

function loadTunes() {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('tunes-grid').style.display = 'none';
    document.getElementById('no-results').style.display = 'none';
    document.getElementById('loading-more').classList.remove('visible');

    // Reset state
    fullTunesLoaded = false;
    isLoadingFullTunes = true;

    // Get current sort mode for API query
    const sortMode = sortModes[currentSortModeIndex];
    const sortParam = sortMode ? sortMode.id : 'alpha-asc';

    // First, fetch initial 20 tunes for fast display
    fetchWithRetry(`/api/my-tunes?per_page=20&sort=${sortParam}`)
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                if (errorInfo.action) {
                    errorInfo.action();
                    return Promise.reject(new Error(errorInfo.message));
                }
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            // Show initial 20 tunes immediately
            allTunes = data.tunes || [];
            populateTuneTypes();
            applyFilters();

            // If we got fewer than 20, we have all tunes
            if (allTunes.length < 20) {
                fullTunesLoaded = true;
                isLoadingFullTunes = false;
            }
        })
        .catch(error => {
            console.error('Error loading initial tunes:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');

            // Show retry option if retryable
            if (errorInfo.retryable) {
                showRetryOption();
            }

            document.getElementById('loading').style.display = 'none';
            isLoadingFullTunes = false;
        });

    // In parallel, fetch all tunes (up to 2000)
    fetchWithRetry(`/api/my-tunes?per_page=2000&sort=${sortParam}`)
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            // Replace with full tune list
            allTunes = data.tunes || [];
            fullTunesLoaded = true;
            isLoadingFullTunes = false;

            // Hide loading-more indicator
            document.getElementById('loading-more').classList.remove('visible');

            populateTuneTypes();
            applyFilters();
        })
        .catch(error => {
            console.error('Error loading full tune list:', error);
            isLoadingFullTunes = false;
            // Don't show error if we already have initial tunes
            if (allTunes.length === 0) {
                const errorInfo = handleApiError(error);
                showMessage(errorInfo.message, 'error');
            }
            document.getElementById('loading-more').classList.remove('visible');
        });
}

function showRetryOption() {
    const grid = document.getElementById('tunes-grid');
    grid.innerHTML = `
        <div class="error-state">
            <div class="error-state-icon">⚠️</div>
            <div class="error-state-title">Failed to Load Tunes</div>
            <div class="error-state-message">There was a problem loading your tune collection.</div>
            <div class="error-state-action">
                <button class="retry-btn" onclick="loadTunes()">
                    <span class="retry-icon">↻</span>
                    Retry
                </button>
            </div>
        </div>
    `;
    grid.style.display = 'grid';
}

function populateTuneTypes() {
    const types = [...new Set(allTunes.map(tune => tune.tune_type).filter(Boolean))];
    types.sort();
    
    const typeFilter = document.getElementById('type-filter');
    const currentValue = typeFilter.value;
    
    // Keep "All Types" option and add tune types
    typeFilter.innerHTML = '<option value="">All Types</option>';
    types.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        typeFilter.appendChild(option);
    });
    
    // Restore selected value if it still exists
    if (currentValue && types.includes(currentValue)) {
        typeFilter.value = currentValue;
    }
}

function applyFilters() {
    filteredTunes = allTunes.filter(tune => {
        // Search filter
        if (currentFilters.search) {
            const searchLower = currentFilters.search.toLowerCase();
            const nameMatch = tune.tune_name && tune.tune_name.toLowerCase().includes(searchLower);
            if (!nameMatch) return false;
        }

        // Type filter
        if (currentFilters.type && tune.tune_type !== currentFilters.type) {
            return false;
        }

        // Status filter
        if (currentFilters.status && tune.learn_status !== currentFilters.status) {
            return false;
        }

        return true;
    });

    // Apply client-side sorting
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.sortFn) {
        filteredTunes.sort(sortMode.sortFn);
    }

    updateURL();
    renderTunes();
}

function renderTunes() {
    document.getElementById('loading').style.display = 'none';

    const grid = document.getElementById('tunes-grid');
    const noResults = document.getElementById('no-results');
    const resultsCountText = document.getElementById('results-count-text');

    if (filteredTunes.length === 0) {
        grid.style.display = 'none';
        noResults.style.display = 'block';
        resultsCountText.textContent = '';
        return;
    }

    grid.style.display = 'grid';
    noResults.style.display = 'none';

    // Update results count - only show if full tunes are loaded
    if (fullTunesLoaded) {
        const total = allTunes.length;
        const filtered = filteredTunes.length;
        if (filtered < total) {
            resultsCountText.textContent = `Showing ${filtered} of ${total} tunes`;
        } else {
            resultsCountText.textContent = `${total} tune${total !== 1 ? 's' : ''}`;
        }
    } else {
        // Don't show count until full data is loaded
        resultsCountText.textContent = '';
    }

    // Render tune cards
    grid.innerHTML = filteredTunes.map(tune => createTuneCard(tune)).join('');
}

function createTuneCard(tune) {
    const statusClass = `status-${tune.learn_status.replace(/ /g, '-')}`;
    const heardCountHTML = tune.learn_status === 'want to learn' && tune.heard_before_learning_count > 0
        ? `<div class="heard-count-container">
               <span>Heard at sessions:</span>
               <span class="heard-count">${tune.heard_before_learning_count}</span>
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Increment heard count">+</button>
           </div>`
        : tune.learn_status === 'want to learn'
        ? `<div class="heard-count-container">
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Mark as heard">+</button>
               <span style="font-size: 12px;">Mark as heard</span>
           </div>`
        : '';

    const thesessionLink = tune.tune_id
        ? `<a href="https://thesession.org/tunes/${tune.tune_id}" target="_blank" class="tune-action-btn" onclick="event.stopPropagation();">View on TheSession.org</a>`
        : '';

    // Determine what to show in the tune type badge based on sort mode
    const sortMode = sortModes[currentSortModeIndex];
    const isPopularityMode = sortMode.id === 'popularity-desc' || sortMode.id === 'popularity-asc';
    const typeLabel = isPopularityMode
        ? (tune.tunebook_count || 0).toString()
        : tune.tune_type || '';

    return `
        <div class="tune-card" onclick="showTuneDetail(${tune.person_tune_id}, event)">
            <div class="tune-card-header">
                <h3 class="tune-name">${tune.tune_name || 'Unknown'}</h3>
                ${typeLabel ? `<span class="tune-type">${typeLabel}</span>` : ''}
            </div>
            <div class="tune-meta">
                <div class="tune-meta-item">
                    <span class="status-badge ${statusClass}">${tune.learn_status}</span>
                </div>
                ${tune.tune_key ? `<div class="tune-meta-item">Key: ${tune.tune_key}</div>` : ''}
            </div>
            ${heardCountHTML}
            <div class="tune-actions">
                ${thesessionLink}
            </div>
        </div>
    `;
}

function clearFilters() {
    currentFilters = {
        search: '',
        type: '',
        status: ''
    };

    document.getElementById('search-input').value = '';
    document.getElementById('type-filter').value = '';

    // Reset status filter to "All"
    currentStatusFilterIndex = 0;
    document.getElementById('status-filter-icon').textContent = 'All';
    document.getElementById('status-filter-btn').classList.remove('active');

    applyFilters();
}

function incrementHeardCount(personTuneId) {
    const loading = showLoading('Updating heard count...');
    
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        loading.hide();
        showMessage('Heard count updated!', 'success');
        // Update the tune in our local data
        const tune = allTunes.find(t => t.person_tune_id === personTuneId);
        if (tune) {
            tune.heard_before_learning_count = data.heard_before_learning_count;
            applyFilters(); // Re-render
        }
    })
    .catch(error => {
        loading.hide();
        console.error('Error incrementing heard count:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function showTuneDetail(personTuneId, event) {
    console.log('=== showTuneDetail called ===');
    console.log('personTuneId:', personTuneId);
    console.log('Event passed to showTuneDetail:', event);
    if (event) {
        console.log('Event type:', event.type);
        console.log('Event target:', event.target);
        console.log('Event currentTarget:', event.currentTarget);
        console.log('Event bubbles:', event.bubbles);
        console.log('Event isTrusted:', event.isTrusted);
    }

    // Stop the click from propagating to prevent it from immediately closing the modal
    if (event) {
        console.log('Calling event.stopPropagation()');
        event.stopPropagation();
        console.log('After stopPropagation');
    } else {
        console.log('WARNING: No event passed to showTuneDetail');
    }

    // Find the tune in our local data to get basic info
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (!tune) {
        showMessage('Tune not found', 'error');
        return;
    }

    // Cancel any in-progress modal fetch
    if (modalFetchController) {
        console.log('Aborting previous modal fetch request');
        modalFetchController.abort();
    }

    // Create new AbortController for this fetch
    modalFetchController = new AbortController();
    console.log('Created new AbortController for modal fetch');

    // Show modal immediately with basic info
    displayTuneDetailModalBasic(tune);

    // Fetch full details in the background with abort signal
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        signal: modalFetchController.signal
    })
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                if (errorInfo.action) {
                    errorInfo.action();
                    return Promise.reject(new Error(errorInfo.message));
                }
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Update modal with full details
                displayTuneDetailModalFull(data.person_tune);
            } else {
                showMessage(data.error || 'Failed to load tune details', 'error');
            }
        })
        .catch(error => {
            // Don't show error if request was aborted
            if (error.name === 'AbortError') {
                console.log('Modal fetch request was aborted');
                return;
            }
            console.error('Error loading tune details:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');
        });
}

function displayTuneDetailModalBasic(tune) {
    console.log('=== displayTuneDetailModalBasic called ===');
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon - we can show this immediately if we have tune_id
    const thesessionLinkIcon = tune.tune_id
        ? `<a href="https://thesession.org/tunes/${tune.tune_id}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">🔗</a>`
        : '';

    // Show basic info with inline loading dots for numbers and disabled notes field
    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="onModalFieldChange()">
                ${statusOptions}
            </select>
        </div>
        <div id="modal-additional-info">
            <div class="modal-info-line">TheSession.org Tunebooks: <span class="loading-dots">...</span></div>
            <div class="modal-info-line">Play count at your sessions: <span class="loading-dots">...</span></div>
            <div class="modal-notes-section">
                <div class="modal-notes-label">Notes:</div>
                <textarea id="modal-notes-textarea" class="modal-notes-textarea" placeholder="Loading..." disabled oninput="onModalFieldChange()"></textarea>
                <button id="modal-save-btn" class="modal-save-btn" onclick="saveModalChanges()" disabled style="margin-top: 8px;">Save</button>
            </div>
        </div>
    `;

    // Store current tune ID and original status for updates
    modal.dataset.personTuneId = tune.person_tune_id;
    modal.dataset.originalStatus = tune.learn_status;

    // Show modal
    console.log('SHOWING MODAL - setting display = flex');
    console.log('Modal current display:', modal.style.display);
    modal.style.display = 'flex';
    console.log('Modal display after setting:', modal.style.display);

    // Add 'show' class after a small delay to trigger slide-in animation
    setTimeout(() => {
        modal.classList.add('show');
    }, 10);

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('modalShowTime set to:', modalShowTime);
    console.log('=== END displayTuneDetailModalBasic ===');
}

function displayTuneDetailModalFull(tune) {
    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">🔗</a>`
        : '';

    // Update the title to include the link
    const modalTitle = document.querySelector('.modal-tune-title');
    if (modalTitle) {
        modalTitle.innerHTML = `${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}`;
    }

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    // Build full additional info
    const additionalInfo = `
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <textarea id="modal-notes-textarea" class="modal-notes-textarea" placeholder="Add notes about this tune..." oninput="onModalFieldChange()">${tune.notes || ''}</textarea>
            <button id="modal-save-btn" class="modal-save-btn" onclick="saveModalChanges()" disabled style="margin-top: 8px;">Save</button>
        </div>
    `;

    // Replace the loading dots with the full info
    const additionalInfoDiv = document.getElementById('modal-additional-info');
    if (additionalInfoDiv) {
        additionalInfoDiv.innerHTML = additionalInfo;
    }

    // Enable the notes textarea now that data is loaded
    const notesTextarea = document.getElementById('modal-notes-textarea');
    if (notesTextarea) {
        notesTextarea.disabled = false;
    }

    // Store original notes for comparison
    const modal = document.getElementById('tune-detail-modal');
    modal.dataset.originalNotes = tune.notes || '';
}

function displayTuneDetailModal(tune) {
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">🔗</a>`
        : '';

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="updateStatusFromModal(${tune.person_tune_id})">
                ${statusOptions}
            </select>
        </div>
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}

        ${tune.notes ? `
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <p>${tune.notes}</p>
        </div>` : ''}
    `;

    // Store current tune ID for updates
    modal.dataset.personTuneId = tune.person_tune_id;

    // Show modal
    console.log('Showing modal - display: flex');
    modal.style.display = 'flex';

    // Add 'show' class after a small delay to trigger slide-in animation
    setTimeout(() => {
        modal.classList.add('show');
    }, 10);

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('Set modalShowTime to', modalShowTime);
}

function closeTuneDetailModal() {
    console.log('=== closeTuneDetailModal called ===');
    console.log('Stack trace:');
    console.trace();

    // Abort any in-progress modal fetch
    if (modalFetchController) {
        console.log('Aborting modal fetch request due to modal close');
        modalFetchController.abort();
        modalFetchController = null;
    }

    const modal = document.getElementById('tune-detail-modal');

    // Remove 'show' class to trigger slide-out animation
    modal.classList.remove('show');

    // Wait for animation to complete before hiding
    setTimeout(() => {
        modal.style.display = 'none';
        console.log('Modal closed');
    }, 300); // Match the CSS transition duration
}

function incrementHeardCountFromModal(personTuneId) {
    const loading = showLoading('Updating heard count...');
    
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        loading.hide();
        showMessage('Heard count updated!', 'success');
        
        // Update the tune in our local data
        const tune = allTunes.find(t => t.person_tune_id === personTuneId);
        if (tune) {
            tune.heard_before_learning_count = data.heard_before_learning_count;
            applyFilters(); // Re-render
        }
        
        // Update the modal display
        const heardCountSpan = document.getElementById('modal-heard-count');
        if (heardCountSpan) {
            heardCountSpan.textContent = data.heard_before_learning_count;
        }
    })
    .catch(error => {
        loading.hide();
        console.error('Error incrementing heard count:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function onModalFieldChange() {
    // Enable/disable the Save button based on whether status or notes changed
    const modal = document.getElementById('tune-detail-modal');
    const statusSelect = document.getElementById('modal-status-select');
    const textarea = document.getElementById('modal-notes-textarea');
    const saveBtn = document.getElementById('modal-save-btn');

    const originalStatus = modal.dataset.originalStatus || '';
    const originalNotes = modal.dataset.originalNotes || '';

    if (statusSelect && textarea && saveBtn) {
        const statusChanged = (statusSelect.value !== originalStatus);
        const notesChanged = (textarea.value !== originalNotes);
        const anyChanges = statusChanged || notesChanged;

        saveBtn.disabled = !anyChanges;

        // Make button blue when enabled
        if (anyChanges) {
            saveBtn.style.backgroundColor = 'var(--primary)';
            saveBtn.style.opacity = '1';
        } else {
            saveBtn.style.backgroundColor = '';
            saveBtn.style.opacity = '';
        }
    }
}

function saveModalChanges() {
    const modal = document.getElementById('tune-detail-modal');
    const statusSelect = document.getElementById('modal-status-select');
    const textarea = document.getElementById('modal-notes-textarea');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    const newStatus = statusSelect ? statusSelect.value : '';
    const newNotes = textarea ? textarea.value : '';
    const originalStatus = modal.dataset.originalStatus || '';
    const originalNotes = modal.dataset.originalNotes || '';

    const statusChanged = (newStatus !== originalStatus);
    const notesChanged = (newNotes !== originalNotes);

    // Don't save if nothing changed
    if (!statusChanged && !notesChanged) {
        return;
    }

    // Disable save button while saving
    const saveBtn = document.getElementById('modal-save-btn');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
    }

    // Prepare promises for API calls
    const promises = [];

    // Save status if changed
    if (statusChanged) {
        promises.push(
            fetchWithRetry(`/api/my-tunes/${personTuneId}/status`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ learn_status: newStatus })
            })
        );
    }

    // Save notes if changed
    if (notesChanged) {
        promises.push(
            fetchWithRetry(`/api/my-tunes/${personTuneId}/notes`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ notes: newNotes })
            })
        );
    }

    // Execute all promises
    Promise.all(promises)
        .then(responses => {
            // Check all responses are OK
            const allOk = responses.every(r => r.ok);
            if (!allOk) {
                throw new Error('Failed to save changes');
            }
            return Promise.all(responses.map(r => r.json()));
        })
        .then(results => {
            showMessage('Changes saved successfully!', 'success');

            // Update original values in modal
            modal.dataset.originalStatus = newStatus;
            modal.dataset.originalNotes = newNotes;

            // Update the tune in our local data
            const tune = allTunes.find(t => t.person_tune_id === personTuneId);
            if (tune) {
                tune.learn_status = newStatus;
                tune.notes = newNotes;
                if (newStatus === 'learned') {
                    tune.learned_date = new Date().toISOString();
                }
            }

            // Re-render the grid to show status change
            applyFilters();

            // Reset button
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'Save';
                saveBtn.style.backgroundColor = '';
                saveBtn.style.opacity = '';
            }

            // Close modal after successful save
            closeTuneDetailModal();
        })
        .catch(error => {
            console.error('Error saving changes:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');

            // Re-enable button
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save';
            }
        });
}

function showMessage(message, type) {
    // Create a temporary message element
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        border-radius: 4px;
        z-index: 10000;
        max-width: 500px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        animation: slideDown 0.3s ease-out;
    `;
    
    if (type === 'success') {
        messageDiv.style.backgroundColor = '#d4edda';
        messageDiv.style.color = '#155724';
        messageDiv.style.border = '1px solid #c3e6cb';
    } else if (type === 'error') {
        messageDiv.style.backgroundColor = '#f8d7da';
        messageDiv.style.color = '#721c24';
        messageDiv.style.border = '1px solid #f5c6cb';
    } else {
        messageDiv.style.backgroundColor = '#d1ecf1';
        messageDiv.style.color = '#0c5460';
        messageDiv.style.border = '1px solid #bee5eb';
    }
    
    messageDiv.textContent = message;
    document.body.appendChild(messageDiv);
    
    // Remove after 5 seconds
    setTimeout(() => {
        messageDiv.style.animation = 'slideUp 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(messageDiv);
        }, 300);
    }, 5000);
}
</script>

<style>
@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

@keyframes slideUp {
    from {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
    to {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
}
</style>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/my_tunes_mobile.js') }}"></script>
{% endblock %}
