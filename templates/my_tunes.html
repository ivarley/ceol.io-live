{% extends "base.html" %}

{% block title %}My Tunes - Personal Tune Collection{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/my_tunes_mobile.css') }}">
<style>
    /* Prevent page bounce/overscroll and pull-to-refresh on mobile */
    html, body {
        overscroll-behavior-y: none; /* Prevent pull-to-refresh */
        overscroll-behavior-x: none; /* Prevent horizontal bounce */
    }

    .my-tunes-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    /* Mobile compact view */
    @media (max-width: 768px) {
        /* Override parent container padding */
        .docs-content {
            padding: 0 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        .my-tunes-container {
            padding: 0;
            max-width: 100%;
            margin-top: 0;
            margin-left: 0;
            margin-right: 0;
        }

        .my-tunes-header-section {
            padding: 10px;
        }

        .page-header {
            margin-bottom: 4px;
            padding: 0;
        }

        .filters-container {
            margin-bottom: 6px;
            padding: 0;
        }

        .results-count {
            margin-bottom: 4px;
            font-size: 12px;
            padding: 0;
        }
    }

    .page-header {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }

    .page-header h1 {
        margin: 0;
    }

    .page-actions {
        display: flex;
        flex-direction: row;
        gap: 8px;
        align-items: center;
        margin-left: auto;
    }

    .btn {
        padding: 4px 12px;
        background-color: var(--primary);
        color: white !important;
        text-decoration: none;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 13px;
        transition: background-color 0.2s;
        white-space: nowrap;
        line-height: 1.2;
    }

    .btn:hover {
        background-color: var(--primary-dark, #0056b3);
        color: white !important;
        text-decoration: none;
    }

    .btn-secondary {
        background-color: var(--secondary, #6c757d);
        color: white !important;
    }

    .btn-secondary:hover {
        background-color: var(--secondary-dark, #5a6268);
        color: white !important;
    }

    .filters-container {
        margin-bottom: 20px;
    }

    .filter-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: nowrap;
    }

    .filter-group {
        display: flex;
        align-items: center;
        min-width: 0;
    }

    .filter-group:first-child {
        flex: 1;
        min-width: 0;
    }

    .filter-group label {
        display: none;
    }

    .filter-input {
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        width: 100%;
        min-width: 0;
        max-width: 200px;
    }

    .filter-select {
        padding: 8px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        width: 110px;
        flex-shrink: 0;
    }

    .status-filter-btn {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 60px;
        justify-content: center;
        flex-shrink: 0;
    }

    .status-filter-btn:hover {
        background-color: var(--hover-bg);
    }

    .status-filter-btn.active {
        background-color: var(--primary);
        color: white;
        border-color: var(--primary);
    }

    .tunes-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    /* Mobile compact tune list */
    @media (max-width: 768px) {
        .tunes-grid {
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-bottom: 10px;
        }
    }

    .tune-card {
        background-color: var(--bg-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        transition: box-shadow 0.2s, transform 0.2s;
        cursor: pointer;
    }

    @media (max-width: 768px) {
        .tune-card {
            border-radius: 0;
            border-left: none;
            border-right: none;
            border-top: none;
            padding: 8px 2px; /* Increased from 6px to 8px for 4px total height increase (2px top + 2px bottom) */
            margin: 0; /* No margin - border goes to edge */
            display: grid;
            grid-template-columns: 20px 1fr auto;
            grid-template-rows: auto; /* Single row only */
            grid-auto-rows: 0; /* Make any extra rows have 0 height */
            align-items: center;
            gap: 6px;
            max-width: 100%;
            overflow: hidden;
            min-height: 0; /* Prevent extra height */
        }

        .tune-card:first-child {
            border-top: 1px solid var(--border-color);
        }

        /* Force all direct children to be on row 1 or hidden */
        .tune-card > * {
            grid-row: 1;
        }
    }

    .tune-card:hover {
        box-shadow: 0 4px 12px var(--dropdown-shadow);
        transform: translateY(-2px);
    }

    @media (max-width: 768px) {
        .tune-card:hover {
            box-shadow: none;
            transform: none;
            background-color: transparent;
        }
    }

    .tune-card-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        margin-bottom: 15px;
    }

    @media (max-width: 768px) {
        .tune-card-header {
            /* Span columns 2-3, contains both tune-name and tune-type */
            grid-column: 2 / 4;
            grid-row: 1;
            margin-bottom: 0;
            min-width: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 6px;
        }
    }

    .tune-name {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-color);
        margin: 0;
        flex: 1;
    }

    @media (max-width: 768px) {
        .tune-name {
            font-size: 18px; /* Increased from 16px */
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
            max-width: calc(100vw - 100px); /* Reserve space for status (26px with gap) + tune type ("Barndance" ~90px with padding) + gaps (~19px) - extended 35px */
            flex: 0 1 auto; /* Don't grow, allow shrink */
        }
    }

    .tune-type {
        font-size: 12px;
        padding: 4px 8px;
        background-color: var(--primary);
        color: white;
        border-radius: 4px;
        text-transform: capitalize;
        white-space: nowrap;
        margin-left: 10px;
    }

    @media (max-width: 768px) {
        .tune-type {
            font-size: 12px; /* Increased from 10px */
            padding: 2px 6px;
            margin-left: 0;
            flex-shrink: 0; /* Never shrink */
            white-space: nowrap;
        }
    }

    .tune-meta {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 15px;
        font-size: 14px;
        color: var(--text-muted, #6c757d);
    }

    @media (max-width: 768px) {
        .tune-meta {
            /* Don't participate in grid - let status-badge position itself */
            display: contents; /* Make children direct grid participants */
        }
    }

    .tune-meta-item {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    @media (max-width: 768px) {
        .tune-meta-item {
            /* Don't participate in grid - let status-badge position itself */
            display: contents; /* Make children direct grid participants */
        }

        /* Hide the "Key: X" meta item on mobile */
        .tune-meta-item:not(:first-child) {
            display: none !important;
        }

        /* Ensure only the first meta-item participates */
        .tune-meta-item:first-child {
            display: contents;
        }
    }

    .status-badge {
        display: inline-block;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        text-transform: capitalize;
    }

    @media (max-width: 768px) {
        .status-badge {
            /* Grid column 1: fixed 20px column */
            grid-column: 1;
            grid-row: 1;
            padding: 0;
            border-radius: 0;
            font-size: 16px;
            background-color: transparent !important;
            width: 20px;
            height: 20px;
            min-width: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .status-badge::before {
            font-size: 16px;
        }

        .status-want-to-learn::before {
            content: '★';
            color: #f0ad4e;
        }

        .status-learning::before {
            content: '⋯';
            color: #5bc0de;
        }

        .status-learned::before {
            content: '✓';
            color: #5cb85c;
        }

        /* Hide the text on mobile */
        .status-badge {
            font-size: 0;
        }
    }

    .status-want-to-learn {
        background-color: #fff3cd;
        color: #856404;
    }

    .status-learning {
        background-color: #d1ecf1;
        color: #0c5460;
    }

    .status-learned {
        background-color: #d4edda;
        color: #155724;
    }

    .tune-actions {
        display: flex;
        gap: 10px;
        margin-top: 15px;
    }

    @media (max-width: 768px) {
        .tune-actions {
            display: none !important; /* Force hide completely */
        }
    }

    .tune-action-btn {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        background-color: var(--bg-color);
        color: var(--text-color);
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: background-color 0.2s;
        text-align: center;
        text-decoration: none;
    }

    .tune-action-btn:hover {
        background-color: var(--hover-bg);
        text-decoration: none;
        color: var(--text-color);
    }

    .heard-count-container {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 10px;
        padding: 8px;
        background-color: var(--light);
        border-radius: 4px;
    }

    @media (max-width: 768px) {
        .heard-count-container {
            display: none !important; /* Force hide completely */
        }
    }

    .heard-count {
        font-weight: 600;
        color: var(--primary);
    }

    .increment-heard-btn {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 1px solid var(--primary);
        background-color: var(--bg-color);
        color: var(--primary);
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .increment-heard-btn:hover {
        background-color: var(--primary);
        color: white;
    }

    .no-results {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted, #6c757d);
    }

    .no-results h3 {
        margin-bottom: 10px;
    }

    .loading {
        text-align: center;
        padding: 60px 20px;
        color: var(--text-muted, #6c757d);
    }

    .loading-more {
        text-align: center;
        padding: 20px;
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        display: none;
    }

    .loading-more.visible {
        display: block;
    }

    .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .results-count {
        margin-bottom: 15px;
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
    }

    .sort-toggle {
        padding: 4px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        user-select: none;
    }

    .sort-toggle:hover {
        background-color: var(--hover-bg);
    }

    .sort-toggle.active {
        background-color: var(--primary);
        color: white;
        border-color: var(--primary);
    }

    @media (max-width: 768px) {
        .results-count {
            font-size: 12px;
            gap: 6px;
            flex-wrap: wrap;
        }

        .sort-toggle {
            font-size: 11px;
            padding: 3px 6px;
        }
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
        .my-tunes-container {
            padding: 0;
        }

        .page-header {
            gap: 6px;
        }

        .page-header h1 {
            font-size: 22px;
        }

        .btn {
            padding: 4px 10px;
            font-size: 12px;
        }

        .page-actions {
            gap: 6px;
        }

        .tunes-grid {
            grid-template-columns: 1fr;
            gap: 0; /* No gap between rows in mobile */
        }

        .filters-container {
            margin-bottom: 15px;
        }

        .filter-row {
            gap: 5px;
        }

        .filter-input {
            font-size: 16px;
            padding: 8px 6px;
            max-width: none;
            height: 40px;
            box-sizing: border-box;
        }

        .filter-select {
            width: 85px;
            font-size: 13px;
            padding: 8px 4px;
            height: 40px;
            box-sizing: border-box;
        }

        .status-filter-btn {
            padding: 8px 6px;
            font-size: 13px;
            min-width: 45px;
            gap: 4px;
            height: 40px;
            box-sizing: border-box;
        }

        /* Touch-friendly button sizes */
        .tune-action-btn,
        .increment-heard-btn {
            min-height: 44px;
            min-width: 44px;
        }
    }

    /* Dark mode adjustments */
    [data-theme="dark"] .status-want-to-learn {
        background-color: #664d03;
        color: #ffecb5;
    }

    [data-theme="dark"] .status-learning {
        background-color: #055160;
        color: #b6effb;
    }

    [data-theme="dark"] .status-learned {
        background-color: #0f5132;
        color: #badbcc;
    }

    /* Loading dots animation */
    .loading-dots {
        font-weight: bold;
        display: inline-block;
        animation: pulse-dots 1.5s ease-in-out infinite;
    }

    @keyframes pulse-dots {
        0%, 100% {
            opacity: 0.3;
        }
        50% {
            opacity: 1;
        }
    }

    /* Tune Detail Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 10000;
        display: none;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
    }

    .modal-dialog {
        background: var(--bg-color, white);
        border-radius: 8px;
        padding: 0;
        max-width: 600px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        color: var(--text-color);
        position: relative;
        pointer-events: auto;
        z-index: 1;
    }

    #tune-detail-content {
        padding: 20px;
    }

    .modal-close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 28px;
        color: var(--text-muted, #999);
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }

    .modal-close-btn:hover {
        color: var(--text-color);
    }

    .modal-tune-title {
        margin: 0 32px 12px 0;
        color: var(--text-color);
        font-size: 22px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .thesession-link-icon {
        font-size: 18px;
        text-decoration: none;
        color: var(--primary);
        opacity: 0.8;
    }

    .thesession-link-icon:hover {
        opacity: 1;
    }

    .modal-header-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
        width: 100%;
    }

    .modal-status-select {
        padding: 6px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        flex: 1;
        min-width: 0;
    }

    .modal-save-btn {
        padding: 6px 16px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        display: block;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: 20px;
    }

    .modal-save-btn:hover:not(:disabled) {
        background-color: var(--primary-dark, #0056b3);
    }

    .modal-save-btn:disabled {
        background-color: var(--secondary, #6c757d);
        cursor: not-allowed;
        opacity: 0.5;
    }

    [data-theme="dark"] .modal-save-btn:disabled {
        background-color: #555;
    }

    .modal-info-line {
        color: var(--text-muted, #6c757d);
        font-size: 14px;
        margin-bottom: 8px;
    }

    .modal-session-play-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 8px;
    }

    .modal-view-btn {
        padding: 4px 12px;
        background-color: var(--primary);
        color: white !important;
        text-decoration: none;
        border-radius: 4px;
        font-size: 13px;
        white-space: nowrap;
        flex-shrink: 0;
    }

    .modal-view-btn:hover {
        background-color: var(--primary-dark, #0056b3);
        color: white !important;
        text-decoration: none;
    }

    .modal-notes-section {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--border-color);
    }

    .modal-notes-label {
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--text-color);
    }

    .modal-notes-section p {
        margin: 0;
        color: var(--text-color);
        font-size: 14px;
        line-height: 1.5;
    }

    .modal-notes-textarea {
        width: 100%;
        min-height: 80px;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        font-family: inherit;
        background-color: var(--bg-color);
        color: var(--text-color);
        resize: vertical;
        box-sizing: border-box;
    }

    .modal-notes-textarea:focus {
        outline: none;
        border-color: var(--primary);
    }

    .modal-notes-textarea:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: var(--light, #f8f9fa);
    }

    [data-theme="dark"] .modal-notes-textarea:disabled {
        background-color: #2a2a2a;
    }

    /* Setting ID and Name Alias field styles */
    .modal-field-section {
        margin-bottom: 12px;
    }

    .modal-field-label {
        font-size: 13px;
        color: var(--text-muted, #6c757d);
        margin-bottom: 4px;
        display: block;
    }

    .modal-field-input {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        box-sizing: border-box;
    }

    .modal-field-input:focus {
        outline: none;
        border-color: var(--primary);
    }

    .modal-field-input:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: var(--light, #f8f9fa);
    }

    [data-theme="dark"] .modal-field-input:disabled {
        background-color: #2a2a2a;
    }

    .modal-tune-title-editable {
        cursor: pointer;
        transition: opacity 0.2s;
    }

    .modal-tune-title-editable:hover {
        opacity: 0.7;
    }

    .name-alias-hint {
        font-size: 11px;
        color: var(--text-muted, #999);
        font-style: italic;
        margin-top: 2px;
    }

    .modal-field-error {
        font-size: 12px;
        color: #dc3545;
        margin-top: 4px;
        font-weight: 500;
    }

    /* Heard count controls */
    .heard-count-row {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
        padding: 12px;
        background-color: var(--light, #f8f9fa);
        border-radius: 4px;
    }

    [data-theme="dark"] .heard-count-row {
        background-color: #2a2a2a;
    }

    .heard-count-label {
        font-size: 14px;
        color: var(--text-color);
        flex: 1;
        transition: opacity 0.2s;
    }

    /* Dim the label when increment button is disabled (data not loaded) */
    .heard-count-btn-increment:disabled ~ .heard-count-label,
    .heard-count-controls:has(.heard-count-btn-increment:disabled) ~ .heard-count-label {
        opacity: 0.4;
    }

    /* Alternative approach using parent container */
    .heard-count-row:has(.heard-count-btn-increment:disabled) .heard-count-label {
        opacity: 0.4;
    }

    .heard-count-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .heard-count-btn {
        width: 32px;
        height: 32px;
        border-radius: 4px;
        border: none;
        color: white;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s;
    }

    .heard-count-btn:hover:not(:disabled) {
        opacity: 0.8;
    }

    .heard-count-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
    }

    .heard-count-btn-decrement {
        background-color: #dc3545;
    }

    .heard-count-btn-increment {
        background-color: #28a745;
    }

    .heard-count-value {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-color);
        min-width: 30px;
        text-align: center;
    }

    /* Old swipe styles removed - see new implementation near bottom of file */

    /* Mobile adjustments for modal - full page slide-in */
    @media (max-width: 768px) {
        .modal-overlay {
            background-color: transparent;
            align-items: flex-start;
            justify-content: flex-end;
            pointer-events: none; /* Allow clicks through to header */
        }

        .modal-dialog {
            width: 100%;
            max-width: 100%;
            height: calc(100vh - 40px); /* Account for header height */
            max-height: calc(100vh - 40px);
            margin: 0;
            margin-top: 40px; /* Start below header */
            border-radius: 0;
            position: fixed;
            right: 0;
            top: 0;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            box-shadow: -4px 0 12px rgba(0,0,0,0.2);
            pointer-events: auto; /* Re-enable clicks on the dialog */
        }

        .modal-overlay.show .modal-dialog {
            transform: translateX(0);
        }

        #tune-detail-content {
            padding: 16px;
            padding-top: 16px; /* No extra space at top */
        }

        .modal-tune-title {
            font-size: 18px;
            margin-right: 48px; /* Space for back button */
            margin-top: 0;
            margin-left: 0;
        }

        .modal-close-btn {
            position: fixed;
            top: 8px; /* Top corner of screen */
            right: 8px; /* Right corner of screen */
            left: auto;
            font-size: 0; /* Hide the × */
            width: 40px;
            height: 40px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            z-index: 10001; /* Above modal */
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close-btn::before {
            content: '>';
            font-size: 24px;
            font-weight: bold;
            color: var(--text-color);
        }

        .modal-close-btn:hover {
            background-color: var(--hover-bg);
        }

        .modal-header-row {
            flex-wrap: wrap;
        }

        .modal-status-select {
            max-width: none;
        }

        .modal-info-line {
            font-size: 13px;
        }

        .modal-session-play-row {
            flex-direction: row;
            align-items: center;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="my-tunes-container">
    <div class="my-tunes-header-section">
        <div class="page-header">
            <h1>My Tunes</h1>
            <div class="page-actions">
                <a href="/my-tunes/add" class="btn">Add</a>
                <a href="/my-tunes/sync" class="btn btn-secondary">Sync</a>
            </div>
        </div>

        <div class="filters-container">
            <div class="filter-row">
                <div class="filter-group">
                    <input
                        type="text"
                        id="search-input"
                        class="filter-input"
                        placeholder="Search"
                        title="Search tunes"
                        autocomplete="off"
                    >
                </div>
                <div class="filter-group">
                    <select id="type-filter" class="filter-select" title="Tune type">
                        <option value="">All Types</option>
                    </select>
                </div>
                <div class="filter-group">
                    <button id="status-filter-btn" class="status-filter-btn" onclick="cycleStatusFilter()" title="Filter by learning status">
                        <span id="status-filter-icon">All</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="results-count">
            <span id="results-count-text"></span>
            <button id="sort-toggle" class="sort-toggle" onclick="cycleSortMode()" title="Toggle sort order">
                <span id="sort-icon">a-z</span>
            </button>
        </div>
    </div>

    <div id="loading" class="loading" style="display: none;">
        <p>Loading your tunes...</p>
    </div>

    <div id="no-results" class="no-results" style="display: none;">
        <h3>No tunes found</h3>
        <p id="no-results-message">Try adjusting your filters or add your first tune to get started!</p>
        <div id="no-results-action" style="margin-top: 15px;"></div>
    </div>

    <div class="tunes-grid" id="tunes-grid">
        <!-- Tune cards will be inserted here by JavaScript -->
    </div>

    <div id="loading-more" class="loading-more">
        <span class="loading-spinner"></span>
        <span>Loading more tunes...</span>
    </div>
</div>

<!-- Tune Detail Modal -->
<div id="tune-detail-modal" class="modal-overlay">
    <div class="modal-dialog">
        <div id="tune-detail-content">
            <!-- Content will be inserted by JavaScript -->
        </div>
    </div>
</div>

<script>
// Helper functions for API calls
function fetchWithRetry(url, options = {}) {
    return fetch(url, options);
}

function handleApiError(error, response = null) {
    if (response) {
        if (response.status === 401) {
            return { message: 'Please log in again', action: () => window.location.href = '/login' };
        }
        if (response.status === 404) {
            return { message: 'Not found', retryable: false };
        }
        if (response.status >= 500) {
            return { message: 'Server error. Please try again.', retryable: true };
        }
        return { message: 'An error occurred. Please try again.', retryable: true };
    }
    return { message: error?.message || 'An error occurred', retryable: true };
}

function showLoading(message = 'Loading...') {
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loading-overlay';
    loadingDiv.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(255,255,255,0.9); z-index: 9999;
        display: flex; align-items: center; justify-content: center;
        flex-direction: column; gap: 15px;
    `;
    loadingDiv.innerHTML = `
        <div style="width: 40px; height: 40px; border: 4px solid #ddd;
                    border-top-color: #007bff; border-radius: 50%;
                    animation: spin 0.8s linear infinite;"></div>
        <div style="color: #333; font-size: 16px;">${message}</div>
    `;
    const style = document.createElement('style');
    style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
    document.head.appendChild(style);
    document.body.appendChild(loadingDiv);
    return {
        hide: () => {
            if (loadingDiv.parentNode) loadingDiv.parentNode.removeChild(loadingDiv);
            if (style.parentNode) style.parentNode.removeChild(style);
        }
    };
}

// Build a thesession.org URL with optional setting parameter
// Format: https://thesession.org/tunes/{tune_id}?setting={setting_id}#setting{setting_id}
function buildTheSessionUrl(tuneId, settingId) {
    if (!tuneId) return '';

    const baseUrl = `https://thesession.org/tunes/${tuneId}`;

    if (settingId) {
        return `${baseUrl}?setting=${settingId}#setting${settingId}`;
    }

    return baseUrl;
}

// Extract setting ID from thesession.org URL or plain number
// Handles formats:
// - Plain number: 123
// - Query param: ?setting=123 or &setting=123
// - Hash anchor: #setting123
// - Combined: ?setting=123#setting123
function extractSettingId(input) {
    if (!input || input.trim() === '') {
        return null;
    }

    const trimmed = input.trim();

    // If it's already just a number, return it
    if (/^\d+$/.test(trimmed)) {
        return parseInt(trimmed);
    }

    // Try to extract from URL query param format first: ?setting=123 or &setting=123
    // This is the authoritative source if present
    const queryMatch = trimmed.match(/[?&]setting=(\d+)/);
    if (queryMatch) {
        return parseInt(queryMatch[1]);
    }

    // Fall back to hash format: #setting123
    const hashMatch = trimmed.match(/#setting(\d+)/);
    if (hashMatch) {
        return parseInt(hashMatch[1]);
    }

    // Couldn't parse - return null
    return null;
}

// Validate that input is either empty, a number, or a valid thesession.org URL
function validateSettingId(input) {
    if (!input || input.trim() === '') {
        return { valid: true, settingId: null };
    }

    const trimmed = input.trim();

    // Check if it's just a number
    if (/^\d+$/.test(trimmed)) {
        return { valid: true, settingId: parseInt(trimmed) };
    }

    // Check if it's a valid thesession.org URL
    if (trimmed.includes('thesession.org')) {
        const settingId = extractSettingId(trimmed);
        if (settingId !== null) {
            return { valid: true, settingId: settingId };
        }
    }

    // Invalid input
    return { valid: false, settingId: null, error: 'Please enter a number or paste a valid TheSession.org URL' };
}

// Handle setting ID input with instant parsing and validation
function onSettingIdInput() {
    const input = document.getElementById('modal-setting-id-input');
    const errorDiv = document.getElementById('modal-setting-id-error');

    if (!input || !errorDiv) return;

    const value = input.value;
    const validation = validateSettingId(value);

    if (!validation.valid) {
        // Show error
        errorDiv.textContent = validation.error;
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';

        // Disable save button
        const saveBtn = document.getElementById('modal-save-btn');
        if (saveBtn) {
            saveBtn.disabled = true;
        }
    } else {
        // Clear error
        errorDiv.style.display = 'none';
        input.style.borderColor = '';

        // If we extracted a setting ID from a URL, replace the input with just the number
        if (validation.settingId !== null && value !== validation.settingId.toString()) {
            input.value = validation.settingId.toString();
        }

        // Trigger field change detection
        onModalFieldChange();
    }
}

let allTunes = [];
let filteredTunes = [];
let currentFilters = {
    search: '',
    type: '',
    status: ''
};
let modalShowTime = 0;
let modalFetchController = null; // AbortController for modal fetch requests
let isLoadingFullTunes = false; // Track if full tune list is still loading
let fullTunesLoaded = false; // Track if we have all tunes

// Status filter cycle states
const statusFilterStates = [
    { value: '', label: 'All', icon: 'All' },
    { value: 'learned', label: 'Learned', icon: '✓' },
    { value: 'learning', label: 'Learning', icon: '⋯' },
    { value: 'want to learn', label: 'Want to Learn', icon: '★' }
];
let currentStatusFilterIndex = 0;

// Sort mode cycle states
const sortModes = [
    { id: 'alpha-asc', label: 'a-z', icon: 'a-z', sortFn: (a, b) => (a.tune_name || '').localeCompare(b.tune_name || '') },
    { id: 'alpha-desc', label: 'z-a', icon: 'z-a', sortFn: (a, b) => (b.tune_name || '').localeCompare(a.tune_name || '') },
    { id: 'popularity-desc', label: 'popularity high', icon: '#', sortFn: (a, b) => (b.tunebook_count || 0) - (a.tunebook_count || 0) },
    { id: 'popularity-asc', label: 'popularity low', icon: '#ꜜ', sortFn: (a, b) => (a.tunebook_count || 0) - (b.tunebook_count || 0) }
];
let currentSortModeIndex = 0;

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadTunes();
    setupEventListeners();
    loadFiltersFromURL();
    checkForSuccessMessage();
    setupScrollDetection();
});

function setupScrollDetection() {
    // Detect scroll to show loading indicator if still loading
    window.addEventListener('scroll', function() {
        if (!isLoadingFullTunes || fullTunesLoaded) {
            return;
        }

        const tunesGrid = document.getElementById('tunes-grid');
        const loadingMore = document.getElementById('loading-more');

        if (!tunesGrid || !loadingMore) {
            return;
        }

        // Get the bottom position of the tunes grid
        const gridRect = tunesGrid.getBoundingClientRect();
        const gridBottom = gridRect.bottom;

        // Get viewport height
        const viewportHeight = window.innerHeight;

        // If we're within 200px of the bottom of the grid, show loading indicator
        if (gridBottom < viewportHeight + 200) {
            loadingMore.classList.add('visible');
        }
    });
}

function checkForSuccessMessage() {
    const params = new URLSearchParams(window.location.search);
    if (params.has('added')) {
        const tuneName = params.get('added');
        showMessage(`Successfully added "${tuneName}" to your collection!`, 'success');
        // Clean up URL
        params.delete('added');
        const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
        window.history.replaceState({}, '', newURL);
    }
}

function setupEventListeners() {
    // Search input with debounce
    let searchTimeout;
    document.getElementById('search-input').addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            currentFilters.search = e.target.value.toLowerCase().trim();
            applyFilters();
        }, 300);
    });

    // Filter dropdowns
    document.getElementById('type-filter').addEventListener('change', function(e) {
        currentFilters.type = e.target.value;
        applyFilters();
    });

    // Modal overlay click handler - close when clicking outside
    const modalOverlay = document.getElementById('tune-detail-modal');

    // Add click handler to modal dialog to stop propagation
    const setupModalDialogHandler = () => {
        const modalDialog = modalOverlay.querySelector('.modal-dialog');
        if (modalDialog) {
            modalDialog.addEventListener('click', function(event) {
                console.log('Click inside modal-dialog, stopping propagation');
                console.log('Clicked element:', event.target.tagName, event.target.className);
                event.stopPropagation();
            });
            console.log('Modal dialog click handler attached');
        } else {
            console.log('Modal dialog not found yet, will retry');
            // Try again after a short delay (in case modal hasn't been rendered yet)
            setTimeout(setupModalDialogHandler, 100);
        }
    };

    // Initial setup
    setupModalDialogHandler();

    modalOverlay.addEventListener('click', function(event) {
        console.log('=== MODAL OVERLAY CLICK EVENT ===');
        console.log('event.target:', event.target);
        console.log('event.target.tagName:', event.target.tagName);
        console.log('event.target.className:', event.target.className);
        console.log('event.target.id:', event.target.id);
        console.log('event.target.classList:', event.target.classList);
        console.log('Has modal-overlay class:', event.target.classList.contains('modal-overlay'));
        console.log('event.currentTarget:', event.currentTarget);
        console.log('event.currentTarget.id:', event.currentTarget.id);
        console.log('Time since modal shown:', Date.now() - modalShowTime, 'ms');
        console.log('Event detail (click count):', event.detail);
        console.log('Event isTrusted:', event.isTrusted);
        console.log('Event type:', event.type);
        console.log('Event bubbles:', event.bubbles);
        console.log('Event cancelable:', event.cancelable);
        console.log('Event defaultPrevented:', event.defaultPrevented);

        // Log parent elements to understand the hierarchy
        let parent = event.target.parentElement;
        let depth = 0;
        console.log('Parent chain:');
        while (parent && depth < 5) {
            console.log(`  ${depth}: ${parent.tagName}.${parent.className} #${parent.id}`);
            parent = parent.parentElement;
            depth++;
        }

        // Ignore clicks that happen too soon after modal opens (within 500ms)
        // This prevents the synthesized click from touch events from closing the modal
        const timeSinceShown = Date.now() - modalShowTime;
        if (timeSinceShown < 500) {
            console.log('RESULT: Ignoring click - modal just opened', timeSinceShown, 'ms ago');
            return;
        }

        // Only close if clicking directly on the overlay (not on the modal dialog or its children)
        // event.target is the overlay AND event.currentTarget is the overlay means we clicked
        // directly on the overlay background, not on any child elements
        if (event.target === event.currentTarget && event.target.classList.contains('modal-overlay')) {
            console.log('RESULT: Closing modal - clicked directly on overlay background');
            closeTuneDetailModal();
        } else {
            console.log('RESULT: NOT closing modal - clicked inside modal dialog');
            console.log('  Clicked element:', event.target.tagName, event.target.className);
        }
        console.log('=== END MODAL CLICK EVENT ===');
    });

    // Setup swipe-to-close for mobile
    setupSwipeToClose();

    // Setup swipe-right for heard count on tune cards
    setupTuneCardSwipe();
}

function setupTuneCardSwipe() {
    // This will be called after each render to attach swipe handlers to tune cards
    // We'll set up a delegated event listener on the grid
    const grid = document.getElementById('tunes-grid');
    if (!grid) return;

    let touchStartX = 0;
    let touchStartY = 0;
    let swipedCard = null;

    grid.addEventListener('touchstart', function(e) {
        // Check if touch is on a tune card with "want to learn" status
        const card = e.target.closest('.tune-card[data-can-swipe="true"]');
        if (!card) return;

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        swipedCard = card;
    }, { passive: true });

    grid.addEventListener('touchmove', function(e) {
        if (!swipedCard) return;

        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Check if it's a right swipe (and mostly horizontal)
        if (deltaX > 20 && Math.abs(deltaX) > Math.abs(deltaY) * 2) {
            swipedCard.classList.add('swiping');
        } else {
            swipedCard.classList.remove('swiping');
        }
    }, { passive: true });

    grid.addEventListener('touchend', function(e) {
        if (!swipedCard) return;

        const touchEndX = e.changedTouches[0].clientX;
        const deltaX = touchEndX - touchStartX;

        // If swiped far enough to the right, trigger the heard count increment
        if (deltaX > 80) {
            const personTuneId = parseInt(swipedCard.dataset.personTuneId);
            if (personTuneId) {
                incrementHeardCount(personTuneId);
            }
        }

        // Reset
        if (swipedCard) {
            swipedCard.classList.remove('swiping');
        }
        swipedCard = null;
        touchStartX = 0;
        touchStartY = 0;
    }, { passive: true });
}

function setupSwipeToClose() {
    const modalDialog = document.querySelector('.modal-dialog');
    if (!modalDialog) return;

    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let isSwiping = false;

    modalDialog.addEventListener('touchstart', function(e) {
        // Don't intercept touches on input controls
        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            return;
        }

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        isSwiping = false;
    }, { passive: true });

    modalDialog.addEventListener('touchmove', function(e) {
        if (!touchStartX) return;

        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            return;
        }

        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Detect horizontal swipe (more horizontal than vertical)
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            isSwiping = true;
        }
    }, { passive: true });

    modalDialog.addEventListener('touchend', function(e) {
        if (!touchStartX || !isSwiping) {
            touchStartX = 0;
            touchStartY = 0;
            return;
        }

        const target = e.target;
        if (target.tagName === 'INPUT' ||
            target.tagName === 'TEXTAREA' ||
            target.tagName === 'SELECT' ||
            target.tagName === 'BUTTON' ||
            target.tagName === 'A') {
            touchStartX = 0;
            touchStartY = 0;
            isSwiping = false;
            return;
        }

        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const deltaTime = Date.now() - touchStartTime;

        // Swipe right: deltaX > 0 and significant horizontal movement
        // Must be mostly horizontal (not diagonal) and fast enough or far enough
        if (deltaX > 50 && Math.abs(deltaX) > Math.abs(deltaY) * 2) {
            // Swipe right detected - close modal
            console.log('Swipe right detected, closing modal');
            closeTuneDetailModal();
        }

        touchStartX = 0;
        touchStartY = 0;
        isSwiping = false;
    }, { passive: true });
}

function cycleStatusFilter() {
    currentStatusFilterIndex = (currentStatusFilterIndex + 1) % statusFilterStates.length;
    const state = statusFilterStates[currentStatusFilterIndex];
    currentFilters.status = state.value;

    // Update button display
    const btn = document.getElementById('status-filter-btn');
    const icon = document.getElementById('status-filter-icon');
    icon.textContent = state.icon;

    // Add active class if filtering
    if (state.value) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }

    applyFilters();
}

function cycleSortMode() {
    currentSortModeIndex = (currentSortModeIndex + 1) % sortModes.length;
    const mode = sortModes[currentSortModeIndex];

    // Update button display
    const icon = document.getElementById('sort-icon');
    icon.textContent = mode.icon;

    // Re-apply filters and sorting (no DB reload needed)
    applyFilters();
}

function loadFiltersFromURL() {
    const params = new URLSearchParams(window.location.search);

    if (params.has('search')) {
        currentFilters.search = params.get('search');
        document.getElementById('search-input').value = params.get('search');
    }

    if (params.has('type')) {
        currentFilters.type = params.get('type');
        document.getElementById('type-filter').value = params.get('type');
    }

    if (params.has('status')) {
        const status = params.get('status');
        currentFilters.status = status;

        // Find the matching status filter state
        const index = statusFilterStates.findIndex(s => s.value === status);
        if (index >= 0) {
            currentStatusFilterIndex = index;
            const state = statusFilterStates[index];
            document.getElementById('status-filter-icon').textContent = state.icon;

            if (state.value) {
                document.getElementById('status-filter-btn').classList.add('active');
            }
        }
    }

    if (params.has('sort')) {
        const sortId = params.get('sort');
        const index = sortModes.findIndex(s => s.id === sortId);
        if (index >= 0) {
            currentSortModeIndex = index;
            const mode = sortModes[index];
            document.getElementById('sort-icon').textContent = mode.icon;
        }
    }
}

function updateURL() {
    const params = new URLSearchParams();

    if (currentFilters.search) params.set('search', currentFilters.search);
    if (currentFilters.type) params.set('type', currentFilters.type);
    if (currentFilters.status) params.set('status', currentFilters.status);

    // Only add sort param if not default (alpha-asc)
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.id !== 'alpha-asc') {
        params.set('sort', sortMode.id);
    }

    const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
    window.history.replaceState({}, '', newURL);
}

function loadTunes() {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('tunes-grid').style.display = 'none';
    document.getElementById('no-results').style.display = 'none';
    document.getElementById('loading-more').classList.remove('visible');

    // Reset state
    fullTunesLoaded = false;
    isLoadingFullTunes = true;

    // Get current sort mode for API query
    const sortMode = sortModes[currentSortModeIndex];
    const sortParam = sortMode ? sortMode.id : 'alpha-asc';

    // First, fetch initial 20 tunes for fast display
    fetchWithRetry(`/api/my-tunes?per_page=20&sort=${sortParam}`)
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                if (errorInfo.action) {
                    errorInfo.action();
                    return Promise.reject(new Error(errorInfo.message));
                }
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            // Only update if we don't already have the full tune list
            // This prevents the 20-tune response from overwriting the 2000-tune response
            if (!fullTunesLoaded) {
                allTunes = data.tunes || [];
                populateTuneTypes();
                applyFilters();

                // If we got fewer than 20, we have all tunes
                if (allTunes.length < 20) {
                    fullTunesLoaded = true;
                    isLoadingFullTunes = false;
                }
            }
        })
        .catch(error => {
            console.error('Error loading initial tunes:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');

            // Show retry option if retryable
            if (errorInfo.retryable) {
                showRetryOption();
            }

            document.getElementById('loading').style.display = 'none';
            isLoadingFullTunes = false;
        });

    // In parallel, fetch all tunes (up to 2000)
    fetchWithRetry(`/api/my-tunes?per_page=2000&sort=${sortParam}`)
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            // Replace with full tune list - this should always take precedence
            allTunes = data.tunes || [];
            fullTunesLoaded = true;
            isLoadingFullTunes = false;

            // Hide loading-more indicator
            document.getElementById('loading-more').classList.remove('visible');

            populateTuneTypes();
            applyFilters();
        })
        .catch(error => {
            console.error('Error loading full tune list:', error);
            isLoadingFullTunes = false;
            // Don't show error if we already have initial tunes
            if (allTunes.length === 0) {
                const errorInfo = handleApiError(error);
                showMessage(errorInfo.message, 'error');
            }
            document.getElementById('loading-more').classList.remove('visible');
        });
}

function showRetryOption() {
    const grid = document.getElementById('tunes-grid');
    grid.innerHTML = `
        <div class="error-state">
            <div class="error-state-icon">⚠️</div>
            <div class="error-state-title">Failed to Load Tunes</div>
            <div class="error-state-message">There was a problem loading your tune collection.</div>
            <div class="error-state-action">
                <button class="retry-btn" onclick="loadTunes()">
                    <span class="retry-icon">↻</span>
                    Retry
                </button>
            </div>
        </div>
    `;
    grid.style.display = 'grid';
}

function populateTuneTypes() {
    const types = [...new Set(allTunes.map(tune => tune.tune_type).filter(Boolean))];
    types.sort();
    
    const typeFilter = document.getElementById('type-filter');
    const currentValue = typeFilter.value;
    
    // Keep "All Types" option and add tune types
    typeFilter.innerHTML = '<option value="">All Types</option>';
    types.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        typeFilter.appendChild(option);
    });
    
    // Restore selected value if it still exists
    if (currentValue && types.includes(currentValue)) {
        typeFilter.value = currentValue;
    }
}

function applyFilters() {
    filteredTunes = allTunes.filter(tune => {
        // Search filter
        if (currentFilters.search) {
            const searchLower = currentFilters.search.toLowerCase();
            const nameMatch = tune.tune_name && tune.tune_name.toLowerCase().includes(searchLower);
            if (!nameMatch) return false;
        }

        // Type filter
        if (currentFilters.type && tune.tune_type !== currentFilters.type) {
            return false;
        }

        // Status filter
        if (currentFilters.status && tune.learn_status !== currentFilters.status) {
            return false;
        }

        return true;
    });

    // Apply client-side sorting
    const sortMode = sortModes[currentSortModeIndex];
    if (sortMode && sortMode.sortFn) {
        filteredTunes.sort(sortMode.sortFn);
    }

    updateURL();
    renderTunes();
}

function renderTunes() {
    document.getElementById('loading').style.display = 'none';

    const grid = document.getElementById('tunes-grid');
    const noResults = document.getElementById('no-results');
    const resultsCountText = document.getElementById('results-count-text');

    if (filteredTunes.length === 0) {
        grid.style.display = 'none';
        noResults.style.display = 'block';
        resultsCountText.textContent = '';

        // Check if any filters are active (excluding search)
        const hasActiveFilters = currentFilters.type || currentFilters.status;
        const actionDiv = document.getElementById('no-results-action');

        if (hasActiveFilters) {
            // Show "Clear Filters" link
            actionDiv.innerHTML = '<a href="#" onclick="clearFilters(); return false;" class="btn">Clear Filters</a>';
        } else {
            // Show "Add Tune" link
            actionDiv.innerHTML = '<a href="/my-tunes/add" class="btn">Add Tune</a>';
        }

        return;
    }

    grid.style.display = 'grid';
    noResults.style.display = 'none';

    // Update results count - only show if full tunes are loaded
    if (fullTunesLoaded) {
        const total = allTunes.length;
        const filtered = filteredTunes.length;
        if (filtered < total) {
            resultsCountText.textContent = `Showing ${filtered} of ${total} tunes`;
        } else {
            resultsCountText.textContent = `${total} tune${total !== 1 ? 's' : ''}`;
        }
    } else {
        // Don't show count until full data is loaded
        resultsCountText.textContent = '';
    }

    // Render tune cards
    console.log('Rendering', filteredTunes.length, 'tunes. Window width:', window.innerWidth);
    const wantToLearnCount = filteredTunes.filter(t => t.learn_status === 'want to learn').length;
    console.log('Want to learn tunes:', wantToLearnCount);

    grid.innerHTML = filteredTunes.map(tune => createTuneCard(tune)).join('');

    // Initialize swipe listeners for mobile
    if (window.innerWidth <= 768) {
        initializeSwipeListeners();
    }
}

function initializeSwipeListeners() {
    const swipeContainers = document.querySelectorAll('.tune-card-swipe-container');

    console.log('Initializing swipe listeners for', swipeContainers.length, 'containers');

    // Global variable to track currently revealed row
    let currentlyRevealed = null;

    swipeContainers.forEach((container, index) => {
        const card = container.querySelector('.tune-card-swipeable');
        const button = container.querySelector('.swipe-action-btn');
        const actionDiv = container.querySelector('.tune-card-swipe-action');

        if (!card || !button || !actionDiv) {
            console.error('Missing elements in container', index);
            return;
        }

        const buttonWidth = 80; // matches CSS
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let isDragging = false;
        let isRevealed = false;
        let swipeDirection = null; // 'horizontal' or 'vertical'

        // Track touch/mouse position during swipe
        card.addEventListener('touchstart', (e) => {
            console.log('touchstart');
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            currentX = 0;
            isDragging = true;
            swipeDirection = null;

            // Close any previously revealed row (different from current)
            if (currentlyRevealed && currentlyRevealed !== container) {
                const prevCard = currentlyRevealed.querySelector('.tune-card-swipeable');
                const prevActionDiv = currentlyRevealed.querySelector('.tune-card-swipe-action');
                if (prevCard && prevActionDiv) {
                    prevCard.classList.remove('revealed');
                    prevCard.style.transform = '';
                    prevActionDiv.style.width = '0px';
                }
                currentlyRevealed = null;
            }

            // If this card was previously revealed, close it immediately when starting new drag
            if (isRevealed) {
                card.classList.remove('revealed');
                isRevealed = false;
                card.style.transform = '';
                actionDiv.style.width = '0px';
            }
        }, { passive: true });

        card.addEventListener('touchmove', (e) => {
            if (!isDragging) return;

            const touch = e.touches[0];
            const diffX = touch.clientX - startX; // Changed: now positive when moving right
            const diffY = touch.clientY - startY;

            // Determine swipe direction on first move
            if (swipeDirection === null && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    swipeDirection = 'horizontal';
                    card.classList.add('swiping');
                } else {
                    swipeDirection = 'vertical';
                }
            }

            // Only handle horizontal swipes
            if (swipeDirection === 'horizontal') {
                // Only allow right swipe (positive diffX means finger moving right)
                if (diffX > 0) {
                    currentX = Math.min(diffX, buttonWidth * 2); // Allow swipe up to 2x button width

                    // Update card position - move card right
                    card.style.transform = `translateX(${currentX}px)`;

                    // Button width matches drag distance (so it reveals progressively)
                    actionDiv.style.width = `${currentX}px`;

                    // Prevent scrolling for horizontal swipes
                    e.preventDefault();
                }
            }
        }, { passive: false });

        card.addEventListener('touchend', (e) => {
            console.log('touchend - swipeDirection:', swipeDirection, 'currentX:', currentX);
            if (!isDragging) return;
            isDragging = false;
            card.classList.remove('swiping');

            // Only process horizontal swipes
            if (swipeDirection === 'horizontal') {
                // Determine action based on swipe distance
                if (currentX > buttonWidth) {
                    // Swiped past button width - trigger increment
                    console.log('Triggering increment (swiped past button width)');
                    currentlyRevealed = null; // Clear global tracking
                    triggerIncrementWithAnimation(container, button);
                } else if (currentX > buttonWidth * 0.25) {
                    // Swiped more than 25% - stay revealed
                    console.log('Staying revealed');
                    // Set transform to current position, force reflow, then add class to animate
                    const currentPosition = currentX;
                    card.style.transform = `translateX(${currentPosition}px)`;
                    card.offsetHeight; // Force reflow
                    card.classList.add('revealed');
                    isRevealed = true;
                    currentlyRevealed = container; // Track globally
                    // Clear inline transform so class takes over
                    setTimeout(() => {
                        card.style.transform = '';
                    }, 0);
                    actionDiv.style.width = `${buttonWidth}px`;
                } else {
                    // Swiped less than 25% - slide back
                    console.log('Sliding back');
                    card.classList.remove('revealed');
                    isRevealed = false;
                    currentlyRevealed = null; // Clear global tracking
                    card.style.transform = '';
                    actionDiv.style.width = '0px';
                }
            }

            currentX = 0;
            swipeDirection = null;
        }, { passive: true });

        // Handle button click
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Button clicked');
            currentlyRevealed = null; // Clear global tracking
            triggerIncrementWithAnimation(container, button);
        });

        // Close revealed state when tapping elsewhere
        document.addEventListener('click', (e) => {
            if (isRevealed && !container.contains(e.target)) {
                card.classList.remove('revealed');
                isRevealed = false;
                currentlyRevealed = null; // Clear global tracking
                actionDiv.style.width = '0px';
            }
        });
    });
}

function triggerIncrementWithAnimation(container, button) {
    const personTuneId = parseInt(button.dataset.personTuneId);
    const card = container.querySelector('.tune-card-swipeable');

    // Get current heard count
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    const oldCount = tune ? tune.heard_count : 0;

    // Animate button click
    button.style.backgroundColor = '#218838';
    setTimeout(() => {
        button.style.backgroundColor = '';
    }, 200);

    // Slide card back
    card.classList.remove('revealed');
    card.style.transform = '';

    // Call increment function with old count for toast message
    incrementHeardCountWithToast(personTuneId, oldCount);
}

function createTuneCard(tune) {
    const statusClass = `status-${tune.learn_status.replace(/ /g, '-')}`;
    const heardCountHTML = tune.learn_status === 'want to learn' && tune.heard_count > 0
        ? `<div class="heard-count-container">
               <span>Heard at sessions:</span>
               <span class="heard-count">${tune.heard_count}</span>
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Increment heard count">+</button>
           </div>`
        : tune.learn_status === 'want to learn'
        ? `<div class="heard-count-container">
               <button class="increment-heard-btn" onclick="incrementHeardCount(${tune.person_tune_id}); event.stopPropagation();" title="Mark as heard">+</button>
               <span style="font-size: 12px;">Mark as heard</span>
           </div>`
        : '';

    const thesessionUrl = buildTheSessionUrl(tune.tune_id, tune.setting_id);
    const thesessionLink = thesessionUrl
        ? `<a href="${thesessionUrl}" target="_blank" class="tune-action-btn" onclick="event.stopPropagation();">View on TheSession.org</a>`
        : '';

    // Determine what to show in the tune type badge based on sort mode
    const sortMode = sortModes[currentSortModeIndex];
    const isPopularityMode = sortMode.id === 'popularity-desc' || sortMode.id === 'popularity-asc';
    const typeLabel = isPopularityMode
        ? (tune.tunebook_count || 0).toString()
        : tune.tune_type || '';

    // Add data attribute for swipe functionality on mobile
    const swipeAttr = `data-person-tune-id="${tune.person_tune_id}"`;

    // Show increment button for all tunes on mobile
    const canIncrement = true;

    // For mobile, wrap all cards in a container with the action button
    const isMobile = window.innerWidth <= 768;
    if (isMobile) {
        return `
            <div class="tune-card-swipe-container" ${swipeAttr}>
                <div class="tune-card-swipe-action">
                    <button class="swipe-action-btn" data-action="increment" data-person-tune-id="${tune.person_tune_id}">
                        <span class="swipe-action-icon">+</span>
                    </button>
                </div>
                <div class="tune-card tune-card-swipeable" onclick="showTuneDetail(${tune.person_tune_id}, event)">
                    <div class="tune-card-header">
                        <h3 class="tune-name">${tune.tune_name || 'Unknown'}</h3>
                        ${typeLabel ? `<span class="tune-type">${typeLabel}</span>` : ''}
                    </div>
                    <div class="tune-meta">
                        <div class="tune-meta-item">
                            <span class="status-badge ${statusClass}">${tune.learn_status}</span>
                        </div>
                        ${tune.tune_key ? `<div class="tune-meta-item">Key: ${tune.tune_key}</div>` : ''}
                    </div>
                    ${heardCountHTML}
                    <div class="tune-actions">
                        ${thesessionLink}
                    </div>
                </div>
            </div>
        `;
    } else {
        return `
            <div class="tune-card" ${swipeAttr} onclick="showTuneDetail(${tune.person_tune_id}, event)">
                <div class="tune-card-header">
                    <h3 class="tune-name">${tune.tune_name || 'Unknown'}</h3>
                    ${typeLabel ? `<span class="tune-type">${typeLabel}</span>` : ''}
                </div>
                <div class="tune-meta">
                    <div class="tune-meta-item">
                        <span class="status-badge ${statusClass}">${tune.learn_status}</span>
                    </div>
                    ${tune.tune_key ? `<div class="tune-meta-item">Key: ${tune.tune_key}</div>` : ''}
                </div>
                ${heardCountHTML}
                <div class="tune-actions">
                    ${thesessionLink}
                </div>
            </div>
        `;
    }
}

function clearFilters() {
    currentFilters = {
        search: '',
        type: '',
        status: ''
    };

    document.getElementById('search-input').value = '';
    document.getElementById('type-filter').value = '';

    // Reset status filter to "All"
    currentStatusFilterIndex = 0;
    document.getElementById('status-filter-icon').textContent = 'All';
    document.getElementById('status-filter-btn').classList.remove('active');

    applyFilters();
}

function incrementHeardCount(personTuneId) {
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    const oldCount = tune ? tune.heard_count : 0;
    incrementHeardCountWithToast(personTuneId, oldCount);
}

function incrementHeardCountWithToast(personTuneId, oldCount) {
    // Optimistically update UI and show toast immediately
    const newCount = oldCount + 1;
    showMessage(`Heard count: ${oldCount} → ${newCount}`, 'success');

    // Update local data immediately
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (tune) {
        tune.heard_count = newCount;
        applyFilters(); // Re-render
    }

    // Send update to server in background
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        // Silently sync the actual count from server
        if (tune && data.heard_count !== newCount) {
            tune.heard_count = data.heard_count;
            applyFilters(); // Re-render with actual count
        }
    })
    .catch(error => {
        console.error('Error incrementing heard count:', error);
        // Revert the optimistic update on error
        if (tune) {
            tune.heard_count = oldCount;
            applyFilters();
        }
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function showTuneDetail(personTuneId, event) {
    console.log('=== showTuneDetail called ===');
    console.log('personTuneId:', personTuneId);
    console.log('Event passed to showTuneDetail:', event);
    if (event) {
        console.log('Event type:', event.type);
        console.log('Event target:', event.target);
        console.log('Event currentTarget:', event.currentTarget);
        console.log('Event bubbles:', event.bubbles);
        console.log('Event isTrusted:', event.isTrusted);
    }

    // Stop the click from propagating to prevent it from immediately closing the modal
    if (event) {
        console.log('Calling event.stopPropagation()');
        event.stopPropagation();
        console.log('After stopPropagation');
    } else {
        console.log('WARNING: No event passed to showTuneDetail');
    }

    // Find the tune in our local data to get basic info
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (!tune) {
        showMessage('Tune not found', 'error');
        return;
    }

    // Cancel any in-progress modal fetch
    if (modalFetchController) {
        console.log('Aborting previous modal fetch request');
        modalFetchController.abort();
    }

    // Create new AbortController for this fetch
    modalFetchController = new AbortController();
    console.log('Created new AbortController for modal fetch');

    // Show modal immediately with basic info
    displayTuneDetailModalBasic(tune);

    // Fetch full details in the background with abort signal
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        signal: modalFetchController.signal
    })
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                if (errorInfo.action) {
                    errorInfo.action();
                    return Promise.reject(new Error(errorInfo.message));
                }
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Update modal with full details
                displayTuneDetailModalFull(data.person_tune);
            } else {
                showMessage(data.error || 'Failed to load tune details', 'error');
            }
        })
        .catch(error => {
            // Don't show error if request was aborted
            if (error.name === 'AbortError') {
                console.log('Modal fetch request was aborted');
                return;
            }
            console.error('Error loading tune details:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');
        });
}

function displayTuneDetailModalBasic(tune) {
    console.log('=== displayTuneDetailModalBasic called ===');
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon - we can show this immediately if we have tune_id
    // Use setting_id if available to link to specific setting
    const thesessionUrl = buildTheSessionUrl(tune.tune_id, tune.setting_id);
    const thesessionLinkIcon = thesessionUrl
        ? `<a href="${thesessionUrl}" target="_blank" class="thesession-link-icon" title="View on TheSession.org" onclick="event.stopPropagation();">🔗</a>`
        : '';

    // Show basic info with inline loading dots for numbers and disabled notes field
    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title modal-tune-title-editable" id="modal-tune-title" onclick="toggleNameAliasEdit()" title="Click to set custom name">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-field-section" id="name-alias-section" style="display: none;">
            <label class="modal-field-label">I call this:</label>
            <input type="text" id="modal-name-alias-input" class="modal-field-input" placeholder="Enter your custom name for this tune" oninput="onModalFieldChange()">
            <div class="name-alias-hint">Click title again to hide this field</div>
        </div>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="onModalFieldChange()">
                ${statusOptions}
            </select>
        </div>
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <textarea id="modal-notes-textarea" class="modal-notes-textarea" placeholder="Loading..." disabled oninput="onModalFieldChange()"></textarea>
        </div>
        <div class="modal-field-section">
            <label class="modal-field-label">If you play a specific setting of the tune, enter the URL or setting ID here:</label>
            <input type="text" id="modal-setting-id-input" class="modal-field-input" placeholder="e.g., 123 or paste URL" disabled oninput="onSettingIdInput()">
            <div id="modal-setting-id-error" class="modal-field-error" style="display: none;"></div>
        </div>
        <div class="heard-count-row">
            <div class="heard-count-label">I've heard this <span id="modal-heard-count-value">0</span> <span id="modal-heard-count-unit">times</span></div>
            <div class="heard-count-controls">
                <button class="heard-count-btn heard-count-btn-decrement" onclick="decrementHeardCountModal()" title="Decrement heard count" disabled>-</button>
                <button class="heard-count-btn heard-count-btn-increment" onclick="incrementHeardCountModal()" title="Increment heard count" disabled>+</button>
            </div>
        </div>
        <button id="modal-save-btn" class="modal-save-btn" onclick="saveModalChanges()" disabled>Save</button>
        <div id="modal-additional-info">
            <div class="modal-info-line">TheSession.org Tunebooks: <span class="loading-dots">...</span></div>
            <div class="modal-info-line">Play count at your sessions: <span class="loading-dots">...</span></div>
        </div>
    `;

    // Store current tune ID and original status for updates
    modal.dataset.personTuneId = tune.person_tune_id;
    modal.dataset.originalStatus = tune.learn_status;
    modal.dataset.originalSettingId = '';
    modal.dataset.originalNameAlias = '';

    // Show modal
    console.log('SHOWING MODAL - setting display = flex');
    console.log('Modal current display:', modal.style.display);
    modal.style.display = 'flex';
    console.log('Modal display after setting:', modal.style.display);

    // Add 'show' class after a small delay to trigger slide-in animation
    setTimeout(() => {
        modal.classList.add('show');
    }, 10);

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('modalShowTime set to:', modalShowTime);
    console.log('=== END displayTuneDetailModalBasic ===');
}

function displayTuneDetailModalFull(tune) {
    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">🔗</a>`
        : '';

    // Update the title to include the link - show name_alias if it exists, otherwise tune_name
    const displayName = tune.name_alias || tune.tune_name || 'Unknown Tune';
    const modalTitle = document.querySelector('.modal-tune-title');
    if (modalTitle) {
        modalTitle.innerHTML = `${displayName} ${thesessionLinkIcon}`;
    }

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    // Populate notes field
    const notesTextarea = document.getElementById('modal-notes-textarea');
    if (notesTextarea) {
        notesTextarea.value = tune.notes || '';
        notesTextarea.disabled = false;
        notesTextarea.placeholder = 'Add notes about this tune...';
    }

    // Build full additional info (just the read-only stats)
    const additionalInfo = `
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}
    `;

    // Replace the loading dots with the full info
    const additionalInfoDiv = document.getElementById('modal-additional-info');
    if (additionalInfoDiv) {
        additionalInfoDiv.innerHTML = additionalInfo;
    }

    // Populate the setting ID input field (it's in the main modal HTML now)
    const settingIdInput = document.getElementById('modal-setting-id-input');
    if (settingIdInput) {
        settingIdInput.value = tune.setting_id || '';
        settingIdInput.disabled = false;
    }

    // Populate name alias field if it exists
    const nameAliasInput = document.getElementById('modal-name-alias-input');
    if (nameAliasInput) {
        nameAliasInput.value = tune.name_alias || '';
    }

    // Update heard count display
    updateHeardCountDisplay(tune.heard_count || 0);

    // Update button states
    updateHeardCountButtonStates();

    // Store original values for comparison
    const modal = document.getElementById('tune-detail-modal');
    modal.dataset.originalNotes = tune.notes || '';
    modal.dataset.originalSettingId = tune.setting_id || '';
    modal.dataset.originalNameAlias = tune.name_alias || '';
    modal.dataset.currentHeardCount = tune.heard_count || 0;
}

function displayTuneDetailModal(tune) {
    const modal = document.getElementById('tune-detail-modal');
    const modalContent = document.getElementById('tune-detail-content');

    // Build status options
    const statuses = ['want to learn', 'learning', 'learned'];
    const statusOptions = statuses.map(status => {
        const selected = status === tune.learn_status ? 'selected' : '';
        const label = status.charAt(0).toUpperCase() + status.slice(1);
        return `<option value="${status}" ${selected}>${label}</option>`;
    }).join('');

    // Get tune type badge
    const tuneTypeBadge = tune.tune_type
        ? `<span class="tune-type">${tune.tune_type}</span>`
        : '';

    // Build thesession.org link icon
    const thesessionLinkIcon = tune.thesession_url
        ? `<a href="${tune.thesession_url}" target="_blank" class="thesession-link-icon" title="View on TheSession.org">🔗</a>`
        : '';

    // Build session play info
    const sessionPlayInfo = tune.session_play_count !== undefined && tune.session_play_count > 0
        ? `<div class="modal-info-line">Play count at your sessions: ${tune.session_play_count}</div>`
        : '';

    modalContent.innerHTML = `
        <button class="modal-close-btn" onclick="closeTuneDetailModal()" title="Close">&times;</button>
        <h2 class="modal-tune-title">${tune.tune_name || 'Unknown Tune'} ${thesessionLinkIcon}</h2>
        <div class="modal-header-row">
            ${tuneTypeBadge}
            <select id="modal-status-select" class="modal-status-select" onchange="updateStatusFromModal(${tune.person_tune_id})">
                ${statusOptions}
            </select>
        </div>
        <div class="modal-info-line">TheSession.org Tunebooks: ${tune.tunebook_count || 0}</div>
        ${sessionPlayInfo}

        ${tune.notes ? `
        <div class="modal-notes-section">
            <div class="modal-notes-label">Notes:</div>
            <p>${tune.notes}</p>
        </div>` : ''}
    `;

    // Store current tune ID for updates
    modal.dataset.personTuneId = tune.person_tune_id;

    // Show modal
    console.log('Showing modal - display: flex');
    modal.style.display = 'flex';

    // Add 'show' class after a small delay to trigger slide-in animation
    setTimeout(() => {
        modal.classList.add('show');
    }, 10);

    // Record the time when modal is shown (used to ignore immediate clicks)
    modalShowTime = Date.now();
    console.log('Set modalShowTime to', modalShowTime);
}

function closeTuneDetailModal() {
    console.log('=== closeTuneDetailModal called ===');
    console.log('Stack trace:');
    console.trace();

    // Abort any in-progress modal fetch
    if (modalFetchController) {
        console.log('Aborting modal fetch request due to modal close');
        modalFetchController.abort();
        modalFetchController = null;
    }

    const modal = document.getElementById('tune-detail-modal');

    // Remove 'show' class to trigger slide-out animation
    modal.classList.remove('show');

    // Wait for animation to complete before hiding
    setTimeout(() => {
        modal.style.display = 'none';
        console.log('Modal closed');
    }, 300); // Match the CSS transition duration
}

function incrementHeardCountFromModal(personTuneId) {
    const loading = showLoading('Updating heard count...');
    
    fetchWithRetry(`/api/my-tunes/${personTuneId}/heard`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        loading.hide();
        showMessage('Heard count updated!', 'success');
        
        // Update the tune in our local data
        const tune = allTunes.find(t => t.person_tune_id === personTuneId);
        if (tune) {
            tune.heard_count = data.heard_count;
            applyFilters(); // Re-render
        }
        
        // Update the modal display
        const heardCountSpan = document.getElementById('modal-heard-count');
        if (heardCountSpan) {
            heardCountSpan.textContent = data.heard_count;
        }
    })
    .catch(error => {
        loading.hide();
        console.error('Error incrementing heard count:', error);
        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function toggleNameAliasEdit() {
    const section = document.getElementById('name-alias-section');
    if (section) {
        const isHidden = section.style.display === 'none';
        section.style.display = isHidden ? 'block' : 'none';
        if (isHidden) {
            // Focus the input when shown
            const input = document.getElementById('modal-name-alias-input');
            if (input) {
                setTimeout(() => input.focus(), 100);
            }
        }
    }
}

function updateHeardCountDisplay(count) {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const heardCountUnit = document.getElementById('modal-heard-count-unit');

    if (heardCountValue) {
        heardCountValue.textContent = count;
    }

    if (heardCountUnit) {
        heardCountUnit.textContent = count === 1 ? 'time' : 'times';
    }
}

function updateHeardCountButtonStates() {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const decrementBtn = document.querySelector('.heard-count-btn-decrement');
    const incrementBtn = document.querySelector('.heard-count-btn-increment');

    if (heardCountValue && decrementBtn && incrementBtn) {
        const currentCount = parseInt(heardCountValue.textContent) || 0;

        // Enable both buttons (data is loaded)
        incrementBtn.disabled = false;

        // Disable decrement only if count is 0
        decrementBtn.disabled = currentCount === 0;
    }
}

function incrementHeardCountModal() {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const modal = document.getElementById('tune-detail-modal');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    if (!heardCountValue) return;

    const currentCount = parseInt(heardCountValue.textContent) || 0;
    const newCount = currentCount + 1;

    // Update UI immediately
    updateHeardCountDisplay(newCount);
    updateHeardCountButtonStates();

    // Update the tune in our local data
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (tune) {
        tune.heard_count = newCount;
        applyFilters(); // Re-render
    }

    // Update stored count
    modal.dataset.currentHeardCount = newCount;

    // Send update to server in background
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ heard_count: newCount })
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        if (!data.success) {
            throw new Error(data.error || 'Failed to update heard count');
        }
        // Success - no toast, already updated UI
    })
    .catch(error => {
        console.error('Error incrementing heard count:', error);
        // Revert the change on error
        updateHeardCountDisplay(currentCount);
        updateHeardCountButtonStates();
        if (tune) {
            tune.heard_count = currentCount;
            applyFilters();
        }
        modal.dataset.currentHeardCount = currentCount;

        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function decrementHeardCountModal() {
    const heardCountValue = document.getElementById('modal-heard-count-value');
    const modal = document.getElementById('tune-detail-modal');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    if (!heardCountValue) return;

    const currentCount = parseInt(heardCountValue.textContent) || 0;
    if (currentCount === 0) return; // Can't go below zero

    const newCount = currentCount - 1;

    // Update UI immediately
    updateHeardCountDisplay(newCount);
    updateHeardCountButtonStates();

    // Update the tune in our local data
    const tune = allTunes.find(t => t.person_tune_id === personTuneId);
    if (tune) {
        tune.heard_count = newCount;
        applyFilters(); // Re-render
    }

    // Update stored count
    modal.dataset.currentHeardCount = newCount;

    // Send update to server in background
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ heard_count: newCount })
    })
    .then(response => {
        if (!response.ok) {
            const errorInfo = handleApiError(null, response);
            throw new Error(errorInfo.message);
        }
        return response.json();
    })
    .then(data => {
        if (!data.success) {
            throw new Error(data.error || 'Failed to update heard count');
        }
        // Success - no toast, already updated UI
    })
    .catch(error => {
        console.error('Error decrementing heard count:', error);
        // Revert the change on error
        updateHeardCountDisplay(currentCount);
        updateHeardCountButtonStates();
        if (tune) {
            tune.heard_count = currentCount;
            applyFilters();
        }
        modal.dataset.currentHeardCount = currentCount;

        const errorInfo = handleApiError(error);
        showMessage(errorInfo.message, 'error');
    });
}

function onModalFieldChange() {
    // Enable/disable the Save button based on whether any field changed
    const modal = document.getElementById('tune-detail-modal');
    const statusSelect = document.getElementById('modal-status-select');
    const textarea = document.getElementById('modal-notes-textarea');
    const settingIdInput = document.getElementById('modal-setting-id-input');
    const nameAliasInput = document.getElementById('modal-name-alias-input');
    const saveBtn = document.getElementById('modal-save-btn');

    const originalStatus = modal.dataset.originalStatus || '';
    const originalNotes = modal.dataset.originalNotes || '';
    const originalSettingId = modal.dataset.originalSettingId || '';
    const originalNameAlias = modal.dataset.originalNameAlias || '';

    if (saveBtn) {
        const statusChanged = statusSelect && (statusSelect.value !== originalStatus);
        const notesChanged = textarea && (textarea.value !== originalNotes);

        // For setting ID, extract the numeric value and compare
        const currentSettingId = settingIdInput ? extractSettingId(settingIdInput.value) : null;
        const originalSettingIdNum = originalSettingId ? parseInt(originalSettingId) : null;
        const settingIdChanged = (currentSettingId !== originalSettingIdNum);

        const nameAliasChanged = nameAliasInput && (nameAliasInput.value !== originalNameAlias);

        const anyChanges = statusChanged || notesChanged || settingIdChanged || nameAliasChanged;

        saveBtn.disabled = !anyChanges;

        // Make button blue when enabled
        if (anyChanges) {
            saveBtn.style.backgroundColor = 'var(--primary)';
            saveBtn.style.opacity = '1';
        } else {
            saveBtn.style.backgroundColor = '';
            saveBtn.style.opacity = '';
        }
    }
}

function saveModalChanges() {
    const modal = document.getElementById('tune-detail-modal');
    const statusSelect = document.getElementById('modal-status-select');
    const textarea = document.getElementById('modal-notes-textarea');
    const settingIdInput = document.getElementById('modal-setting-id-input');
    const nameAliasInput = document.getElementById('modal-name-alias-input');
    const personTuneId = parseInt(modal.dataset.personTuneId);

    const newStatus = statusSelect ? statusSelect.value : '';
    const newNotes = textarea ? textarea.value : '';
    const newSettingIdRaw = settingIdInput ? settingIdInput.value : '';
    const newNameAlias = nameAliasInput ? nameAliasInput.value : '';

    // Validate setting ID before proceeding
    const settingIdValidation = validateSettingId(newSettingIdRaw);
    if (!settingIdValidation.valid) {
        const errorDiv = document.getElementById('modal-setting-id-error');
        if (errorDiv) {
            errorDiv.textContent = settingIdValidation.error;
            errorDiv.style.display = 'block';
        }
        if (settingIdInput) {
            settingIdInput.style.borderColor = '#dc3545';
        }
        return; // Don't proceed with save
    }

    const originalStatus = modal.dataset.originalStatus || '';
    const originalNotes = modal.dataset.originalNotes || '';
    const originalSettingId = modal.dataset.originalSettingId || '';
    const originalNameAlias = modal.dataset.originalNameAlias || '';

    const statusChanged = (newStatus !== originalStatus);
    const notesChanged = (newNotes !== originalNotes);

    // Extract numeric setting ID
    const newSettingId = settingIdValidation.settingId;
    const originalSettingIdNum = originalSettingId ? parseInt(originalSettingId) : null;
    const settingIdChanged = (newSettingId !== originalSettingIdNum);

    const nameAliasChanged = (newNameAlias !== originalNameAlias);

    // Don't save if nothing changed
    if (!statusChanged && !notesChanged && !settingIdChanged && !nameAliasChanged) {
        return;
    }

    // Disable save button while saving
    const saveBtn = document.getElementById('modal-save-btn');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
    }

    // Build update payload - only include changed fields
    const updates = {};
    if (statusChanged) updates.learn_status = newStatus;
    if (notesChanged) updates.notes = newNotes;
    if (settingIdChanged) updates.setting_id = newSettingId;
    if (nameAliasChanged) updates.name_alias = newNameAlias || null; // Convert empty string to null

    // Call unified API endpoint
    fetchWithRetry(`/api/my-tunes/${personTuneId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updates)
    })
        .then(response => {
            if (!response.ok) {
                const errorInfo = handleApiError(null, response);
                throw new Error(errorInfo.message);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                showMessage('Changes saved successfully!', 'success');

                // Update original values in modal
                modal.dataset.originalStatus = newStatus;
                modal.dataset.originalNotes = newNotes;
                modal.dataset.originalSettingId = newSettingId || '';
                modal.dataset.originalNameAlias = newNameAlias;

                // Update the tune in our local data
                const tune = allTunes.find(t => t.person_tune_id === personTuneId);
                if (tune) {
                    if (statusChanged) {
                        tune.learn_status = newStatus;
                        if (newStatus === 'learned') {
                            tune.learned_date = new Date().toISOString();
                        }
                    }
                    if (notesChanged) tune.notes = newNotes;
                    if (settingIdChanged) tune.setting_id = newSettingId;
                    if (nameAliasChanged) {
                        tune.name_alias = newNameAlias || null;
                        // Update tune_name to reflect the change
                        // The backend returns the updated tune with the correct tune_name,
                        // but we need to update it locally for immediate display
                        if (data.person_tune && data.person_tune.tune_name) {
                            tune.tune_name = data.person_tune.tune_name;
                        }
                    }
                }

                // Update the modal title if name alias or setting changed
                if (nameAliasChanged || settingIdChanged) {
                    const modalTitle = document.querySelector('.modal-tune-title');
                    if (modalTitle && tune) {
                        const displayName = tune.name_alias || tune.tune_name || 'Unknown Tune';
                        const thesessionUrl = buildTheSessionUrl(tune.tune_id, tune.setting_id);
                        const linkHtml = thesessionUrl
                            ? `<a href="${thesessionUrl}" target="_blank" class="thesession-link-icon" title="View on TheSession.org" onclick="event.stopPropagation();">🔗</a>`
                            : '';
                        modalTitle.innerHTML = `${displayName} ${linkHtml}`;
                    }
                }

                // Re-render the grid to show changes
                applyFilters();

                // Reset button
                if (saveBtn) {
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Save';
                    saveBtn.style.backgroundColor = '';
                    saveBtn.style.opacity = '';
                }

                // Close modal after successful save
                closeTuneDetailModal();
            } else {
                throw new Error(data.error || 'Failed to save changes');
            }
        })
        .catch(error => {
            console.error('Error saving changes:', error);
            const errorInfo = handleApiError(error);
            showMessage(errorInfo.message, 'error');

            // Re-enable button
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save';
            }
        });
}

function showMessage(message, type) {
    // Create a temporary message element
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        border-radius: 4px;
        z-index: 10000;
        max-width: 500px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        animation: slideDown 0.3s ease-out;
    `;
    
    if (type === 'success') {
        messageDiv.style.backgroundColor = '#d4edda';
        messageDiv.style.color = '#155724';
        messageDiv.style.border = '1px solid #c3e6cb';
    } else if (type === 'error') {
        messageDiv.style.backgroundColor = '#f8d7da';
        messageDiv.style.color = '#721c24';
        messageDiv.style.border = '1px solid #f5c6cb';
    } else {
        messageDiv.style.backgroundColor = '#d1ecf1';
        messageDiv.style.color = '#0c5460';
        messageDiv.style.border = '1px solid #bee5eb';
    }
    
    messageDiv.textContent = message;
    document.body.appendChild(messageDiv);
    
    // Remove after 5 seconds
    setTimeout(() => {
        messageDiv.style.animation = 'slideUp 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(messageDiv);
        }, 300);
    }, 5000);
}
</script>

<style>
/* Swipe-to-reveal styles for mobile */
@media (max-width: 768px) {
    .tune-card-swipe-container {
        position: relative;
        overflow: visible; /* Changed from hidden to see button */
        width: 100%;
        height: 100%;
    }

    .tune-card-swipe-action {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 0; /* Start hidden, will be set by JS during drag */
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #28a745;
        z-index: 0; /* Behind the card */
        overflow: hidden;
    }

    .swipe-action-btn {
        width: 100%;
        height: 100%;
        border: none;
        background: transparent;
        color: white;
        font-size: 32px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        transition: background-color 0.2s;
    }

    .swipe-action-btn:active {
        background-color: #218838;
    }

    .swipe-action-icon {
        display: block;
        line-height: 1;
    }

    .tune-card-swipeable {
        position: relative;
        z-index: 1; /* In front of the button */
        background-color: var(--bg-color);
        transition: transform 0.3s ease-out;
        transform: translateX(0);
        width: 100%;
    }

    .tune-card-swipeable.swiping {
        transition: none;
    }

    .tune-card-swipeable.revealed {
        transform: translateX(80px);
    }
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

@keyframes slideUp {
    from {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
    to {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
}
</style>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/swipe-listener.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/my_tunes_mobile.js') }}"></script>
{% endblock %}
