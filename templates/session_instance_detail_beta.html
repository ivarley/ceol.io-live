{% extends "base.html" %}

{% block title %}{{ session_instance.session_name }} - {{ session_instance.date }} - Irish Music Session Details (Beta){% endblock %}

{% block extra_css %}
<style>
        .hidden {
            display: none;
        }
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .loading-ellipsis {
            display: inline-block;
            color: var(--disabled-text);
        }
        .loading-ellipsis:after {
            content: '...';
            animation: ellipsis 1.5s infinite;
            width: 1em;
            text-align: left;
            display: inline-block;
        }
        @keyframes ellipsis {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .cancelled-date {
            color: var(--danger, #dc3545);
            text-decoration: line-through;
        }
        .cancelled-message {
            padding: 20px;
            background-color: var(--light);
            border-left: 4px solid var(--danger, #dc3545);
            margin: 20px 0;
            color: var(--text-color);
            font-style: italic;
        }
        
        /* Force header to stay fixed even when contentEditable is active */
        .header.fixed-top {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 9999 !important;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        .edit-link {
            color: var(--primary);
            text-decoration: none;
            margin-left: 15px;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            cursor: pointer;
            vertical-align: middle;
        }
        .edit-link:hover {
            text-decoration: underline;
        }
        .editable-header:hover .edit-link {
            opacity: 1;
        }
        
        /* Beta Editor Styles */
        .tune-pills-container {
            min-height: 200px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
            background: var(--bg-color, white);
            line-height: 1.8;
            font-size: 16px;
            cursor: text;
            position: relative;
            transition: border-color 0.2s ease;
        }
        
        .tune-pills-container:hover {
            border-color: var(--primary);
        }
        
        .tune-pills-container:focus-within {
            border-color: var(--primary);
            outline: none;
        }
        
        .tune-set {
            margin-bottom: 2px;
            min-height: 18px;
        }
        
        .tune-set:last-child {
            margin-bottom: 0;
        }
        
        .tune-pill {
            display: inline-block;
            margin: 2px;
            padding: 0px 9px;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            user-select: none;
            vertical-align: middle;
            line-height: 21px;
        }
        
        .tune-pill.unlinked {
            background-color: var(--secondary, #6c757d);
            color: white;
            border: 1px solid var(--secondary, #6c757d);
        }
        
        .tune-pill.unmatched {
            background-color: var(--danger, #dc3545);
            color: white;
            border: 1px solid var(--danger, #dc3545);
        }
        
        .tune-pill.loading {
            background-color: #e9ecef;
            color: #6c757d;
            border: 1px solid #e9ecef;
        }
        
        .tune-pill.linked {
            background-color: var(--primary, #007bff);
            color: white;
            border: 1px solid var(--primary, #007bff);
        }
        
        .tune-pill.error {
            background-color: var(--warning, #ffc107);
            color: var(--dark, #212529);
            border: 1px solid var(--warning, #ffc107);
        }
        
        .tune-pill.selected {
            box-shadow: 0 0 0 2px var(--primary);
            background-color: rgba(0, 122, 255, 0.1);
        }
        
        .tune-pill.dragging {
            opacity: 0.5;
            box-shadow: 0 0 0 2px #007AFF;
            position: relative;
            z-index: 1000;
        }
        
        /* Drop indicators - color only, no size changes */
        .tune-pill.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.1) !important;
            position: relative;
        }
        
        /* Show drop position indicator on right side of pill */
        .tune-pill.mobile-drop-target.drop-after::after {
            content: '';
            position: absolute;
            right: -2px;
            top: 2px;
            bottom: 2px;
            width: 3px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 10;
        }
        
        /* Show drop position indicator on left side of pill */
        .tune-pill.mobile-drop-target.drop-before::before {
            content: '';
            position: absolute;
            left: -2px;
            top: 2px;
            bottom: 2px;
            width: 3px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 10;
        }
        
        .horizontal-drop-zone.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.3) !important;
        }
        
        .tune-set.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.05) !important;
        }
        
        /* Tune-set with blank space drop gets brighter highlighting */
        .tune-set.mobile-drop-target.drop-at-end {
            background-color: rgba(0, 122, 255, 0.3) !important;
            position: relative;
        }
        
        /* Position indicator for blank space drops in tune-sets - vertical bar at end of row */
        .tune-set.mobile-drop-target.drop-at-end::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 30px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 1000;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 4px rgba(0, 122, 255, 0.5);
        }
        
        /* Tune-set with gap drop gets brighter highlighting */
        .tune-set.mobile-drop-target.drop-in-gap {
            background-color: rgba(0, 122, 255, 0.3) !important;
            position: relative;
        }
        
        /* Position indicator for gap drops - vertical bar between pills */
        .tune-set.mobile-drop-target.drop-in-gap::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 30px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 1000;
            left: var(--gap-indicator-left, 12px);
            top: var(--gap-indicator-top, 8px);
            box-shadow: 0 0 4px rgba(0, 122, 255, 0.5);
        }
        
        #tune-pills-container.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.3) !important;
            position: relative;
        }
        
        /* Position indicator for blank space drops - vertical bar at insertion point */
        #tune-pills-container.mobile-drop-target.drop-at-end::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 60px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 1000;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 4px rgba(0, 122, 255, 0.5);
        }
        
        /* Ensure dark mode doesn't override */
        [data-theme="dark"] #tune-pills-container.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.3) !important;
        }
        
        .tune-pill.just-landed {
            background-color: #ffc107 !important;
            border-color: #ffc107 !important;
            box-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
            animation: landingGlow 3s ease-out forwards;
        }
        
        /* Loading spinner for pills waiting for API response */
        .tune-pill .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(108, 117, 125, 0.3);
            border-top: 2px solid #6c757d;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes landingGlow {
            0% {
                background-color: #ffc107 !important;
                border-color: #ffc107 !important;
                box-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
            }
            100% {
                background-color: var(--primary, #007bff) !important;
                border-color: var(--primary, #007bff) !important;
                box-shadow: none;
            }
        }
        
        .tune-pill .chevron {
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            border-left: 5px solid currentColor;
            opacity: 0.7;
            transition: transform 0.2s ease;
        }
        
        .tune-pill .chevron.open {
            transform: translateY(-50%) rotate(90deg);
        }
        
        .tune-pill .text {
            margin-left: 10px;
        }
        
        .drop-indicator {
            display: inline-block;
            width: 3px;
            height: 20px;
            background-color: var(--primary);
            border-radius: 2px;
            margin: 0 2px;
            vertical-align: middle;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .drop-indicator.active {
            opacity: 1;
        }
        
        .horizontal-drop-zone {
            height: 12px;
            width: 100%;
            margin: 0px 0;
            position: relative;
            cursor: text;
            /* Removed transition to prevent flickering */
        }
        
        .horizontal-drop-zone:hover {
            background-color: rgba(0, 123, 255, 0.08);
        }
        
        .horizontal-drop-zone.drag-over {
            background-color: rgba(0, 123, 255, 0.15);
        }
        
        .horizontal-drop-zone.drag-over::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 2px;
            background-color: var(--primary);
            border-radius: 1px;
            transform: translateY(-50%);
        }
        
        .text-cursor {
            display: inline-block;
            width: 2px;
            height: 21px;
            background-color: var(--primary, #007bff);
            animation: blink 1s infinite;
            vertical-align: middle;
            margin: 0 1px;
            position: relative;
            top: -5px;
            z-index: 10;
            border-radius: 1px;
            box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .cursor-position {
            display: inline-block;
            width: 0;
            height: 21px;
            position: relative;
            vertical-align: middle;
            background-color: transparent;
            cursor: text;
            padding: 0 3px; /* Create hover area without affecting layout */
            margin: 0;
            overflow: visible; /* Allow content to extend beyond boundaries */
        }
        
        .cursor-position:hover::before {
            content: '';
            position: absolute;
            left: 3px;
            top: -5px;
            width: 2px;
            height: 21px;
            background-color: rgba(0, 123, 255, 0.4);
            border-radius: 1px;
        }
        
        .text-input {
            display: inline-block;
            min-width: 200px;
            border: 2px solid var(--primary);
            outline: none;
            background: var(--bg-color, white);
            font-family: inherit;
            font-size: inherit;
            color: var(--text-color);
            vertical-align: middle;
            margin: 2px;
            padding: 4px 8px;
            border-radius: 4px;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        
        .tune-context-menu {
            position: absolute;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1500;
            font-size: 14px;
            color: var(--text-color);
            white-space: nowrap;
            display: none;
            min-width: 120px;
            pointer-events: auto;
            touch-action: manipulation;
        }
        
        .tune-context-menu a {
            display: block;
            padding: 8px 12px;
            text-decoration: none;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
        }
        
        .tune-context-menu a:hover {
            background-color: var(--hover-bg);
            color: var(--primary);
        }
        
        .tune-context-menu .menu-section {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 4px;
            padding-bottom: 4px;
        }
        
        .tune-context-menu .menu-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Dark mode adjustments */
        [data-theme="dark"] .tune-pills-container {
            background: var(--bg-color);
            border-color: var(--border-color);
        }
        
        [data-theme="dark"] .tune-context-menu {
            background: var(--dropdown-bg);
            border-color: var(--border-color);
            color: var(--text-color);
        }
        
        [data-theme="dark"] .tune-context-menu a {
            color: var(--text-color);
        }
        
        [data-theme="dark"] .tune-context-menu a:hover {
            background-color: var(--hover-bg);
            color: var(--primary);
        }
        
        /* Modals for linking and editing tunes */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--bg-color, white);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            color: var(--text-color);
        }
        
        .modal-header {
            margin-bottom: 16px;
        }
        
        .modal-header h3 {
            margin: 0;
            color: var(--text-color);
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .modal-body label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color);
        }
        
        .modal-body input, .modal-body textarea, .modal-body select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        .modal-footer {
            text-align: right;
        }
        
        .modal-footer button {
            margin-left: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .modal-footer .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        
        .modal-footer .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }
        
        .modal-footer button:hover {
            opacity: 0.9;
        }
        
        /* Save button disabled state */
        #save-session-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: var(--disabled-bg, #ccc) !important;
        }
        
        #save-session-btn:not(:disabled):hover {
            opacity: 0.9;
        }
        
        /* Auto-save countdown styling */
        #auto-save-countdown {
            color: #c3e6cb; /* Light green, subtle in light mode */
        }
        
        [data-theme="dark"] #auto-save-countdown {
            color: #3d4f42; /* Dark grey-green, subtle in dark mode */
        }
        
        /* Cancel link inherits color from parent countdown text */
        #cancel-auto-save {
            color: inherit;
            font-style: inherit;
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .save-controls-container {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 10px !important;
            }
            
            #save-session-btn .desktop-text {
                display: none;
            }
            #save-session-btn .mobile-text {
                display: inline;
            }
            
            
            .inactivity-text {
                display: none;
            }
            
            .countdown-desktop {
                display: none;
            }
            .countdown-mobile {
                display: inline;
            }
            
            .cancel-desktop {
                display: none;
            }
            .cancel-mobile {
                display: inline;
            }
            
            #auto-save-countdown {
                margin-left: 0 !important;
                margin-top: 5px;
                width: 100%;
            }
            
            /* Only force block display when countdown should be visible */
            #auto-save-countdown[style*="display: inline"] {
                display: block !important;
            }
        }
        
        /* Desktop default - hide mobile elements */
        @media (min-width: 769px) {
            #save-session-btn .mobile-text {
                display: none;
            }
            #save-session-btn .desktop-text {
                display: inline;
            }
            
            .auto-save-interval-mobile {
                display: none;
            }
            .auto-save-interval-desktop {
                display: block;
            }
            
            .countdown-mobile {
                display: none;
            }
            .countdown-desktop {
                display: inline;
            }
            
            .cancel-mobile {
                display: none;
            }
            .cancel-desktop {
                display: inline;
            }
        }
    </style>
{% endblock %}

{% block content %}
<div class="landing-page" style="display: block;">

    <h1>{{ session_instance.session_name }}</h1>
    <h2 class="editable-header{% if session_instance.is_cancelled %} cancelled-date{% endif %}">{{ session_instance.date }}<span class="edit-link" id="edit-date-btn">Edit</span></h2>
    
    {% if session_instance.location_override %}
    <p style="margin: 10px 0; color: var(--disabled-text); font-style: italic;">
        <strong>Note</strong> - actual location of this session: {{ session_instance.location_override }}
    </p>
    {% endif %}
    
    <div id="message-container">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
                <div class="message success">
                    {% for message in messages %}
                        <p>{{ message }}</p>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}
    </div>
    
    <!-- Beta Mode Indicator -->
    <div style="background-color: var(--warning-bg, #fff3cd); border: 1px solid var(--warning, #ffc107); border-radius: 4px; padding: 12px; margin: 20px 0; color: var(--text-color);">
        <strong>🧪 Beta Editor Mode</strong> - This is the experimental tune pill editor. <a href="/sessions/{{ session_instance.session_path }}/{{ session_instance.date }}">Switch to normal view</a>
    </div>
    
    <!-- Link Tune Modal -->
    <div id="link-tune-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Link Tune</h3>
            </div>
            <div class="modal-body">
                <p>Enter a URL or tune ID from thesession.org to link for this name:</p>
                <label for="tune-link-input">Tune ID or URL:</label>
                <input type="text" id="tune-link-input" placeholder="e.g. 1234 or https://thesession.org/tunes/1234">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="link-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="link-confirm-btn">Link</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Tune Modal -->
    <div id="edit-tune-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Tune</h3>
            </div>
            <div class="modal-body">
                <label for="edit-tune-name-input">Tune Name:</label>
                <input type="text" id="edit-tune-name-input" placeholder="Enter tune name">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="edit-tune-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="edit-tune-save-btn">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Session Instance Modal -->
    <div id="edit-session-instance-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Session Instance</h3>
            </div>
            <div class="modal-body">
                <label for="edit-session-date-input">Session Date:</label>
                <input type="date" id="edit-session-date-input" required>
                
                <label for="edit-session-location-input" style="margin-top: 16px;">Location:</label>
                <input type="text" id="edit-session-location-input" placeholder="The usual: {{ session_instance.session_name }}">
                
                <label for="edit-session-comments-input" style="margin-top: 16px;">Comments:</label>
                <textarea id="edit-session-comments-input" placeholder="Notes about this session" rows="3" style="resize: vertical;"></textarea>
                
                <div style="margin-top: 16px;">
                    <label style="display: flex; align-items: center; font-weight: normal;">
                        <input type="checkbox" id="edit-session-cancelled-input" style="margin-right: 8px; width: auto;">
                        Cancelled?
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="edit-session-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="edit-session-save-btn">Save</button>
            </div>
        </div>
    </div>
    
    {% if session_instance.comments %}
    <div class="session-instance-comments">
        <h3>Notes from this session:</h3>
        <p>{{ session_instance.comments }}</p>
    </div>
    {% endif %}
    
    {% if session_instance.is_cancelled %}
    <div class="cancelled-message">
        <strong>This session instance was cancelled.</strong>
    </div>
    {% else %}
    <div id="tunes-container">
        <h3>Tunes Played:</h3>
        <div id="tune-pills-container" class="tune-pills-container" tabindex="0" role="textbox" aria-label="Tune editor">
            <!-- Tune pills will be rendered here -->
        </div>
    </div>
    
    <!-- Save Controls -->
    <div class="save-controls-container" style="display: flex; align-items: center; gap: 15px; margin: 20px 0; padding: 15px; background-color: var(--light); border-radius: 4px;">
        <button id="save-session-btn" class="btn-primary" style="padding: 10px 20px; background-color: var(--primary); color: white; border: none; border-radius: 4px; cursor: pointer; transition: opacity 0.2s ease, background-color 0.2s ease;" disabled>
            <span class="desktop-text">Save Session</span>
            <span class="mobile-text">Save</span>
        </button>
        <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="auto-save-checkbox" style="cursor: pointer;">
            <label for="auto-save-checkbox" style="margin: 0; cursor: pointer;">Auto-save after</label>
            <select id="auto-save-interval" style="padding: 5px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--bg-color); color: var(--text-color);">
                <option value="10">10 seconds</option>
                <option value="30">30 seconds</option>
                <option value="60" selected>60 seconds</option>
            </select>
            <span style="margin: 0;" class="inactivity-text">of inactivity</span>
        </div>
        <span id="auto-save-countdown" style="font-style: italic; display: none; margin-left: 8px;">
            <span class="countdown-desktop">Saving in <span id="countdown-seconds" style="display: inline-block; width: 2ch; text-align: right;">60</span> seconds... </span>
            <span class="countdown-mobile">Saving in <span id="countdown-seconds-mobile" style="display: inline-block; width: 2ch; text-align: right;">60</span> seconds... </span>
            <a href="#" id="cancel-auto-save" style="text-decoration: underline; cursor: pointer;">
                <span class="cancel-desktop">Cancel</span>
                <span class="cancel-mobile">cancel</span>
            </a>
        </span>
        <span id="save-status" style="color: var(--success, #28a745); font-style: italic; display: none;"></span>
    </div>
    {% endif %}
    
    {% if session_instance.log_complete_date and is_session_admin %}
    <div style="margin-top: 20px;">
        <p style="color: var(--disabled-text); font-style: italic;">
            This session was marked complete on {{ session_instance.log_complete_date.strftime('%Y-%m-%d') if session_instance.log_complete_date else '' }}.
        </p>
        <a href="#" id="mark-incomplete-link" style="color: var(--warning, #ffc107); text-decoration: none; font-size: 14px;">Mark this session as not complete</a>
    </div>
    {% elif not session_instance.log_complete_date and is_session_admin %}
    <div style="margin-top: 20px;">
        <a href="#" id="mark-complete-link" style="color: var(--primary); text-decoration: none; font-size: 14px;">Mark this session log complete</a>
    </div>
    {% elif session_instance.log_complete_date and not is_session_admin %}
    <div style="margin-top: 20px;">
        <p style="color: var(--disabled-text); font-style: italic;">
            This session was marked complete on {{ session_instance.log_complete_date.strftime('%Y-%m-%d') if session_instance.log_complete_date else '' }}.
        </p>
    </div>
    {% endif %}
    
    <p><a href="/sessions/{{ session_instance.session_path }}">← Back to this session</a></p>
</div>
{% endblock %}

{% block extra_js %}
<script src="/static/js/components/autoSave.js"></script>
<script src="/static/js/components/stateManager.js"></script>
<script src="/static/js/components/cursorManager.js"></script>
<script src="/static/js/components/pillRenderer.js"></script>
<script src="/static/js/components/pillSelection.js"></script>
<script>
    const sessionPath = '{{ session_instance.session_path }}';
    const sessionDate = '{{ session_instance.date }}';
    const isCancelled = {{ 'true' if session_instance.is_cancelled else 'false' }};
    const isSessionAdmin = {{ 'true' if is_session_admin else 'false' }};
    const isLogComplete = {{ 'true' if session_instance.log_complete_date else 'false' }};
    
    // Session instance data for editing
    const sessionInstanceData = {
        date: '{{ session_instance.date }}',
        location_override: {{ session_instance.location_override|tojson if session_instance.location_override else 'null' }},
        default_location: {{ session_instance.default_location|tojson if session_instance.default_location else 'null' }},
        comments: {{ session_instance.comments|tojson if session_instance.comments else 'null' }},
        is_cancelled: {{ 'true' if session_instance.is_cancelled else 'false' }}
    };
    
    // Beta Editor State - core data now managed by StateManager
    // selectedPills now fully managed by PillSelection module
    let dragState = null;
    // cursorPosition now managed by CursorManager - keep reference for backward compatibility
    let cursorPosition = null;
    
    // Core data array - will be replaced by StateManager calls
    let tunePillsData = [];
    
    // Save state tracking - now managed by AutoSaveManager
    
    // State change tracking now handled directly by AutoSaveManager
    
    // Handle responsive option text - now handled directly by AutoSaveManager
    let isTyping = false;
    let typingBuffer = '';
    let isKeepingKeyboardOpen = false;
    let typingTimeout = null;  // For 3-second pause matching
    let typingPill = null;      // Temporary pill being typed
    
    // Global mobile drag ghost management
    let globalDragGhost = null;
    
    // Function to clean up any existing drag ghosts
    function cleanupDragGhosts() {
        // Remove the global ghost if it exists
        if (globalDragGhost) {
            globalDragGhost.remove();
            globalDragGhost = null;
        }
        // Also remove any orphaned ghosts by class name
        document.querySelectorAll('.mobile-drag-ghost').forEach(ghost => ghost.remove());
    }
    

    // Save functionality - now handled directly by AutoSaveManager
    
    // AutoSave functions now handled directly by AutoSaveManager module
    
    // Initialize the editor on page load
    document.addEventListener('DOMContentLoaded', function() {
        if (!isCancelled) {
            // Initialize StateManager with change callback
            StateManager.initialize(() => {
                tunePillsData = StateManager.getTunePillsData();
                AutoSaveManager.forceCheckChanges();
            });
            
            // Initialize CursorManager 
            CursorManager.initialize({
                getStateManager: () => StateManager,
                onCursorChange: (newPosition) => {
                    // Update global reference for backward compatibility
                    cursorPosition = newPosition;
                },
                onSelectionChange: () => {
                    PillSelection.updateSelectionDisplay();
                }
            });
            
            // Register callbacks that CursorManager needs
            CursorManager.registerCallbacks({
                finishTyping: (keepKeyboard) => finishTyping(keepKeyboard),
                removeTemporaryEmptySet: () => removeTemporaryEmptySet(),
                renderTunePills: () => renderTunePills(),
                handleTextInput: (char) => handleTextInput(char),
                handleBackspace: () => handleBackspace()
            });
            
            // Set typing-related variables that CursorManager needs access to
            CursorManager.typingBuffer = () => typingBuffer;
            CursorManager.isKeepingKeyboardOpen = () => isKeepingKeyboardOpen;
            
            // Initialize PillRenderer
            PillRenderer.initialize({
                getStateManager: () => StateManager,
                getCursorManager: () => CursorManager,
                getAutoSaveManager: () => AutoSaveManager
            });
            
            // Register callbacks that PillRenderer needs
            PillRenderer.registerCallbacks({
                cleanupDragGhosts: () => cleanupDragGhosts(),
                createHorizontalDropZone: (setIndex) => createHorizontalDropZone(setIndex),
                setupPillEventListeners: (pillElement, pillData) => setupPillEventListeners(pillElement, pillData),
                setCursorPosition: (setIndex, pillIndex, positionType, maintainKeyboard) => setCursorPosition(setIndex, pillIndex, positionType, maintainKeyboard),
                clearSelection: () => CursorManager.clearSelection()
            });
            
            // Initialize PillSelection
            PillSelection.initialize({
                getStateManager: () => StateManager,
                getAutoSaveManager: () => AutoSaveManager,
                onSelectionChange: () => {
                    PillSelection.updateSelectionDisplay();
                }
            });
            
            // Register callbacks that PillSelection needs
            PillSelection.registerCallbacks({
                renderTunePills: () => renderTunePills(),
                saveToUndo: () => saveToUndo(),
                showMessage: (message, type) => showMessage(message, type)
            });
            
            // Convert server-side tune sets data to pills format
            const initialTuneSets = {{ tune_sets|tojson }};
            convertTuneSetsToPills(initialTuneSets, true); // Skip callback during initialization
            renderTunePills();
            setupEventListeners();
            
            // Initialize AutoSaveManager after tunePillsData is created
            AutoSaveManager.initialize(sessionPath, sessionDate, () => StateManager.getTunePillsData(), {
                isUserLoggedIn: {{ 'true' if current_user.is_authenticated else 'false' }},
                userAutoSave: {{ 'true' if current_user.auto_save_tunes else 'false' }}
            });
            
            // Initialize save state - mark as clean since we just loaded
            const currentData = StateManager.getTunePillsData();
            AutoSaveManager.lastSavedData = JSON.parse(JSON.stringify(currentData));
            AutoSaveManager.lastCheckedData = JSON.parse(JSON.stringify(currentData));
            AutoSaveManager.isDirty = false;
            
            // Ensure save button is disabled on initial load
            const saveBtn = document.getElementById('save-session-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
            }
        }
        
        setupSessionEditListeners();
        setupSaveListeners();
        
        // Initialize auto-save preference
        AutoSaveManager.initializeAutoSavePreference();
        
        // Set up responsive option text
        AutoSaveManager.updateOptionText();
        window.addEventListener('resize', AutoSaveManager.updateOptionText);
    });
    
    // Convert tune sets to pills data format - delegated to StateManager
    function convertTuneSetsToPills(tuneSets, skipCallback = false) {
        StateManager.convertTuneSetsToPills(tuneSets, skipCallback);
        tunePillsData = StateManager.getTunePillsData();
    }
    
    // Generate unique IDs for pills - delegated to StateManager
    function generateId() {
        return StateManager.generateId();
    }
    
    // Render tune pills in the container
    // Pill rendering functionality - delegated to PillRenderer module
    function renderTunePills() {
        return PillRenderer.renderTunePills();
    }
    
    // Create a pill element - delegated to PillRenderer module
    function createPillElement(pill, setIndex, pillIndex) {
        return PillRenderer.createPillElement(pill, setIndex, pillIndex);
    }
    
    // Add cursor position markers
    // Cursor management functions - delegated to CursorManager
    function addCursorPosition(parent, setIndex, pillIndex, positionType) {
        return CursorManager.addCursorPosition(parent, setIndex, pillIndex, positionType);
    }
    
    function addFinalCursor(containerElement) {
        return CursorManager.addFinalCursor(containerElement);
    }
    
    function isMobileDevice() {
        return CursorManager.isMobileDevice();
    }

    
    // Create CursorManager wrapper 
    function setCursorPosition(setIndex, pillIndex, positionType, maintainKeyboard = false) {
        return CursorManager.setCursorPosition(setIndex, pillIndex, positionType, maintainKeyboard);
    }
    
    // Create drop indicator
    function createDropIndicator() {
        const indicator = document.createElement('div');
        indicator.className = 'drop-indicator';
        return indicator;
    }
    
    // Create horizontal drop zone between sets
    function createHorizontalDropZone(insertAtSetIndex) {
        const dropZone = document.createElement('div');
        dropZone.className = 'horizontal-drop-zone';
        dropZone.dataset.insertAtSetIndex = insertAtSetIndex;
        
        // Click handler - position cursor for typing new set
        dropZone.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Clear selection and selection anchor when clicking to move cursor
            CursorManager.clearSelection();
            
            setCursorPosition(insertAtSetIndex, 0, 'newset');
        });
        
        // Drag and drop handlers
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation(); // IMPORTANT: Stop the event from bubbling to the container
            dropZone.classList.remove('drag-over');
            
            
            if (dragState) {
                // Internal drag and drop - use drag data to preserve set structure
                try {
                    const dragData = JSON.parse(e.dataTransfer.getData('text/json'));
                    if (dragData && Array.isArray(dragData)) {
                        // Use the existing performDrop logic but with the structured data
                        dropStructuredSetsAtNewPosition(dragData, insertAtSetIndex);
                    } else {
                        // Fallback to old method if drag data is invalid
                        const draggedIds = Array.from(PillSelection.getSelectedPills());
                        const position = { setIndex: insertAtSetIndex, pillIndex: 0, position: 'newset' };
                        performDrop(position, draggedIds);
                    }
                } catch (err) {
                    // Fallback to old method if drag data parsing fails
                    const draggedIds = Array.from(PillSelection.getSelectedPills());
                    const position = { setIndex: insertAtSetIndex, pillIndex: 0, position: 'newset' };
                    performDrop(position, draggedIds);
                }
            } else {
                // External drag or paste
                try {
                    const dragData = JSON.parse(e.dataTransfer.getData('text/json'));
                    if (dragData && Array.isArray(dragData)) {
                        const position = { setIndex: insertAtSetIndex, pillIndex: 0, position: 'newset' };
                        pasteAtPosition(dragData, position);
                    }
                } catch (err) {
                }
            }
        });
        
        return dropZone;
    }
    
    // Find drop position based on mouse coordinates
    function findDropPosition(x, y) {
        const containerElement = document.getElementById('tune-pills-container');
        
        // First check for horizontal drop zones
        const horizontalZones = containerElement.querySelectorAll('.horizontal-drop-zone');
        for (let i = 0; i < horizontalZones.length; i++) {
            const zoneElement = horizontalZones[i];
            const zoneRect = zoneElement.getBoundingClientRect();
            
            if (y >= zoneRect.top && y <= zoneRect.bottom) {
                const insertAtSetIndex = parseInt(zoneElement.dataset.insertAtSetIndex);
                return { setIndex: insertAtSetIndex, pillIndex: 0, position: 'newset' };
            }
        }
        
        // Then check tune sets
        const sets = containerElement.querySelectorAll('.tune-set');
        
        for (let setIndex = 0; setIndex < sets.length; setIndex++) {
            const setElement = sets[setIndex];
            const setRect = setElement.getBoundingClientRect();
            
            if (y >= setRect.top && y <= setRect.bottom) {
                const pills = setElement.querySelectorAll('.tune-pill');
                
                for (let pillIndex = 0; pillIndex < pills.length; pillIndex++) {
                    const pillRect = pills[pillIndex].getBoundingClientRect();
                    
                    if (x < pillRect.left + pillRect.width / 2) {
                        return { setIndex, pillIndex, position: 'before' };
                    }
                }
                
                // After last pill in this set
                return { setIndex, pillIndex: pills.length, position: 'after' };
            }
        }
        
        // After last set
        return { setIndex: sets.length, pillIndex: 0, position: 'newset' };
    }
    
    // Setup event listeners for pills
    function setupPillEventListeners(pillElement, pillData) {
        // Click to select or show context menu
        pillElement.addEventListener('click', (e) => {
            // Calculate if click is on the left side (chevron area)
            const rect = pillElement.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const textElement = pillElement.querySelector('.text');
            const textStart = textElement ? textElement.offsetLeft : 20; // Fallback to 20px if no text found
            
            // If click is to the left of the text, treat it as chevron click
            if (clickX < textStart) {
                // Check if menu is already open for this pill
                const existingMenu = document.querySelector(`.tune-context-menu[data-pill-id="${pillData.id}"]`);
                if (existingMenu) {
                    // Menu is open, close it
                    hideContextMenu(pillData.id);
                } else {
                    // Menu is closed, open it
                    showContextMenu(e, pillData);
                }
            } else {
                // Click on text area - handle selection
                
                // If user is typing, finish typing first
                if (isTyping) {
                    finishTyping();
                }
                
                if (e.shiftKey) {
                    // Range selection
                    PillSelection.extendSelection(pillData.id);
                } else if (e.ctrlKey || e.metaKey) {
                    // Toggle selection
                    PillSelection.toggleSelection(pillData.id);
                } else {
                    // Normal click - select this pill (clearing any existing selection)
                    PillSelection.selectSingle(pillData.id);
                    
                    // If we had a selection anchor from shift+arrow, clear it
                    if (CursorManager.selectionAnchor !== null) {
                        CursorManager.selectionAnchor = null;
                    }
                }
            }
            e.preventDefault();
            e.stopPropagation();
        });
        
        // Mobile touch handling
        let longPressTimer;
        let touchStartTime;
        let hasTouchMoved = false;
        let touchStartPos = null;
        let isDragMode = false;
        
        pillElement.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            hasTouchMoved = false;
            isDragMode = false;
            touchStartPos = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
            
            // Check if touch is on the chevron area (left part of pill)
            const rect = pillElement.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const textElement = pillElement.querySelector('.text');
            const textStart = textElement ? textElement.offsetLeft : 20; // Fallback to 20px if no text found
            const isChevronArea = touchX < textStart;
            
            // Store whether this touch started on chevron
            pillElement.dataset.touchOnChevron = isChevronArea;
            
            if (!isChevronArea) {
                // Only set up long press for drag if not on chevron
                longPressTimer = setTimeout(() => {
                    // Enter drag mode
                    isDragMode = true;
                    pillElement.classList.add('dragging');
                    
                    // If pill isn't selected, select it
                    if (!PillSelection.isSelected(pillData.id)) {
                        PillSelection.selectSingle(pillData.id);
                    }
                    
                    // Visual feedback for all selected pills
                    PillSelection.getSelectedPills().forEach(pillId => {
                        const pill = document.querySelector(`[data-pill-id="${pillId}"]`);
                        if (pill && pill !== pillElement) {
                            pill.classList.add('dragging');
                        }
                    });
                    
                    // Add haptic feedback if available
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                    
                }, 1000);
            }
            
            e.stopPropagation();
        });
        
        // Track last drop zone and throttle updates
        let lastDropZone = null;
        let lastDropZoneUpdate = 0;
        const DROP_ZONE_UPDATE_THROTTLE = 50; // ms - reduced for more responsive feedback
        
        pillElement.addEventListener('touchmove', (e) => {
            hasTouchMoved = true;
            clearTimeout(longPressTimer);
            
            if (isDragMode) {
                // Prevent scrolling during drag
                e.preventDefault();
                
                const touch = e.touches[0];
                
                // Clean up any existing ghosts first
                cleanupDragGhosts();
                
                // Create new drag ghost
                if (!globalDragGhost) {
                    globalDragGhost = document.createElement('div');
                    globalDragGhost.className = 'mobile-drag-ghost';
                    globalDragGhost.style.cssText = `
                        position: fixed;
                        pointer-events: none;
                        z-index: 10000;
                        background: #007AFF;
                        color: white;
                        padding: 4px 8px;
                        border-radius: 6px;
                        font-size: 12px;
                        transform: rotate(2deg);
                        opacity: 0.8;
                    `;
                    globalDragGhost.textContent = PillSelection.getSelectionCount() > 1 ? `${PillSelection.getSelectionCount()} pills` : pillData.tuneName;
                    document.body.appendChild(globalDragGhost);
                }
                
                // Update ghost position smoothly
                globalDragGhost.style.left = (touch.clientX - 30) + 'px';
                globalDragGhost.style.top = (touch.clientY - 15) + 'px';
                
                // Check for drop zone under finger every 50ms to show color feedback
                const now = Date.now();
                if (now - lastDropZoneUpdate > DROP_ZONE_UPDATE_THROTTLE) {
                    lastDropZoneUpdate = now;
                    
                    // Get element below finger
                    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                    
                    // Find potential drop zone
                    let currentDropZone = null;
                    let dropSide = null; // 'left' or 'right' for pills
                    
                    if (elementBelow) {
                        // Check for horizontal drop zone first
                        currentDropZone = elementBelow.closest('.horizontal-drop-zone');
                        
                        // If not, check for pill (but not if it's being dragged)
                        if (!currentDropZone) {
                            const pill = elementBelow.closest('.tune-pill');
                            if (pill && !pill.classList.contains('dragging')) {
                                currentDropZone = pill;
                                
                                // Determine if we're over the right half (drop after) or left half (drop before)
                                const pillRect = pill.getBoundingClientRect();
                                const pillCenterX = pillRect.left + pillRect.width / 2;
                                dropSide = touch.clientX > pillCenterX ? 'right' : 'left';
                            }
                        }
                        
                        // If not over a pill or horizontal zone, check for gaps between pills
                        if (!currentDropZone) {
                            const tuneSet = elementBelow.closest('.tune-set');
                            if (tuneSet) {
                                const pills = Array.from(tuneSet.querySelectorAll('.tune-pill'));
                                
                                // Check if we're in a gap between two pills on the same row
                                for (let i = 0; i < pills.length - 1; i++) {
                                    const currentPill = pills[i];
                                    const nextPill = pills[i + 1];
                                    
                                    const currentRect = currentPill.getBoundingClientRect();
                                    const nextRect = nextPill.getBoundingClientRect();
                                    
                                    // Check if both pills are on roughly the same row (within 20px vertically)
                                    const verticalDiff = Math.abs(currentRect.top - nextRect.top);
                                    if (verticalDiff < 20) {
                                        // Check if touch point is horizontally between these two pills
                                        const gapStart = currentRect.right;
                                        const gapEnd = nextRect.left;
                                        const gapCenterY = (currentRect.top + currentRect.bottom) / 2;
                                        
                                        // Check if we're in the horizontal gap and vertically aligned
                                        if (touch.clientX >= gapStart && 
                                            touch.clientX <= gapEnd &&
                                            Math.abs(touch.clientY - gapCenterY) < 25) {
                                            
                                            // We're in the gap between these pills
                                            currentDropZone = tuneSet;
                                            currentDropZone.dataset.gapAfterPillIndex = i.toString();
                                            dropSide = 'gap';
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Finally, check for tune-set or any blank space
                        if (!currentDropZone) {
                            const tuneSet = elementBelow.closest('.tune-set');
                            if (tuneSet) {
                                // Check if we're in blank space to the right of pills in this set
                                const pills = tuneSet.querySelectorAll('.tune-pill');
                                const setRect = tuneSet.getBoundingClientRect();
                                
                                if (pills.length > 0) {
                                    // Find the rightmost pill on the same row as our touch point
                                    let rightmostPillOnRow = null;
                                    let smallestDistance = Infinity;
                                    
                                    for (const pill of pills) {
                                        const pillRect = pill.getBoundingClientRect();
                                        const verticalDistance = Math.abs(touch.clientY - (pillRect.top + pillRect.height / 2));
                                        
                                        // If this pill is roughly on the same row (within reasonable vertical distance)
                                        if (verticalDistance < 30) {
                                            if (pillRect.right < touch.clientX && verticalDistance < smallestDistance) {
                                                rightmostPillOnRow = pill;
                                                smallestDistance = verticalDistance;
                                            }
                                        }
                                    }
                                    
                                    // If we found a pill on the same row and we're to the right of it, this is blank space
                                    if (rightmostPillOnRow && touch.clientX > rightmostPillOnRow.getBoundingClientRect().right + 10) {
                                        currentDropZone = tuneSet;
                                        currentDropZone.dataset.virtualDropType = 'end-of-row';
                                        dropSide = 'end'; // Special indicator for blank space positioning
                                    } else {
                                        // Regular tune-set drop
                                        currentDropZone = tuneSet;
                                    }
                                } else {
                                    // Empty set
                                    currentDropZone = tuneSet;
                                }
                            } else {
                                // Check if we're in the main container area (bottom empty space)
                                const container = document.getElementById('tune-pills-container');
                                if (container) {
                                    const containerRect = container.getBoundingClientRect();
                                    
                                    // Check if touch point is within container bounds
                                    if (touch.clientX >= containerRect.left && 
                                        touch.clientX <= containerRect.right &&
                                        touch.clientY >= containerRect.top && 
                                        touch.clientY <= containerRect.bottom) {
                                        
                                        // We're in the bottom empty area - create new set
                                        currentDropZone = container;
                                        currentDropZone.dataset.virtualDropType = 'end-of-list';
                                        dropSide = 'end';
                                    }
                                }
                            }
                        }
                    }
                    
                    // Track if target or side changed
                    const dropKey = currentDropZone ? `${currentDropZone.id || currentDropZone.className}-${dropSide}` : null;
                    const lastDropKey = lastDropZone ? `${lastDropZone.id || lastDropZone.className}-${lastDropZone.dataset.dropSide}` : null;
                    
                    // Only update if target or side changed
                    if (dropKey !== lastDropKey) {
                        // Remove classes from previous target
                        if (lastDropZone) {
                            lastDropZone.classList.remove('mobile-drop-target', 'drop-before', 'drop-after', 'drop-at-end', 'drop-in-gap');
                            delete lastDropZone.dataset.dropSide;
                            delete lastDropZone.dataset.gapAfterPillIndex;
                            lastDropZone.style.removeProperty('--gap-indicator-left');
                            lastDropZone.style.removeProperty('--gap-indicator-top');
                        }
                        
                        // Add classes to new target
                        if (currentDropZone) {
                            currentDropZone.classList.add('mobile-drop-target');
                            
                            // Debug for container
                            if (currentDropZone.id === 'tune-pills-container') {
                            }
                            
                            // Add side indicator for pills
                            if (currentDropZone.classList.contains('tune-pill') && dropSide && dropSide !== 'end') {
                                currentDropZone.classList.add(dropSide === 'right' ? 'drop-after' : 'drop-before');
                                currentDropZone.dataset.dropSide = dropSide;
                            }
                            
                            // Add position indicator for blank space drops
                            if ((currentDropZone.id === 'tune-pills-container' || currentDropZone.classList.contains('tune-set')) && dropSide === 'end') {
                                currentDropZone.classList.add('drop-at-end');
                                currentDropZone.dataset.dropSide = dropSide;
                            }
                            
                            // Add position indicator for gap drops
                            if (currentDropZone.classList.contains('tune-set') && dropSide === 'gap') {
                                currentDropZone.classList.add('drop-in-gap');
                                currentDropZone.dataset.dropSide = dropSide;
                                
                                // Position the indicator between the pills
                                const gapAfterIndex = parseInt(currentDropZone.dataset.gapAfterPillIndex);
                                const pills = currentDropZone.querySelectorAll('.tune-pill');
                                
                                if (pills[gapAfterIndex] && pills[gapAfterIndex + 1]) {
                                    const currentPillRect = pills[gapAfterIndex].getBoundingClientRect();
                                    const nextPillRect = pills[gapAfterIndex + 1].getBoundingClientRect();
                                    const setRect = currentDropZone.getBoundingClientRect();
                                    
                                    // Calculate gap center position relative to the set
                                    const gapCenterX = (currentPillRect.right + nextPillRect.left) / 2;
                                    const gapCenterY = (currentPillRect.top + currentPillRect.bottom) / 2;
                                    
                                    const relativeLeft = gapCenterX - setRect.left;
                                    const relativeTop = gapCenterY - setRect.top;
                                    
                                    // Set the position via CSS custom properties
                                    currentDropZone.style.setProperty('--gap-indicator-left', `${relativeLeft - 2}px`);
                                    currentDropZone.style.setProperty('--gap-indicator-top', `${relativeTop - 15}px`);
                                }
                            }
                        }
                        
                        lastDropZone = currentDropZone;
                    }
                }
            }
        });
        
        pillElement.addEventListener('touchend', (e) => {
            clearTimeout(longPressTimer);
            
            if (isDragMode) {
                e.preventDefault();
                
                const touch = e.changedTouches[0];
                const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Clean up all drag ghosts
                cleanupDragGhosts();
                
                // Remove classes from the last drop zone
                if (lastDropZone) {
                    lastDropZone.classList.remove('mobile-drop-target', 'drop-before', 'drop-after', 'drop-at-end', 'drop-in-gap');
                    delete lastDropZone.dataset.dropSide;
                    delete lastDropZone.dataset.gapAfterPillIndex;
                    lastDropZone.style.removeProperty('--gap-indicator-left');
                    lastDropZone.style.removeProperty('--gap-indicator-top');
                }
                
                // Find drop target and perform drop
                // Use the lastDropZone if available (it has our gap data), otherwise detect from elementBelow
                let dropZone = lastDropZone;
                if (!dropZone && elementBelow) {
                    dropZone = elementBelow.closest('.horizontal-drop-zone, .tune-pill, .tune-set');
                }
                
                if (dropZone && !dropZone.classList.contains('dragging')) {
                    let dropPosition = null;
                    
                    // Determine drop position based on drop zone type
                    if (dropZone.classList.contains('horizontal-drop-zone')) {
                        // Dropping between sets - create a new set at this position
                        const setIndex = parseInt(dropZone.dataset.insertAtSetIndex);
                        dropPosition = { setIndex, pillIndex: 0, position: 'newset' };
                    } else if (dropZone.classList.contains('tune-pill')) {
                        // Dropping on a pill - detect which side based on touch position
                        const targetPillId = dropZone.dataset.pillId;
                        
                        // Determine side based on touch position
                        const pillRect = dropZone.getBoundingClientRect();
                        const pillCenterX = pillRect.left + pillRect.width / 2;
                        const dropAfter = touch.clientX > pillCenterX;
                        
                        // Find the pill's position
                        for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
                            const pillIndex = tunePillsData[setIndex].findIndex(p => p.id === targetPillId);
                            if (pillIndex !== -1) {
                                // Drop based on which side we're on
                                if (dropAfter) {
                                    // Right side - drop after this pill
                                    dropPosition = { setIndex, pillIndex, position: 'after' };
                                } else {
                                    // Left side - drop before this pill
                                    dropPosition = { setIndex, pillIndex, position: 'before' };
                                }
                                break;
                            }
                        }
                    } else if (dropZone.classList.contains('tune-set')) {
                        const setIndex = parseInt(dropZone.dataset.setIndex);
                        
                        // Check if this is a gap drop
                        if (dropZone.dataset.gapAfterPillIndex !== undefined) {
                            // Dropping in a gap between pills
                            const gapAfterIndex = parseInt(dropZone.dataset.gapAfterPillIndex);
                            dropPosition = { setIndex, pillIndex: gapAfterIndex, position: 'after' };
                        } else if (dropZone.dataset.virtualDropType === 'end-of-row') {
                            // Dropping in blank space at end of row
                            const setLength = tunePillsData[setIndex]?.length || 0;
                            dropPosition = { setIndex, pillIndex: setLength - 1, position: 'after' };
                        } else {
                            // Regular set drop - add to end
                            const setLength = tunePillsData[setIndex]?.length || 0;
                            dropPosition = { setIndex, pillIndex: setLength - 1, position: 'after' };
                        }
                    } else if (dropZone.id === 'tune-pills-container' || dropZone.dataset.virtualDropType === 'end-of-list') {
                        // Dropping on blank space - create new set at the end
                        dropPosition = { setIndex: tunePillsData.length, pillIndex: 0, position: 'newset' };
                    }
                    
                    if (dropPosition) {
                        // Call the existing drop handler with correct parameters
                        const draggedIds = Array.from(PillSelection.getSelectedPills());
                        performDrop(dropPosition, draggedIds);
                    }
                }
            } else {
                // Not in drag mode - handle as selection or context menu
                const touchDuration = Date.now() - touchStartTime;
                const wasChevronTouch = pillElement.dataset.touchOnChevron === 'true';
                
                
                // Only handle quick taps (less than 500ms to be more responsive)
                // Long touches should do nothing
                if (!hasTouchMoved && touchDuration < 500) {
                    if (wasChevronTouch) {
                        // Touch was on chevron - toggle context menu
                        const existingMenu = document.querySelector(`.tune-context-menu[data-pill-id="${pillData.id}"]`);
                        if (existingMenu) {
                            // Menu is open, close it
                            hideContextMenu(pillData.id);
                        } else {
                            // Menu is closed, open it
                            // Create a fake event with the touch coordinates
                            const touch = e.changedTouches[0];
                            const fakeEvent = {
                                clientX: touch.clientX,
                                clientY: touch.clientY,
                                target: pillElement,
                                preventDefault: () => {},
                                stopPropagation: () => {}
                            };
                            showContextMenu(fakeEvent, pillData);
                        }
                    } else {
                        // Touch was on main pill area - handle selection
                        // If user is typing, finish typing first
                        if (isTyping) {
                            finishTyping();
                        }
                        
                        // Toggle selection (works like shift-select by default)
                        PillSelection.toggleSelection(pillData.id);
                    }
                } else if (touchDuration >= 1000) {
                    // Long touch without drag - do nothing
                }
                
                e.preventDefault();
            }
            
            // Clean up the data attribute
            delete pillElement.dataset.touchOnChevron;
            
            // Reset drag styling
            PillSelection.getSelectedPills().forEach(pillId => {
                const pill = document.querySelector(`[data-pill-id="${pillId}"]`);
                if (pill) {
                    pill.classList.remove('dragging');
                }
            });
            
            // Reset drag state
            isDragMode = false;
            lastDropZone = null;
            e.stopPropagation();
        });
        
        // Handle touch cancel (e.g., incoming call, system gesture)
        pillElement.addEventListener('touchcancel', (e) => {
            clearTimeout(longPressTimer);
            
            // Clean up any drag ghosts
            cleanupDragGhosts();
            
            // Reset drag state
            if (isDragMode) {
                // Remove dragging class from all pills
                PillSelection.getSelectedPills().forEach(pillId => {
                    const pill = document.querySelector(`[data-pill-id="${pillId}"]`);
                    if (pill) {
                        pill.classList.remove('dragging');
                    }
                });
                
                // Remove classes from the last drop zone
                if (lastDropZone) {
                    lastDropZone.classList.remove('mobile-drop-target', 'drop-before', 'drop-after', 'drop-at-end', 'drop-in-gap');
                    delete lastDropZone.dataset.dropSide;
                    delete lastDropZone.dataset.gapAfterPillIndex;
                    lastDropZone.style.removeProperty('--gap-indicator-left');
                    lastDropZone.style.removeProperty('--gap-indicator-top');
                    lastDropZone = null;
                }
                
                isDragMode = false;
            }
        });
        
        // Right click for context menu (desktop only)
        // Mobile browsers trigger this on long press, so we need to prevent it
        pillElement.addEventListener('contextmenu', (e) => {
            // Always prevent default browser context menu
            e.preventDefault();
            
            // Check if this is from a touch event (mobile)
            // Multiple ways to detect since browser support varies
            const isTouch = (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) ||
                           e.pointerType === 'touch' ||
                           'ontouchstart' in window && navigator.maxTouchPoints > 0;
            
            if (isTouch) {
                // Don't show context menu on mobile - it's handled by touch events
                return;
            }
            
            // Show context menu only for desktop right-click
            showContextMenu(e, pillData);
        });
        
        // Drag and drop functionality
        pillElement.addEventListener('dragstart', (e) => {
            dragState = {
                draggedPillId: pillData.id,
                startX: e.clientX,
                startY: e.clientY
            };
            
            // If dragged pill is not selected, select only it
            if (!PillSelection.isSelected(pillData.id)) {
                PillSelection.selectSingle(pillData.id);
            }
            
            // Visual feedback - apply dragging class to all selected pills
            PillSelection.getSelectedPills().forEach(pillId => {
                const pill = document.querySelector(`[data-pill-id="${pillId}"]`);
                if (pill) {
                    pill.classList.add('dragging');
                }
            });
            
            // Set drag data (for clipboard compatibility) - preserve set structure
            const selectedBySet = new Map();
            
            tunePillsData.forEach((tuneSet, setIndex) => {
                tuneSet.forEach((pill, pillIndex) => {
                    if (PillSelection.isSelected(pill.id)) {
                        if (!selectedBySet.has(setIndex)) {
                            selectedBySet.set(setIndex, []);
                        }
                        selectedBySet.get(setIndex).push(JSON.parse(JSON.stringify(pill)));
                    }
                });
            });
            
            // Convert to array of sets, preserving set breaks
            const dragData = Array.from(selectedBySet.values()).filter(set => set && set.length > 0);
            
            e.dataTransfer.setData('text/json', JSON.stringify(dragData));
            e.dataTransfer.effectAllowed = 'move';
        });
        
        pillElement.addEventListener('dragend', (e) => {
            // Remove dragging class from all pills that might have it
            document.querySelectorAll('.tune-pill.dragging').forEach(pill => {
                pill.classList.remove('dragging');
            });
            clearDropIndicators();
            dragState = null;
        });
    }
    
    // Selection functions
    // Selection functions now directly call PillSelection methods
    
    // Drag and drop support functions
    function findPillById(pillId) {
        for (const set of tunePillsData) {
            for (const pill of set) {
                if (pill.id === pillId) {
                    return pill;
                }
            }
        }
        return null;
    }
    
    function clearDropIndicators() {
        document.querySelectorAll('.drop-indicator').forEach(indicator => {
            indicator.remove();
        });
    }
    
    function showDropIndicator(position) {
        clearDropIndicators();
        
        const containerElement = document.getElementById('tune-pills-container');
        const sets = containerElement.querySelectorAll('.tune-set');
        
        if (position.position === 'newset') {
            // Show indicator at end of container
            const indicator = createDropIndicator();
            indicator.classList.add('active');
            containerElement.appendChild(indicator);
        } else {
            const targetSet = sets[position.setIndex];
            const pills = targetSet.querySelectorAll('.tune-pill');
            
            if (position.position === 'before' && pills[position.pillIndex]) {
                const indicator = createDropIndicator();
                indicator.classList.add('active');
                targetSet.insertBefore(indicator, pills[position.pillIndex]);
            } else {
                // After last pill or specific position
                const indicator = createDropIndicator();
                indicator.classList.add('active');
                targetSet.appendChild(indicator);
            }
        }
    }
    
    // Specialized function for dropping structured sets at a new position (horizontal zones)
    function dropStructuredSetsAtNewPosition(dragData, targetSetIndex) {
        if (!dragData || dragData.length === 0) return;
        
        // Filter out any empty sets from drag data
        dragData = dragData.filter(set => set && set.length > 0);
        
        if (dragData.length === 0) {
            return;
        }
        
        saveToUndo();
        
        // Remove dragged pills from their current positions (same logic as performDrop)
        const draggedPillIds = Array.from(PillSelection.getSelectedPills());
        const setsToRemove = new Set();
        
        
        draggedPillIds.forEach(pillId => {
            for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
                const pillIndex = tunePillsData[setIndex].findIndex(p => p.id === pillId);
                if (pillIndex !== -1) {
                    tunePillsData[setIndex].splice(pillIndex, 1);
                    if (tunePillsData[setIndex].length === 0) {
                        setsToRemove.add(setIndex);
                    }
                    break;
                }
            }
        });
        
        // Clean up empty sets BEFORE calculating target position
        tunePillsData = tunePillsData.filter(set => set.length > 0);
        
        // Calculate adjusted target index AFTER cleanup
        let adjustedTargetIndex = targetSetIndex;
        for (let i = 0; i < targetSetIndex; i++) {
            if (setsToRemove.has(i)) {
                adjustedTargetIndex--;
            }
        }
        
        
        // Create new sets with new IDs
        const newSets = dragData.map(set => 
            set.map(pill => ({
                ...pill,
                id: generateId(),
                orderNumber: null
            }))
        );
        
        // Insert the new sets at the adjusted position
        if (adjustedTargetIndex >= tunePillsData.length) {
            tunePillsData.push(...newSets);
        } else {
            tunePillsData.splice(adjustedTargetIndex, 0, ...newSets);
        }
        
        // Update StateManager with the modified data
        StateManager.setTunePillsData(tunePillsData);
        
        renderTunePills();
        
        // Apply landing animation
        const movedPillIds = newSets.flat().map(pill => pill.id);
        setTimeout(() => {
            applyLandingAnimation(movedPillIds);
        }, 50);
    }
    
    function performDrop(position, draggedPillIds) {
        if (!draggedPillIds || draggedPillIds.length === 0) return;
        
        saveToUndo();
        
        // Track which sets will become empty after removal
        const originalSetCount = tunePillsData.length;
        const setsToRemove = new Set();
        
        // Remove dragged pills from their current positions
        const draggedPills = [];
        draggedPillIds.forEach(pillId => {
            for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
                const pillIndex = tunePillsData[setIndex].findIndex(p => p.id === pillId);
                if (pillIndex !== -1) {
                    draggedPills.push(tunePillsData[setIndex].splice(pillIndex, 1)[0]);
                    if (tunePillsData[setIndex].length === 0) {
                        setsToRemove.add(setIndex);
                    }
                    break;
                }
            }
        });
        
        // Calculate how many sets before target position will be removed
        let adjustedTargetIndex = position.setIndex;
        for (let i = 0; i < position.setIndex; i++) {
            if (setsToRemove.has(i)) {
                adjustedTargetIndex--;
            }
        }
        
        // Clean up empty sets
        tunePillsData = tunePillsData.filter(set => set.length > 0);
        
        // Insert at new position
        if (position.position === 'newset') {
            if (adjustedTargetIndex >= tunePillsData.length) {
                // Create new set at end
                tunePillsData.push(draggedPills);
            } else {
                // Create new set at specific index (insert between existing sets)
                tunePillsData.splice(adjustedTargetIndex, 0, draggedPills);
            }
        } else {
            // Use the adjusted target index for existing sets too
            if (adjustedTargetIndex >= tunePillsData.length) {
                // Create new set at end
                tunePillsData.push(draggedPills);
            } else {
                // Insert into existing set
                const targetSet = tunePillsData[adjustedTargetIndex];
                let insertIndex;
                
                if (position.position === 'after') {
                    insertIndex = Math.min(position.pillIndex + 1, targetSet.length);
                } else if (position.position === 'before') {
                    insertIndex = position.pillIndex; // Insert exactly at the pill index to go before it
                } else {
                    insertIndex = Math.min(position.pillIndex, targetSet.length);
                }
                
                // Insert all dragged pills at the position
                draggedPills.forEach((pill, index) => {
                    targetSet.splice(insertIndex + index, 0, pill);
                });
            }
        }
        
        // Update StateManager with the modified data
        StateManager.setTunePillsData(tunePillsData);
        
        renderTunePills();
        
        // Apply landing animation to moved pills
        const movedPillIds = draggedPills.map(pill => pill.id);
        setTimeout(() => {
            applyLandingAnimation(movedPillIds);
        }, 50); // Small delay to ensure pills are rendered
    }
    
    // Context menu functions
    function hideContextMenu(pillId) {
        // Remove all context menus and reset chevron states
        document.querySelectorAll('.tune-context-menu').forEach(menu => menu.remove());
        document.querySelectorAll('.chevron.open').forEach(chevron => chevron.classList.remove('open'));
    }
    
    function hideMatchResultsMenu(pillId) {
        // Remove match results menu for specific pill
        const menu = document.querySelector(`.match-results-menu[data-pill-id="${pillId}"]`);
        if (menu) {
            menu.remove();
        }
    }
    
    function showMatchResultsMenu(pill) {
        // Remove any existing match results menu for this pill
        hideMatchResultsMenu(pill.id);
        
        if (!pill.matchResults || pill.matchResults.length === 0) {
            return;
        }
        
        // Find the pill element
        const pillElement = document.querySelector(`[data-pill-id="${pill.id}"]`);
        if (!pillElement) {
            console.error(`Could not find pill element for ID: ${pill.id}`);
            return;
        }
        
        const menu = document.createElement('div');
        menu.className = 'tune-context-menu match-results-menu';
        menu.style.display = 'block';
        menu.dataset.pillId = pill.id;
        
        const rect = pillElement.getBoundingClientRect();
        
        // Position menu below the pill
        menu.style.position = 'fixed';
        menu.style.left = rect.left + 'px';
        menu.style.top = (rect.bottom + 5) + 'px';
        menu.style.width = 'auto';
        menu.style.minWidth = Math.max(200, rect.width) + 'px';
        menu.style.maxWidth = Math.min(600, window.innerWidth - rect.left - 20) + 'px';
        
        // Use a neutral background for the menu
        menu.style.backgroundColor = 'white';
        menu.style.color = '#212529';
        menu.style.border = '1px solid #dee2e6';
        menu.style.borderRadius = '4px';
        menu.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        
        // Add match results as menu items
        pill.matchResults.forEach(result => {
            const item = document.createElement('a');
            item.style.display = 'block';
            item.style.padding = '8px 12px';
            item.style.cursor = 'pointer';
            item.style.borderBottom = '1px solid #f0f0f0';
            item.style.color = '#212529';
            item.style.textDecoration = 'none';
            
            // Show tune name and type
            const nameSpan = document.createElement('span');
            nameSpan.textContent = result.tune_name;
            nameSpan.style.fontWeight = '500';
            item.appendChild(nameSpan);
            
            if (result.tune_type) {
                const typeSpan = document.createElement('span');
                typeSpan.textContent = ` (${result.tune_type})`;
                typeSpan.style.color = '#6c757d';
                typeSpan.style.fontSize = '0.9em';
                item.appendChild(typeSpan);
            }
            
            // Hover effect
            item.addEventListener('mouseenter', () => {
                item.style.backgroundColor = '#f8f9fa';
            });
            item.addEventListener('mouseleave', () => {
                item.style.backgroundColor = 'transparent';
            });
            
            // Click to select this match
            item.addEventListener('click', () => {
                // Apply the selected match
                pill.tuneId = result.tune_id;
                pill.tuneName = result.tune_name;
                pill.tuneType = result.tune_type;
                pill.state = 'linked';
                pill.matchResults = null;
                
                // Update the pill appearance
                updatePillAppearance(pill);
                
                // Force check for changes (includes timer reset and dirty state)
                AutoSaveManager.forceCheckChanges();
                
                // Hide the menu
                hideMatchResultsMenu(pill.id);
                
                // If we're still typing, maintain typing state
                if (isTyping) {
                    // Move cursor after this pill
                    const pillPosition = findPillPosition(pill.id);
                    if (pillPosition) {
                        setCursorPosition(pillPosition.setIndex, pillPosition.pillIndex, 'after');
                    }
                }
            });
            
            menu.appendChild(item);
        });
        
        // Remove last border
        if (menu.lastChild) {
            menu.lastChild.style.borderBottom = 'none';
        }
        
        document.body.appendChild(menu);
        
        // Don't auto-hide this menu when clicking elsewhere while typing
        // But do hide it when the pill state changes or user navigates away
    }
    
    function findPillPosition(pillId) {
        for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
            const set = tunePillsData[setIndex];
            const pillIndex = set.findIndex(p => p.id === pillId);
            if (pillIndex !== -1) {
                return { setIndex, pillIndex };
            }
        }
        return null;
    }
    
    function showContextMenu(event, pillData) {
        // Remove existing context menus and reset all chevrons
        hideContextMenu();
        
        const menu = document.createElement('div');
        menu.className = 'tune-context-menu';
        menu.style.display = 'block';
        menu.dataset.pillId = pillData.id; // Track which pill this menu belongs to
        
        // Find the pill element to match its dimensions and color
        const pillElement = event.target.closest('.tune-pill');
        const rect = pillElement.getBoundingClientRect();
        
        // Set chevron to open state
        const chevron = pillElement.querySelector('.chevron');
        chevron.classList.add('open');
        
        // Position menu
        menu.style.position = 'fixed';
        menu.style.left = rect.left + 'px';
        menu.style.top = (rect.bottom + 5) + 'px';
        
        // For unmatched pills with results, make menu wider to accommodate tune names
        if (pillData.state === 'unmatched' && pillData.matchResults && pillData.matchResults.length > 0) {
            menu.style.width = 'auto';
            menu.style.minWidth = Math.max(250, rect.width) + 'px';
            menu.style.maxWidth = Math.min(500, window.innerWidth - rect.left - 20) + 'px';
        } else {
            // Match pill width for other states
            menu.style.width = rect.width + 'px';
            menu.style.minWidth = 'unset';
        }
        
        // Match pill background color based on state
        const computedStyle = window.getComputedStyle(pillElement);
        menu.style.backgroundColor = computedStyle.backgroundColor;
        menu.style.color = computedStyle.color;
        menu.style.borderColor = computedStyle.borderColor;
        
        // Create menu items based on pill state
        if (pillData.state === 'linked') {
            // Linked tune options
            addMenuItem(menu, 'Dots', () => {
                const url = `https://thesession.org/tunes/${pillData.tuneId}${pillData.setting ? '#setting' + pillData.setting : ''}`;
                window.open(url, '_blank');
                hideContextMenu();
            });
            
            addMenuItem(menu, 'Relink', () => {
                showLinkModal(pillData);
                hideContextMenu();
            });
        } else if (pillData.state === 'unmatched' && pillData.matchResults && pillData.matchResults.length > 0) {
            // Show match results first if available
            pillData.matchResults.forEach(result => {
                const item = document.createElement('a');
                item.style.display = 'block';
                item.style.padding = '8px 12px';
                item.style.cursor = 'pointer';
                item.style.borderBottom = '1px solid rgba(255,255,255,0.2)';
                
                // Show tune name and type
                const nameSpan = document.createElement('span');
                nameSpan.textContent = result.tune_name;
                nameSpan.style.fontWeight = '500';
                item.appendChild(nameSpan);
                
                if (result.tune_type) {
                    const typeSpan = document.createElement('span');
                    typeSpan.textContent = ` (${result.tune_type})`;
                    typeSpan.style.opacity = '0.8';
                    typeSpan.style.fontSize = '0.9em';
                    item.appendChild(typeSpan);
                }
                
                // Click to select this match
                item.addEventListener('click', () => {
                    // Apply the selected match
                    pillData.tuneId = result.tune_id;
                    pillData.tuneName = result.tune_name;
                    pillData.tuneType = result.tune_type;
                    pillData.state = 'linked';
                    pillData.matchResults = null;
                    
                    // Update the pill appearance
                    updatePillAppearance(pillData);
                    
                    // Force check for changes (includes timer reset and dirty state)
                    AutoSaveManager.forceCheckChanges();
                    hideContextMenu();
                });
                
                menu.appendChild(item);
            });
            
            // Add separator
            const separator = document.createElement('div');
            separator.style.borderTop = '1px solid rgba(255,255,255,0.3)';
            separator.style.margin = '4px 0';
            menu.appendChild(separator);
            
            // Add manual link option
            addMenuItem(menu, 'Manual Link...', () => {
                showLinkModal(pillData);
                hideContextMenu();
            });
        } else {
            // Unlinked tune options
            addMenuItem(menu, 'Link', () => {
                showLinkModal(pillData);
                hideContextMenu();
            });
        }
        
        // Common options
        addMenuItem(menu, 'Edit Text', () => {
            showEditModal(pillData);
            hideContextMenu();
        });
        
        if (PillSelection.getSelectionCount() <= 1) {
            addMenuItem(menu, 'Delete', () => {
                deletePill(pillData.id);
                hideContextMenu();
            });
        } else {
            addMenuItem(menu, `Delete Selected (${PillSelection.getSelectionCount()})`, () => {
                PillSelection.deleteSelectedPills();
                hideContextMenu();
            });
        }
        
        document.body.appendChild(menu);
        
        // Hide menu when clicking elsewhere
        setTimeout(() => {
            const hideMenu = (e) => {
                if (!menu.contains(e.target)) {
                    hideContextMenu();
                    document.removeEventListener('click', hideMenu);
                }
            };
            document.addEventListener('click', hideMenu);
        }, 0);
    }
    
    function addMenuItem(menu, text, callback) {
        const item = document.createElement('a');
        item.textContent = text;
        item.addEventListener('click', callback);
        menu.appendChild(item);
    }
    
    // Modal functions
    function showLinkModal(pillData) {
        document.getElementById('link-tune-modal').style.display = 'flex';
        const input = document.getElementById('tune-link-input');
        if (pillData.tuneId) {
            input.value = `https://thesession.org/tunes/${pillData.tuneId}`;
        } else {
            input.value = '';
        }
        input.focus();
        
        // Store current pill for linking
        window.currentLinkingPill = pillData;
    }
    
    function showEditModal(pillData) {
        document.getElementById('edit-tune-modal').style.display = 'flex';
        const input = document.getElementById('edit-tune-name-input');
        input.value = pillData.tuneName;
        input.focus();
        input.select();
        
        // Add Enter key handler for this modal instance
        const enterHandler = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                confirmEdit();
                input.removeEventListener('keydown', enterHandler);
            }
        };
        input.addEventListener('keydown', enterHandler);
        
        // Store current pill for editing
        window.currentEditingPill = pillData;
    }
    
    // Delete functions
    function deletePill(pillId) {
        // Find and remove the pill
        for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
            const pillIndex = tunePillsData[setIndex].findIndex(p => p.id === pillId);
            if (pillIndex !== -1) {
                saveToUndo();
                tunePillsData[setIndex].splice(pillIndex, 1);
                
                // Remove empty sets
                if (tunePillsData[setIndex].length === 0) {
                    tunePillsData.splice(setIndex, 1);
                }
                
                // Update StateManager with the modified data
                StateManager.setTunePillsData(tunePillsData);
                
                renderTunePills();
                break;
            }
        }
    }
    
    // Delete selected pills now directly calls PillSelection.deleteSelectedPills()
    
    // Undo/Redo functions - now delegated to StateManager
    function saveToUndo() {
        StateManager.saveToUndo();
        // Mark as dirty when any change is made
        AutoSaveManager.forceCheckChanges();
    }
    
    function undo() {
        if (StateManager.undo()) {
            tunePillsData = StateManager.getTunePillsData();
            renderTunePills();
        }
    }
    
    function redo() {
        if (StateManager.redo()) {
            tunePillsData = StateManager.getTunePillsData();
            renderTunePills();
        }
    }
    
    // Clipboard functions
    let clipboard = [];
    
    // Clipboard functions - delegated to PillSelection module  
    function copySelectedPills() {
        const copiedData = PillSelection.copySelectedPills();
        if (copiedData) {
            clipboard = copiedData;
        }
        return copiedData;
    }
    
    function cutSelectedPills() {
        const cutData = PillSelection.cutSelectedPills();
        if (cutData) {
            clipboard = cutData;
        }
        return cutData;
    }
    
    async function pasteFromClipboard() {
        // First try to read from external clipboard
        let externalClipboardData = null;
        let isPlainTextPaste = false;
        if (navigator.clipboard && navigator.clipboard.readText) {
            try {
                const clipboardText = await navigator.clipboard.readText();
                if (clipboardText.trim()) {
                    // Try to parse as JSON first (for internal clipboard data)
                    try {
                        const parsedData = JSON.parse(clipboardText);
                        if (Array.isArray(parsedData)) {
                            // This is internal JSON data - use it as-is, no need to match
                            externalClipboardData = parsedData;
                            isPlainTextPaste = false;
                        }
                    } catch (e) {
                        // Not JSON, treat as plain text tune names
                        // Each line is a set, tunes within a set are comma-separated
                        const lines = clipboardText.split('\n')
                            .map(line => line.trim())
                            .filter(line => line.length > 0);
                        
                        if (lines.length > 0) {
                            // Convert each line to a set of tune objects
                            externalClipboardData = lines.map(line => {
                                const tuneNames = line.split(',')
                                    .map(name => name.trim())
                                    .filter(name => name.length > 0);
                                
                                return tuneNames.map(tunename => ({
                                    id: generateId(),
                                    orderNumber: null,
                                    tuneId: null,
                                    tuneName: tunename,
                                    setting: null,
                                    tuneType: null,
                                    state: 'loading'  // Show loading spinner during matching
                                }));
                            });
                            isPlainTextPaste = true;
                        }
                    }
                }
            } catch (err) {
                console.error('External clipboard read failed:', err);
                // External clipboard read failed, fall back to internal clipboard
            }
        }
        
        // Use external clipboard data if available, otherwise fall back to internal clipboard
        const clipboardData = externalClipboardData || clipboard;
        
        if (!clipboardData || clipboardData.length === 0) return;
        
        // Paste at current cursor position if available, otherwise at the end
        let position;
        const cursorPosition = CursorManager.getCursorPosition();
        if (cursorPosition) {
            position = {
                setIndex: cursorPosition.setIndex,
                pillIndex: cursorPosition.pillIndex,
                position: cursorPosition.position
            };
        } else {
            // Fallback: paste at the end
            position = { setIndex: tunePillsData.length, pillIndex: 0, position: 'newset' };
        }
        pasteAtPosition(clipboardData, position);
        
        // If we pasted external plain text (not JSON), run matching
        if (isPlainTextPaste) {
            // Wait for the DOM to be fully updated before starting matching
            requestAnimationFrame(() => {
                setTimeout(async () => {
                    const originalTuneNames = clipboardData.flat().map(p => p.tuneName);
                    console.log('Starting tune matching for pasted pills:', originalTuneNames);
                    
                    // Find the actual pills that were inserted into tunePillsData
                    // Since pasteAtPosition creates new IDs, we need to find them by tune name
                    const actualPastedPills = [];
                    tunePillsData.forEach(tuneSet => {
                        tuneSet.forEach(pill => {
                            if (originalTuneNames.includes(pill.tuneName) && pill.state === 'loading') {
                                actualPastedPills.push(pill);
                            }
                        });
                    });
                    
                    console.log('Found actual pasted pills in tunePillsData:', actualPastedPills.map(p => `${p.tuneName} (${p.id})`));
                    
                    // Verify pills exist in DOM
                    const missingPills = actualPastedPills.filter(pill => 
                        !document.querySelector(`[data-pill-id="${pill.id}"]`)
                    );
                    if (missingPills.length > 0) {
                        console.warn('Some pills not found in DOM:', missingPills.map(p => p.id));
                    }
                    
                    // Create array of matching promises
                    const matchingPromises = actualPastedPills
                        .filter(pill => pill.state === 'loading')
                        .map(pill => {
                            console.log(`Attempting to match tune: "${pill.tuneName}"`);
                            return autoMatchTune(pill).then(() => {
                                console.log(`Match result for "${pill.tuneName}": ${pill.state}`);
                                updatePillAppearance(pill);
                            }).catch(err => {
                                console.error(`Error matching "${pill.tuneName}":`, err);
                            });
                        });
                    
                    // Wait for all matching operations to complete
                    await Promise.all(matchingPromises);
                    
                    // Force a complete re-render to ensure visual updates are applied
                    renderTunePills();
                    
                    // Now show matching results with accurate pill states
                    console.log('All matching complete, showing results for pills:', actualPastedPills.map(p => `${p.tuneName}: ${p.state}`));
                    showMatchingResults(actualPastedPills);
                }, 200); // Small additional delay after requestAnimationFrame
            });
        }
    }
    
    function pasteAtPosition(pillsData, position) {
        if (!pillsData || pillsData.length === 0) return;
        
        saveToUndo();
        
        // Check if pillsData is a flat array (old format) or array of sets (new format)
        const isNewFormat = Array.isArray(pillsData[0]);
        
        if (isNewFormat) {
            // New format: array of sets with preserved set breaks
            const newSets = pillsData.map(set => 
                set.map(pill => ({
                    ...pill,
                    id: generateId(),
                    orderNumber: null
                }))
            );
            
            let insertPosition = position.setIndex;
            
            if (position.position === 'newset') {
                // Insert sets starting at the specified position
                if (insertPosition >= tunePillsData.length) {
                    // Add at end
                    tunePillsData.push(...newSets);
                } else {
                    // Insert between existing sets
                    tunePillsData.splice(insertPosition, 0, ...newSets);
                }
            } else {
                // Insert into/split existing set
                const targetSetIndex = position.setIndex;
                
                if (targetSetIndex >= tunePillsData.length) {
                    // Add sets at end
                    tunePillsData.push(...newSets);
                } else {
                    const targetSet = tunePillsData[targetSetIndex];
                    let insertIndex = position.pillIndex;
                    
                    // Handle position type
                    if (position.position === 'before') {
                        insertIndex = Math.max(0, position.pillIndex);
                    } else if (position.position === 'after') {
                        insertIndex = Math.min(targetSet.length, position.pillIndex + 1);
                    }
                    
                    if (newSets.length === 1) {
                        // Single set - insert pills into existing set
                        newSets[0].forEach((pill, index) => {
                            targetSet.splice(insertIndex + index, 0, pill);
                        });
                    } else {
                        // Multiple sets - split the target set
                        const beforePills = targetSet.slice(0, insertIndex);
                        const afterPills = targetSet.slice(insertIndex);
                        
                        // Replace target set with: before pills + new sets + after pills
                        const allSets = [];
                        if (beforePills.length > 0) allSets.push(beforePills);
                        allSets.push(...newSets);
                        if (afterPills.length > 0) allSets.push(afterPills);
                        
                        tunePillsData.splice(targetSetIndex, 1, ...allSets);
                    }
                }
            }
            
            const totalPills = newSets.reduce((sum, set) => sum + set.length, 0);
            showMessage(`Pasted ${totalPills} tune(s) in ${newSets.length} set(s)`, 'success');
            
            // Apply landing animation to pasted pills
            const pastedPillIds = newSets.flat().map(pill => pill.id);
            setTimeout(() => {
                applyLandingAnimation(pastedPillIds);
            }, 50);
        } else {
            // Old format: flat array of pills - use original logic
            const newPills = pillsData.map(pill => ({
                ...pill,
                id: generateId(),
                orderNumber: null
            }));
            
            if (position.position === 'newset') {
                const targetSetIndex = position.setIndex;
                if (targetSetIndex >= tunePillsData.length) {
                    tunePillsData.push(newPills);
                } else {
                    tunePillsData.splice(targetSetIndex, 0, newPills);
                }
            } else {
                let targetSetIndex = position.setIndex;
                if (targetSetIndex >= tunePillsData.length) {
                    tunePillsData.push(newPills);
                } else {
                    const targetSet = tunePillsData[targetSetIndex];
                    let insertIndex = position.pillIndex;
                    
                    if (position.position === 'before') {
                        insertIndex = Math.max(0, position.pillIndex);
                    } else if (position.position === 'after') {
                        insertIndex = Math.min(targetSet.length, position.pillIndex + 1);
                    }
                    
                    newPills.forEach((pill, index) => {
                        targetSet.splice(insertIndex + index, 0, pill);
                    });
                }
            }
            
            showMessage(`Pasted ${newPills.length} tune(s)`, 'success');
            
            // Apply landing animation to pasted pills
            const pastedPillIds = newPills.map(pill => pill.id);
            setTimeout(() => {
                applyLandingAnimation(pastedPillIds);
            }, 50);
        }
        
        // Update StateManager with the modified data
        StateManager.setTunePillsData(tunePillsData);
        
        renderTunePills();
    }
    
    // Text input handling functions
    function handleTextInput(char) {
        if (!isTyping) {
            isTyping = true;
            typingBuffer = '';
            typingPill = null;
        }
        
        // Clear any existing typing timeout
        if (typingTimeout) {
            clearTimeout(typingTimeout);
            typingTimeout = null;
        }
        
        // Handle comma and semicolon as immediate tune separators
        if (char === ',' || char === ';') {
            // If we have content in the buffer, finish the current tune first
            if (typingBuffer.trim()) {
                const tuneName = typingBuffer.trim();
                typingBuffer = '';
                
                // Insert the current tune and start matching
                insertTunesAtCursor([tuneName], true); // Keep keyboard open for continued typing
                
                // Continue in typing mode for the next tune
                CursorManager.updateCursorWithText();
            }
            // Don't add the comma/semicolon to the buffer
            return;
        }
        
        typingBuffer += char;
        CursorManager.updateCursorWithText();
        
        // Set a timeout to trigger matching after 3 seconds of no typing
        typingTimeout = setTimeout(() => {
            if (isTyping && typingBuffer.trim()) {
                // Trigger matching but stay in typing mode
                performTypingMatch();
            }
        }, 3000);
    }
    
    // Perform matching while still in typing mode
    function performTypingMatch() {
        if (!isTyping || !typingBuffer.trim()) return;
        
        // Create a temporary pill for matching
        if (!typingPill) {
            typingPill = {
                id: 'typing-' + Date.now(),
                orderNumber: null,
                tuneId: null,
                tuneName: typingBuffer.trim(),
                setting: null,
                tuneType: null,
                state: 'typing'
            };
        } else {
            typingPill.tuneName = typingBuffer.trim();
        }
        
        // Find the previous tune type if we're in a set
        let previousTuneType = null;
        const cursorPosition = CursorManager.getCursorPosition();
        if (cursorPosition) {
            const { setIndex, pillIndex, position } = cursorPosition;
            console.log(`Finding previous tune type - cursor at: setIndex=${setIndex}, pillIndex=${pillIndex}, position=${position}`);
            console.log(`tunePillsData structure:`, tunePillsData.map((set, i) => `Set ${i}: ${set.length} pills`));
            
            if (setIndex < tunePillsData.length) {
                const set = tunePillsData[setIndex];
                console.log(`Current set has ${set.length} pills:`, set.map(p => `${p.tuneName}(${p.tuneType})`));
                
                // Different logic based on cursor position
                if (position === 'after' && pillIndex >= 0 && pillIndex < set.length) {
                    // Cursor is after a pill - look backwards from current pill
                    console.log(`Looking backwards from pill ${pillIndex} in 'after' position`);
                    for (let i = pillIndex; i >= 0; i--) {
                        console.log(`Checking pill ${i}: ${set[i].tuneName} (${set[i].tuneType})`);
                        if (set[i].tuneType) {
                            previousTuneType = set[i].tuneType;
                            console.log(`Found previous tune type from pill ${i}: ${previousTuneType}`);
                            break;
                        }
                    }
                } else if (position === 'before' && pillIndex > 0 && pillIndex <= set.length) {
                    // Cursor is before a pill but not the first - look at previous pill
                    console.log(`Looking backwards from pill ${pillIndex - 1} in 'before' position`);
                    for (let i = pillIndex - 1; i >= 0; i--) {
                        console.log(`Checking pill ${i}: ${set[i].tuneName} (${set[i].tuneType})`);
                        if (set[i].tuneType) {
                            previousTuneType = set[i].tuneType;
                            console.log(`Found previous tune type from pill ${i}: ${previousTuneType}`);
                            break;
                        }
                    }
                } else if (position === 'newset' && setIndex > 0) {
                    // Starting a new set - check the last tune of the previous set
                    const prevSet = tunePillsData[setIndex - 1];
                    console.log(`Looking in previous set (${setIndex - 1}) with ${prevSet ? prevSet.length : 0} pills`);
                    if (prevSet && prevSet.length > 0) {
                        for (let i = prevSet.length - 1; i >= 0; i--) {
                            console.log(`Checking prev set pill ${i}: ${prevSet[i].tuneName} (${prevSet[i].tuneType})`);
                            if (prevSet[i].tuneType) {
                                previousTuneType = prevSet[i].tuneType;
                                console.log(`Found previous tune type from previous set pill ${i}: ${previousTuneType}`);
                                break;
                            }
                        }
                    }
                } else {
                    console.log(`No matching cursor position logic for setIndex=${setIndex}, pillIndex=${pillIndex}, position=${position}`);
                }
            } else {
                console.log(`setIndex ${setIndex} >= tunePillsData.length ${tunePillsData.length}`);
            }
        } else {
            console.log(`No cursorPosition available`);
        }
        
        // Store previous tune type on the pill for the API call
        typingPill.previousTuneType = previousTuneType;
        
        // Call autoMatchTune with stillTyping flag
        autoMatchTune(typingPill, true).then(() => {
            // If we got results, show them as a dropdown menu
            if (typingPill.matchResults && typingPill.matchResults.length > 0) {
                // Show the match results menu positioned at the typing cursor
                showTypingMatchResults(typingPill);
            }
        });
    }
    
    // Show match results for the tune being typed
    function showTypingMatchResults(pill) {
        // Hide any existing typing match results
        const existingMenu = document.querySelector('.typing-match-menu');
        if (existingMenu) {
            existingMenu.remove();
        }
        
        if (!pill.matchResults || pill.matchResults.length === 0) {
            return;
        }
        
        // Find the typing text element
        const typingText = document.querySelector('.typing-text');
        if (!typingText) {
            return;
        }
        
        const menu = document.createElement('div');
        menu.className = 'tune-context-menu typing-match-menu';
        menu.style.display = 'block';
        
        const rect = typingText.getBoundingClientRect();
        
        // Position menu below the typing text
        menu.style.position = 'fixed';
        menu.style.left = rect.left + 'px';
        menu.style.top = (rect.bottom + 5) + 'px';
        menu.style.width = 'auto';
        menu.style.minWidth = Math.max(200, rect.width) + 'px';
        menu.style.maxWidth = Math.min(600, window.innerWidth - rect.left - 20) + 'px';
        
        // Use a neutral background for the menu
        menu.style.backgroundColor = 'white';
        menu.style.color = '#212529';
        menu.style.border = '1px solid #dee2e6';
        menu.style.borderRadius = '4px';
        menu.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        menu.style.zIndex = '1000';
        
        // Add match results as menu items
        pill.matchResults.forEach((result, index) => {
            const item = document.createElement('a');
            item.style.display = 'block';
            item.style.padding = '8px 12px';
            item.style.cursor = 'pointer';
            item.style.borderBottom = index < pill.matchResults.length - 1 ? '1px solid #f0f0f0' : 'none';
            item.style.color = '#212529';
            item.style.textDecoration = 'none';
            
            // Show tune name and type
            const nameSpan = document.createElement('span');
            nameSpan.textContent = result.tune_name;
            nameSpan.style.fontWeight = '500';
            item.appendChild(nameSpan);
            
            if (result.tune_type) {
                const typeSpan = document.createElement('span');
                typeSpan.textContent = ` (${result.tune_type})`;
                typeSpan.style.color = '#6c757d';
                typeSpan.style.fontSize = '0.9em';
                item.appendChild(typeSpan);
            }
            
            // Hover effect
            item.addEventListener('mouseenter', () => {
                item.style.backgroundColor = '#f8f9fa';
            });
            item.addEventListener('mouseleave', () => {
                item.style.backgroundColor = 'transparent';
            });
            
            // Click to select this match
            item.addEventListener('click', () => {
                // Apply the selected match to the typing buffer
                typingBuffer = result.tune_name;
                CursorManager.updateCursorWithText();
                
                // Store the match info for when we finish typing
                typingPill.tuneId = result.tune_id;
                typingPill.tuneName = result.tune_name;
                typingPill.tuneType = result.tune_type;
                typingPill.state = 'matched';
                
                // Hide the menu
                menu.remove();
                
                // Finish typing and insert the matched tune
                finishTyping(true);
            });
            
            menu.appendChild(item);
        });
        
        document.body.appendChild(menu);
        
        // Remove menu when typing continues or stops
        const removeMenu = () => {
            const menu = document.querySelector('.typing-match-menu');
            if (menu) {
                menu.remove();
            }
        };
        
        // Set up event to remove menu on any keypress
        const keyHandler = () => {
            removeMenu();
            document.removeEventListener('keydown', keyHandler);
        };
        document.addEventListener('keydown', keyHandler);
    }
    
    function handleBackspace() {
        // If multiple pills are selected, delete them all
        if (PillSelection.hasSelection()) {
            PillSelection.deleteSelectedPills();
            return;
        }
        
        if (isTyping && typingBuffer.length > 0) {
            typingBuffer = typingBuffer.slice(0, -1);
            CursorManager.updateCursorWithText();
        } else if (CursorManager.getCursorPosition() && !isTyping) {
            const cursorPosition = CursorManager.getCursorPosition();
            const { setIndex, pillIndex, position } = cursorPosition;
            
            // Special case: At the beginning of an empty line (after deleting leftmost tune)
            if (position === 'before' && pillIndex === 0 && tunePillsData[setIndex].length === 0) {
                // Don't do anything if this is the first line
                if (setIndex === 0) {
                    return;
                }
                
                // Delete the set break and merge with previous line
                saveToUndo();
                
                // Just remove the empty set and position cursor at end of previous set
                tunePillsData.splice(setIndex, 1);
                
                // Update StateManager with the modified data
                StateManager.setTunePillsData(tunePillsData);
                
                // Position cursor at end of previous set
                renderTunePills();
                if (setIndex - 1 >= 0 && tunePillsData[setIndex - 1].length > 0) {
                    setCursorPosition(setIndex - 1, tunePillsData[setIndex - 1].length - 1, 'after');
                } else {
                    setCursorPosition(0, 0, 'before');
                }
                return;
            }
            
            // Check for another special case: At the beginning of a line with content
            if (position === 'before' && pillIndex === 0 && tunePillsData[setIndex].length > 0 && setIndex > 0) {
                // At the beginning of a line with content - merge current set with previous set
                saveToUndo();
                const prevSet = tunePillsData[setIndex - 1];
                const currentSet = tunePillsData[setIndex];
                const prevSetOriginalLength = prevSet.length;
                
                // Append all pills from current set to previous set
                prevSet.push(...currentSet);
                
                // Remove the current set
                tunePillsData.splice(setIndex, 1);
                
                // Update StateManager with the modified data
                StateManager.setTunePillsData(tunePillsData);
                
                // Position cursor where the merge happened
                renderTunePills();
                setCursorPosition(setIndex - 1, prevSetOriginalLength, 'after');
                return;
            }
            
            // Normal backspace behavior: delete tune to the left
            deleteTuneAtCursor();
        }
    }
    
    function handleDelete() {
        // If multiple pills are selected, delete them all
        if (PillSelection.hasSelection()) {
            PillSelection.deleteSelectedPills();
            return;
        }
        
        const cursorPosition = CursorManager.getCursorPosition();
        if (!cursorPosition || isTyping) return;
        
        const { setIndex, pillIndex, position } = cursorPosition;
        
        // Special case: On an empty temporary line - just remove the empty line
        if (position === 'before' && pillIndex === 0 && tunePillsData[setIndex].length === 0) {
            // First line, do nothing
            if (setIndex === 0) {
                return;
            }
            
            // Just remove the empty set without merging anything
            saveToUndo();
            tunePillsData.splice(setIndex, 1);
            
            // Update StateManager with the modified data
            StateManager.setTunePillsData(tunePillsData);
            
            // Position cursor at end of previous set
            renderTunePills();
            if (setIndex - 1 >= 0 && tunePillsData[setIndex - 1].length > 0) {
                setCursorPosition(setIndex - 1, tunePillsData[setIndex - 1].length - 1, 'after');
            } else {
                setCursorPosition(0, 0, 'before');
            }
            return;
        }
        
        // Special case: At the end of a line - merge next line's content into current line
        if (position === 'after' && pillIndex === tunePillsData[setIndex].length - 1) {
            // Check if there's a next set to merge
            if (setIndex + 1 < tunePillsData.length) {
                saveToUndo();
                const currentSet = tunePillsData[setIndex];
                const nextSet = tunePillsData[setIndex + 1];
                const currentSetOriginalLength = currentSet.length;
                
                // Append all pills from next set to current set
                currentSet.push(...nextSet);
                
                // Remove the next set
                tunePillsData.splice(setIndex + 1, 1);
                
                // Update StateManager with the modified data
                StateManager.setTunePillsData(tunePillsData);
                
                // Keep cursor at end of original current set content
                renderTunePills();
                setCursorPosition(setIndex, currentSetOriginalLength - 1, 'after');
                return;
            }
        }
        
        // Normal delete behavior: delete tune to the right
        let tuneToDelete = null;
        let newCursorPosition = null;
        
        if (position === 'before') {
            // Delete the pill at the current position
            if (pillIndex < tunePillsData[setIndex].length) {
                tuneToDelete = { setIndex, pillIndex };
                // Cursor stays in the same position (before the next pill)
                newCursorPosition = { setIndex, pillIndex, position: 'before' };
            }
        } else if (position === 'after') {
            // Delete the next pill if it exists
            if (pillIndex + 1 < tunePillsData[setIndex].length) {
                tuneToDelete = { setIndex, pillIndex: pillIndex + 1 };
                // Cursor stays after the current pill
                newCursorPosition = { setIndex, pillIndex, position: 'after' };
            } else if (setIndex + 1 < tunePillsData.length && tunePillsData[setIndex + 1].length > 0) {
                // At end of set, delete first pill of next set
                tuneToDelete = { setIndex: setIndex + 1, pillIndex: 0 };
                // Cursor stays at end of current set
                newCursorPosition = { setIndex, pillIndex, position: 'after' };
            }
        }
        
        if (tuneToDelete) {
            saveToUndo();
            const targetSet = tunePillsData[tuneToDelete.setIndex];
            const wasLastPillInSet = targetSet.length === 1; // Check before deletion
            targetSet.splice(tuneToDelete.pillIndex, 1);
            
            // Check if this deletion creates a temporary empty set
            // This happens when deleting the only pill in a set and cursor stays in that set
            const shouldCreateTemporaryEmpty = (targetSet.length === 0 && 
                                              wasLastPillInSet &&
                                              newCursorPosition && 
                                              newCursorPosition.setIndex === tuneToDelete.setIndex);
            
            // Handle empty sets
            if (targetSet.length === 0 && shouldCreateTemporaryEmpty) {
                // Mark this as a temporary empty set
                temporaryEmptySet = tuneToDelete.setIndex;
            } else if (targetSet.length === 0) {
                // Remove the empty set entirely and adjust cursor positions
                tunePillsData.splice(tuneToDelete.setIndex, 1);
                // Adjust cursor position if needed
                if (newCursorPosition && newCursorPosition.setIndex > tuneToDelete.setIndex) {
                    newCursorPosition.setIndex--;
                } else if (newCursorPosition && newCursorPosition.setIndex === tuneToDelete.setIndex) {
                    // The set we were in was removed
                    if (tuneToDelete.setIndex > 0) {
                        // Go to end of previous set
                        newCursorPosition = { 
                            setIndex: tuneToDelete.setIndex - 1, 
                            pillIndex: tunePillsData[tuneToDelete.setIndex - 1].length - 1, 
                            position: 'after' 
                        };
                    } else if (tunePillsData.length > 0) {
                        // Go to beginning of next set (which is now at index 0)
                        newCursorPosition = { setIndex: 0, pillIndex: 0, position: 'before' };
                    } else {
                        // No sets left
                        newCursorPosition = { setIndex: 0, pillIndex: 0, position: 'newset' };
                    }
                }
            }
            
            renderTunePills();
            
            // Apply the new cursor position
            if (newCursorPosition) {
                // Ensure the position is valid
                if (newCursorPosition.setIndex < tunePillsData.length) {
                    const setLength = tunePillsData[newCursorPosition.setIndex].length;
                    if (newCursorPosition.position === 'after' && newCursorPosition.pillIndex >= setLength) {
                        newCursorPosition.pillIndex = setLength - 1;
                    } else if (newCursorPosition.position === 'before' && newCursorPosition.pillIndex > setLength) {
                        newCursorPosition.pillIndex = setLength;
                    }
                }
                setCursorPosition(newCursorPosition.setIndex, newCursorPosition.pillIndex, newCursorPosition.position);
            }
        }
    }
    
    function handleEnterKey() {
        const cursorPosition = CursorManager.getCursorPosition();
        if (!cursorPosition) return;
        
        const { setIndex, pillIndex, position } = cursorPosition;
        
        // Only create new line if at the end of a set (after the last pill)
        if (position === 'after' && tunePillsData[setIndex] && pillIndex === tunePillsData[setIndex].length - 1) {
            // Create temporary empty set after current set
            const newSetIndex = setIndex + 1;
            tunePillsData.splice(newSetIndex, 0, []);
            temporaryEmptySet = newSetIndex;
            
            // Update StateManager with the modified data
            StateManager.setTunePillsData(tunePillsData);
            
            renderTunePills();
            setCursorPosition(newSetIndex, 0, 'before');
            
        }
    }
    
    function removeTemporaryEmptySet() {
        if (temporaryEmptySet !== null && temporaryEmptySet < tunePillsData.length && tunePillsData[temporaryEmptySet].length === 0) {
            tunePillsData.splice(temporaryEmptySet, 1);
            temporaryEmptySet = null;
            
            // Update StateManager with the modified data
            StateManager.setTunePillsData(tunePillsData);
            
            return true;
        }
        temporaryEmptySet = null;
        return false;
    }
    
    function finishTyping(keepKeyboardOpen = false) {
        // Clear any typing timeout
        if (typingTimeout) {
            clearTimeout(typingTimeout);
            typingTimeout = null;
        }
        
        // Hide any typing match menu
        const typingMenu = document.querySelector('.typing-match-menu');
        if (typingMenu) {
            typingMenu.remove();
        }
        
        // If we're trying to keep keyboard open, set the flag
        if (keepKeyboardOpen) {
            isKeepingKeyboardOpen = true;
            // Clear the flag after a delay to allow processing to complete
            setTimeout(() => {
                isKeepingKeyboardOpen = false;
            }, 1000);
        }
        
        if (isTyping && typingBuffer.trim()) {
            const tuneNames = typingBuffer.split(/[,;]/).map(name => name.trim()).filter(name => name);
            insertTunesAtCursor(tuneNames, keepKeyboardOpen);
        }
        
        typingBuffer = '';
        isTyping = false;
        typingPill = null;
        CursorManager.updateCursorWithText();
        
        // On mobile, only hide keyboard if not continuing to type
        if (isMobileDevice() && !keepKeyboardOpen) {
            const container = document.getElementById('tune-pills-container');
            if (container) {
                container.contentEditable = 'false';
                container.blur();
            }
        } else if (isMobileDevice() && keepKeyboardOpen) {
            // When keeping keyboard open, ensure the container stays focused and editable
            const container = document.getElementById('tune-pills-container');
            if (container) {
                // Keep contentEditable true and don't blur
                container.contentEditable = 'true';
                container.inputMode = 'text';
                
                // Re-focus after a longer delay to ensure everything is complete
                setTimeout(() => {
                    container.focus();
                }, 300);
            }
        }
    }
    
    function cancelTyping() {
        // Clear any typing timeout
        if (typingTimeout) {
            clearTimeout(typingTimeout);
            typingTimeout = null;
        }
        
        // Hide any typing match menu
        const typingMenu = document.querySelector('.typing-match-menu');
        if (typingMenu) {
            typingMenu.remove();
        }
        
        typingBuffer = '';
        isTyping = false;
        typingPill = null;
        CursorManager.updateCursorWithText();
        
        // On mobile, remove contenteditable to hide keyboard
        if (isMobileDevice()) {
            const container = document.getElementById('tune-pills-container');
            if (container) {
                container.contentEditable = 'false';
                container.blur();
            }
        }
    }
    
    // Track the original cursor context during typing
    let typingContext = null;
    
    // Track selection anchor for shift+arrow selection
    let selectionAnchor = null;
    
    // Track if we need to re-render after typing finishes
    let pendingRender = false;
    
    // Track temporary empty line
    let temporaryEmptySet = null;
    
    // Apply landing animation to pills that have been moved
    function applyLandingAnimation(pillIds) {
        pillIds.forEach(pillId => {
            const pillElement = document.querySelector(`[data-pill-id="${pillId}"]`);
            if (pillElement) {
                pillElement.classList.add('just-landed');
                setTimeout(() => {
                    pillElement.classList.remove('just-landed');
                }, 3000);
            }
        });
    }
    
    function selectPillsBetweenPositions(startPos, endPos) {
        // Convert positions to cursor format and use PillSelection method
        const startCursor = { setIndex: startPos.setIndex, pillIndex: startPos.pillIndex, position: 'after' };
        const endCursor = { setIndex: endPos.setIndex, pillIndex: endPos.pillIndex, position: 'after' };
        PillSelection.selectFromCursorRange(startCursor, endCursor);
    }
    
    function selectPillsBetweenCursorPositions(startCursorPos, endCursorPos) {
        // Use PillSelection method directly
        PillSelection.selectFromCursorRange(startCursorPos, endCursorPos);
    }
    
    
    function findPillIndex(allPills, pillPos) {
        if (!pillPos) return -1;
        
        for (let i = 0; i < allPills.length; i++) {
            if (allPills[i].setIndex === pillPos.setIndex && allPills[i].pillIndex === pillPos.pillIndex) {
                return i;
            }
        }
        return -1;
    }
    
    
    function updateCursorWithText() {
        return CursorManager.updateCursorWithText();
    }
    
    function insertTunesAtCursor(tuneNames, keepKeyboardOpen = false) {
        const cursorPosition = CursorManager.getCursorPosition();
        if (!cursorPosition || tuneNames.length === 0) return;
        
        // If we're adding tunes to a temporary empty set, make it permanent
        if (temporaryEmptySet !== null && cursorPosition.setIndex === temporaryEmptySet) {
            temporaryEmptySet = null;
        }
        
        saveToUndo();
        
        const { setIndex, pillIndex, position } = cursorPosition;
        
        // Calculate the previous tune type based on cursor position before inserting pills
        let previousTuneType = null;
        console.log(`insertTunesAtCursor - Finding previous tune type for cursor at: setIndex=${setIndex}, pillIndex=${pillIndex}, position=${position}`);
        
        if (setIndex < tunePillsData.length) {
            const set = tunePillsData[setIndex];
            console.log(`Current set has ${set.length} pills:`, set.map(p => `${p.tuneName}(${p.tuneType})`));
            
            if (position === 'after' && pillIndex >= 0 && pillIndex < set.length) {
                // Cursor is after a pill - look backwards from current pill
                for (let i = pillIndex; i >= 0; i--) {
                    if (set[i].tuneType) {
                        previousTuneType = set[i].tuneType;
                        console.log(`Found previous tune type from pill ${i}: ${previousTuneType}`);
                        break;
                    }
                }
            } else if (position === 'before' && pillIndex > 0) {
                // Cursor is before a pill but not the first - look at previous pill
                for (let i = pillIndex - 1; i >= 0; i--) {
                    if (set[i].tuneType) {
                        previousTuneType = set[i].tuneType;
                        console.log(`Found previous tune type from pill ${i}: ${previousTuneType}`);
                        break;
                    }
                }
            }
        } else if (position === 'newset' && setIndex > 0) {
            // Starting a new set - check the last tune of the previous set
            const prevSet = tunePillsData[setIndex - 1];
            if (prevSet && prevSet.length > 0) {
                for (let i = prevSet.length - 1; i >= 0; i--) {
                    if (prevSet[i].tuneType) {
                        previousTuneType = prevSet[i].tuneType;
                        console.log(`Found previous tune type from previous set pill ${i}: ${previousTuneType}`);
                        break;
                    }
                }
            }
        }
        
        // Create new pills with the calculated previous tune type
        const newPills = tuneNames.map(name => ({
            id: generateId(),
            orderNumber: null,
            tuneId: null,
            tuneName: name,
            setting: null,
            tuneType: null,
            state: 'loading',  // Show loading spinner until API responds
            previousTuneType: previousTuneType  // Store for API call
        }));
        
        console.log(`Created ${newPills.length} pills with previousTuneType: ${previousTuneType}`);
        
        // Attempt to auto-match each tune via API
        const matchPromises = newPills.map(pill => autoMatchTune(pill));
        
        // Wait for all matching to complete, then show appropriate message
        Promise.all(matchPromises).then(() => {
            showMatchingResults(newPills);
        });
        
        
        if (position === 'newset') {
            if (setIndex >= tunePillsData.length) {
                // Create new set at end
                tunePillsData.push(newPills);
                // Position cursor after the last inserted pill in this new set
                setCursorPosition(tunePillsData.length - 1, newPills.length - 1, 'after', keepKeyboardOpen);
            } else {
                // Create new set at specific index (insert between existing sets)
                tunePillsData.splice(setIndex, 0, newPills);
                // Position cursor after the last inserted pill in this new set
                setCursorPosition(setIndex, newPills.length - 1, 'after', keepKeyboardOpen);
            }
        } else {
            // Insert into existing set
            const targetSet = tunePillsData[setIndex];
            let insertIndex = pillIndex;
            
            if (position === 'before') {
                insertIndex = Math.max(0, pillIndex);
            } else if (position === 'after') {
                insertIndex = Math.min(targetSet.length, pillIndex + 1);
            }
            
            
            // Insert all new pills at the position
            newPills.forEach((pill, index) => {
                targetSet.splice(insertIndex + index, 0, pill);
            });
            
            // Move cursor to after the inserted pills
            const newCursorPillIndex = insertIndex + newPills.length - 1;
            setCursorPosition(setIndex, newCursorPillIndex, 'after', keepKeyboardOpen);
        }
        
        // Update StateManager with the modified data
        StateManager.setTunePillsData(tunePillsData);
        
        renderTunePills();
    }
    
    // Show results after all tune matching completes
    function showMatchingResults(pills) {
        const linkedCount = pills.filter(pill => pill.state === 'linked').length;
        const unlinkedCount = pills.filter(pill => pill.state === 'unlinked').length;
        const totalCount = pills.length;
        
        let message, type;
        
        if (linkedCount === totalCount) {
            // All tunes matched
            message = totalCount === 1 ? 'Tune matched' : `All ${totalCount} tunes matched`;
            type = 'success';
        } else if (linkedCount === 0) {
            // No tunes matched
            message = totalCount === 1 ? 'Tune not matched' : `${totalCount} tunes not matched`;
            type = 'error';
        } else {
            // Some matched, some didn't
            message = `${linkedCount} of ${totalCount} tunes matched`;
            type = 'success';
        }
        
        showMessage(message, type);
    }
    
    // Auto-match a tune against the database without saving
    async function autoMatchTune(pill, stillTyping = false) {
        try {
            // Find the previous tune type if this pill is in a set
            let previousTuneType = null;
            
            // Check if the pill already has a previousTuneType set (for typing pills)
            if (pill.previousTuneType !== undefined) {
                previousTuneType = pill.previousTuneType;
                console.log(`Using pre-calculated previous tune type: ${previousTuneType}`);
            } else {
                // Find which set this pill belongs to
                for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
                    const set = tunePillsData[setIndex];
                    const pillIndex = set.findIndex(p => p.id === pill.id);
                    
                    if (pillIndex > 0) {
                        // This pill is not the first in the set, check previous pills for tune type
                        for (let i = pillIndex - 1; i >= 0; i--) {
                            if (set[i].tuneType) {
                                previousTuneType = set[i].tuneType;
                                break;
                            }
                        }
                        break;
                    }
                }
            }
            
            console.log(`Making API request to match tune: "${pill.tuneName}" (previous type: ${previousTuneType || 'none'})`);
            const response = await fetch(`/api/sessions/{{ session_instance.session_path }}/{{ session_instance.date }}/match_tune`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    tune_name: pill.tuneName,
                    previous_tune_type: previousTuneType
                })
            });
            
            console.log(`API response status for "${pill.tuneName}": ${response.status}`);
            
            if (!response.ok) {
                console.warn(`Failed to match tune "${pill.tuneName}": ${response.status}`);
                const errorText = await response.text();
                console.warn('Error response:', errorText);
                return;
            }
            
            const result = await response.json();
            console.log(`API result for "${pill.tuneName}":`, result);
            
            if (result.success && result.results) {
                // Store the results on the pill for later use
                pill.matchResults = result.results;
                
                if (result.results.length === 1 && result.exact_match) {
                    // Single exact match - automatically apply it
                    const match = result.results[0];
                    pill.tuneId = match.tune_id;
                    pill.tuneName = match.tune_name;
                    pill.tuneType = match.tune_type;
                    pill.state = 'linked';
                    pill.matchResults = null; // Clear stored results
                    console.log(`Successfully matched "${pill.tuneName}" -> "${match.tune_name}" (ID: ${match.tune_id})`);
                    
                    // Mark as dirty since we changed the pill
                    AutoSaveManager.forceCheckChanges();
                    
                } else if (result.results.length > 1) {
                    // Multiple matches - mark as unmatched and store results
                    pill.state = 'unmatched';
                    console.log(`Multiple matches found for "${pill.tuneName}": ${result.results.length} results`);
                    
                    // Mark as dirty since we changed the pill state
                    AutoSaveManager.forceCheckChanges();
                    
                    // Show context menu with results if still typing/editing
                    if (stillTyping) {
                        showMatchResultsMenu(pill);
                    } else {
                        // User has exited text entry - hide any existing menu
                        hideMatchResultsMenu(pill.id);
                    }
                    
                } else if (result.results.length === 1 && !result.exact_match) {
                    // Single wildcard match
                    if (stillTyping) {
                        // While typing, just show the option but don't auto-apply
                        pill.state = 'unmatched';
                        AutoSaveManager.forceCheckChanges();
                        showMatchResultsMenu(pill);
                    } else {
                        // When finished typing, auto-apply single wildcard match
                        const match = result.results[0];
                        pill.tuneId = match.tune_id;
                        pill.tuneName = match.tune_name;
                        pill.tuneType = match.tune_type;
                        pill.state = 'linked';
                        pill.matchResults = null;
                        console.log(`Auto-applied single wildcard match: "${pill.tuneName}" -> "${match.tune_name}" (ID: ${match.tune_id})`);
                        
                        // Mark as dirty since we changed the pill
                        AutoSaveManager.forceCheckChanges();
                    }
                    
                } else {
                    // No matches at all
                    pill.state = 'unlinked';
                    pill.matchResults = null;
                    console.log(`No match found for "${pill.tuneName}"`);
                    
                    // Mark as dirty since we changed the pill state
                    AutoSaveManager.forceCheckChanges();
                }
            } else {
                // Error or unexpected response format
                pill.state = 'unlinked';
                pill.matchResults = null;
                console.warn(`Unexpected response format for "${pill.tuneName}"`);
                
                // Mark as dirty since we changed the pill state
                AutoSaveManager.markDirty();
            }
            
            // Update just this pill instead of re-rendering everything
            updatePillAppearance(pill);
        } catch (error) {
            console.error(`Network error matching tune "${pill.tuneName}":`, error);
            // Network error - pill becomes unlinked
            pill.state = 'unlinked';
            pill.matchResults = null;
            
            // Mark as dirty since we changed the pill state
            AutoSaveManager.markDirty();
            
            updatePillAppearance(pill);
        }
    }
    
    // Update the appearance of a single pill without re-rendering everything
    function updatePillAppearance(pill) {
        console.log(`Updating appearance for pill ID: ${pill.id}, state: ${pill.state}, name: ${pill.tuneName}`);
        const pillElement = document.querySelector(`[data-pill-id="${pill.id}"]`);
        if (!pillElement) {
            console.error(`Could not find pill element with ID: ${pill.id}`);
            return;
        }
        
        console.log(`Found pill element, updating class from "${pillElement.className}" to "tune-pill ${pill.state}"`);
        // Update the CSS class to reflect the new state
        pillElement.className = `tune-pill ${pill.state}`;
        
        // Update the text content in case it changed (e.g., canonical name from API)
        const textElement = pillElement.querySelector('.text');
        if (textElement) {
            console.log(`Updating text content from "${textElement.textContent}" to "${pill.tuneName}"`);
            textElement.textContent = pill.tuneName;
        } else {
            console.error('Could not find .text element within pill');
        }
        
        // Remove any existing spinner
        const existingSpinner = pillElement.querySelector('.loading-spinner');
        if (existingSpinner) {
            existingSpinner.remove();
        }
        
        // Add spinner if still loading
        if (pill.state === 'loading') {
            const spinner = document.createElement('span');
            spinner.className = 'loading-spinner';
            pillElement.appendChild(spinner);
        }
    }
    
    function deleteTuneAtCursor() {
        const cursorPosition = CursorManager.getCursorPosition();
        if (!cursorPosition) return;
        
        const { setIndex, pillIndex, position } = cursorPosition;
        
        // Always delete the pill immediately to the left of the cursor (backspace behavior)
        let tuneToDelete = null;
        let newCursorPosition = null;
        
        if (position === 'after') {
            // Cursor is after a pill - delete that pill
            tuneToDelete = { setIndex, pillIndex };
            // After deletion, if there's a pill to the left, position after it
            if (pillIndex > 0) {
                newCursorPosition = { setIndex, pillIndex: pillIndex - 1, position: 'after' };
            } else {
                // Deleting first pill of the set - check if it's the only pill
                if (tunePillsData[setIndex].length === 1) {
                    // This is the only pill in the set - set should become a temporary empty line
                    newCursorPosition = { setIndex, pillIndex: 0, position: 'before' };
                } else {
                    // There are other pills in the set, position before the next pill
                    newCursorPosition = { setIndex, pillIndex: 0, position: 'before' };
                }
            }
        } else if (position === 'before' && pillIndex > 0) {
            // Cursor is before a pill - delete the previous pill
            tuneToDelete = { setIndex, pillIndex: pillIndex - 1 };
            // After deletion, cursor stays before the same pill (which now has a lower index)
            newCursorPosition = { setIndex, pillIndex: pillIndex - 1, position: 'before' };
        } else if (position === 'before' && pillIndex === 0) {
            // Cursor is at the beginning of a set - for backspace, we don't delete anything here
            // This case should be handled by the caller (e.g., merge with previous line if empty)
            return;
        } else if (position === 'newset' && setIndex > 0 && tunePillsData[setIndex - 1].length > 0) {
            // Cursor is at a new set position - delete the last pill of the previous set
            const prevSetIndex = setIndex - 1;
            const prevSetLength = tunePillsData[prevSetIndex].length;
            tuneToDelete = { setIndex: prevSetIndex, pillIndex: prevSetLength - 1 };
            newCursorPosition = { setIndex: prevSetIndex, pillIndex: prevSetLength - 1, position: 'after' };
        }
        
        if (tuneToDelete) {
            saveToUndo();
            const targetSet = tunePillsData[tuneToDelete.setIndex];
            const wasLastPillInSet = targetSet.length === 1; // Check before deletion
            targetSet.splice(tuneToDelete.pillIndex, 1);
            
            // Check if this deletion creates a temporary empty set
            // This happens when deleting the only pill in a set and cursor stays in that set
            const shouldCreateTemporaryEmpty = (targetSet.length === 0 && 
                                              wasLastPillInSet &&
                                              newCursorPosition && 
                                              newCursorPosition.setIndex === tuneToDelete.setIndex &&
                                              newCursorPosition.position === 'before');
            
            // Handle empty sets
            const setWasRemoved = targetSet.length === 0 && !shouldCreateTemporaryEmpty;
            if (setWasRemoved) {
                tunePillsData.splice(tuneToDelete.setIndex, 1);
            } else if (shouldCreateTemporaryEmpty) {
                // Mark this as a temporary empty set
                temporaryEmptySet = tuneToDelete.setIndex;
            }
            
            // Update StateManager with the modified data
            StateManager.setTunePillsData(tunePillsData);
            
            // Render first, then set cursor position
            renderTunePills();
            
            // Apply the cursor position after rendering when cursor position elements exist
            if (setWasRemoved) {
                // Set was removed - use the stored cursor position but adjust for removed set
                if (newCursorPosition.setIndex < tuneToDelete.setIndex) {
                    // Cursor position is in a set before the deleted one, no adjustment needed
                    setCursorPosition(newCursorPosition.setIndex, newCursorPosition.pillIndex, newCursorPosition.position);
                } else if (newCursorPosition.setIndex === tuneToDelete.setIndex) {
                    // Cursor was in the deleted set, position at the beginning of next set or end
                    if (tuneToDelete.setIndex < tunePillsData.length) {
                        setCursorPosition(tuneToDelete.setIndex, 0, 'before');
                    } else if (tuneToDelete.setIndex > 0) {
                        // No next set, go to end of previous set
                        setCursorPosition(tuneToDelete.setIndex - 1, tunePillsData[tuneToDelete.setIndex - 1].length - 1, 'after');
                    } else {
                        // No sets left
                        setCursorPosition(0, 0, 'newset');
                    }
                } else {
                    // Cursor position is after deleted set, adjust index
                    setCursorPosition(newCursorPosition.setIndex - 1, newCursorPosition.pillIndex, newCursorPosition.position);
                }
            } else if (shouldCreateTemporaryEmpty) {
                // Set exists but is now empty (temporary empty set)
                // Position cursor at the beginning of the empty set
                setCursorPosition(newCursorPosition.setIndex, 0, 'before');
            } else {
                // Set still exists and has pills, use the calculated new cursor position
                if (newCursorPosition.pillIndex >= targetSet.length) {
                    // Position is beyond the end of the set, position after last pill
                    setCursorPosition(newCursorPosition.setIndex, targetSet.length - 1, 'after');
                } else if (newCursorPosition.pillIndex < 0) {
                    // Position is before the beginning, position before first pill
                    setCursorPosition(newCursorPosition.setIndex, 0, 'before');
                } else {
                    // Position is valid
                    setCursorPosition(newCursorPosition.setIndex, newCursorPosition.pillIndex, newCursorPosition.position);
                }
            }
        }
    }
    
    // Cursor movement functions
    function moveCursorLeft(shiftKey = false) {
        return CursorManager.moveCursorLeft(shiftKey);
    }
    
    function moveCursorLeftOld(shiftKey = false) {
        if (!cursorPosition) return;
        
        // If user is typing, finish typing first
        if (isTyping) {
            finishTyping();
        }
        
        // Remove temporary empty set if moving away from it
        if (removeTemporaryEmptySet()) {
            renderTunePills();
        }
        
        let { setIndex, pillIndex, position } = cursorPosition;
        
        // Set selection anchor if shift is pressed and we don't have one
        if (shiftKey && !selectionAnchor) {
            selectionAnchor = { setIndex, pillIndex };
        } else if (!shiftKey) {
            // Clear selection anchor if shift is not pressed
            selectionAnchor = null;
            PillSelection.selectNone();
        }
        
        
        let newSetIndex = setIndex;
        let newPillIndex = pillIndex;
        let newPosition = position;
        
        if (position === 'after' && pillIndex > 0) {
            // Move to 'after' the previous pill (which is the same as 'before' current pill)
            newPillIndex = pillIndex - 1;
            newPosition = 'after';
        } else if (position === 'after' && pillIndex === 0) {
            // At beginning of set, try to move to 'before' position if it exists
            newPillIndex = 0;
            newPosition = 'before';
        } else if (position === 'before' && pillIndex === 0 && setIndex > 0) {
            // Move to end of previous set
            const prevSetLength = tunePillsData[setIndex - 1].length;
            newSetIndex = setIndex - 1;
            newPillIndex = prevSetLength - 1;
            newPosition = 'after';
        } else {
            // Can't move further left
            return;
        }
        
        setCursorPosition(newSetIndex, newPillIndex, newPosition);
        
        // Handle selection if shift is pressed
        if (shiftKey && selectionAnchor) {
            // Select pills between anchor and new position based on cursor movement
            selectPillsBetweenCursorPositions(
                { setIndex: selectionAnchor.setIndex, pillIndex: selectionAnchor.pillIndex, position: 'after' },
                { setIndex: newSetIndex, pillIndex: newPillIndex, position: newPosition }
            );
        }
    }
    
    function moveCursorRight(shiftKey = false) {
        return CursorManager.moveCursorRight(shiftKey);
    }
    
    function moveCursorRightOld(shiftKey = false) {
        if (!cursorPosition) return;
        
        // If user is typing, finish typing first
        if (isTyping) {
            finishTyping();
        }
        
        // Remove temporary empty set if moving away from it
        if (removeTemporaryEmptySet()) {
            renderTunePills();
        }
        
        let { setIndex, pillIndex, position } = cursorPosition;
        
        // Set selection anchor if shift is pressed and we don't have one
        if (shiftKey && !selectionAnchor) {
            selectionAnchor = { setIndex, pillIndex };
        } else if (!shiftKey) {
            // Clear selection anchor if shift is not pressed
            selectionAnchor = null;
            PillSelection.selectNone();
        }
        
        
        let newSetIndex = setIndex;
        let newPillIndex = pillIndex;
        let newPosition = position;
        
        if (setIndex < tunePillsData.length) {
            const currentSetLength = tunePillsData[setIndex].length;
            
            if (position === 'before' && pillIndex === 0) {
                // Move to 'after' the same pill (first pill in set)
                newPosition = 'after';
            } else if (position === 'after' && pillIndex < currentSetLength - 1) {
                // Move to 'after' the next pill in same set
                newPillIndex = pillIndex + 1;
                newPosition = 'after';
            } else if (position === 'after' && pillIndex === currentSetLength - 1 && setIndex < tunePillsData.length - 1) {
                // Move to beginning of next set
                newSetIndex = setIndex + 1;
                newPillIndex = 0;
                newPosition = 'before';
            } else if (position === 'after' && pillIndex === currentSetLength - 1 && setIndex === tunePillsData.length - 1) {
                // Move to the very end (newset position)
                newSetIndex = tunePillsData.length;
                newPillIndex = 0;
                newPosition = 'newset';
            } else {
                // Can't move further right
                return;
            }
        } else {
            // Can't move further right
            return;
        }
        
        setCursorPosition(newSetIndex, newPillIndex, newPosition);
        
        // Handle selection if shift is pressed (but not for newset position)
        if (shiftKey && selectionAnchor && newPosition !== 'newset') {
            selectPillsBetweenPositions(selectionAnchor, { setIndex: newSetIndex, pillIndex: newPillIndex });
        }
    }
    
    function moveCursorUp(shiftKey = false) {
        return CursorManager.moveCursorUp(shiftKey);
    }
    
    function moveCursorUpOld(shiftKey = false) {
        // Move to previous set (line)
        if (!cursorPosition) return;
        
        let { setIndex, pillIndex, position } = cursorPosition;
        
        // Set selection anchor if shift is pressed and we don't have one
        if (shiftKey && !selectionAnchor) {
            selectionAnchor = { setIndex, pillIndex };
        } else if (!shiftKey) {
            // Clear selection anchor if shift is not pressed
            selectionAnchor = null;
            PillSelection.selectNone();
        }
        
        
        let newSetIndex = setIndex;
        let newPillIndex = pillIndex;
        let newPosition = position;
        
        // Handle special case: cursor is at "newset" position (very end)
        if (position === 'newset' && setIndex >= tunePillsData.length) {
            // Move to last set
            if (tunePillsData.length > 0) {
                const lastSetLength = tunePillsData[tunePillsData.length - 1].length;
                newSetIndex = tunePillsData.length - 1;
                newPillIndex = lastSetLength - 1;
                newPosition = 'after';
            } else {
                return;
            }
        } else if (setIndex > 0) {
            // Move to previous set, try to maintain similar position
            const prevSetLength = tunePillsData[setIndex - 1].length;
            
            if (prevSetLength === 0) {
                // Empty set, position at beginning
                newSetIndex = setIndex - 1;
                newPillIndex = 0;
                newPosition = 'before';
            } else {
                // Try to match position, but clamp to set bounds
                newSetIndex = setIndex - 1;
                newPillIndex = Math.min(pillIndex, prevSetLength - 1);
                newPosition = position;
            }
        } else {
            // Already at first set, do nothing
            return;
        }
        
        setCursorPosition(newSetIndex, newPillIndex, newPosition);
        
        // Handle selection if shift is pressed
        if (shiftKey && selectionAnchor) {
            // Select pills between anchor and new position based on cursor movement
            selectPillsBetweenCursorPositions(
                { setIndex: selectionAnchor.setIndex, pillIndex: selectionAnchor.pillIndex, position: 'after' },
                { setIndex: newSetIndex, pillIndex: newPillIndex, position: newPosition }
            );
        }
    }
    
    function moveCursorDown(shiftKey = false) {
        return CursorManager.moveCursorDown(shiftKey);
    }
    
    function moveCursorDownOld(shiftKey = false) {
        // Move to next set (line)
        if (!cursorPosition) return;
        
        let { setIndex, pillIndex, position } = cursorPosition;
        
        // Set selection anchor if shift is pressed and we don't have one
        if (shiftKey && !selectionAnchor) {
            selectionAnchor = { setIndex, pillIndex };
        } else if (!shiftKey) {
            // Clear selection anchor if shift is not pressed
            selectionAnchor = null;
            PillSelection.selectNone();
        }
        
        
        let newSetIndex = setIndex;
        let newPillIndex = pillIndex;
        let newPosition = position;
        
        if (setIndex < tunePillsData.length - 1) {
            // Move to next set, try to maintain similar position
            const nextSetLength = tunePillsData[setIndex + 1].length;
            
            if (nextSetLength === 0) {
                // Empty set, position at beginning
                newSetIndex = setIndex + 1;
                newPillIndex = 0;
                newPosition = 'before';
            } else {
                // Try to match position, but clamp to set bounds
                newSetIndex = setIndex + 1;
                newPillIndex = Math.min(pillIndex, nextSetLength - 1);
                newPosition = position;
            }
        } else if (setIndex === tunePillsData.length - 1) {
            // At last set, move to the "newset" position at the very end
            newSetIndex = tunePillsData.length;
            newPillIndex = 0;
            newPosition = 'newset';
        } else {
            // Already at very end (newset), do nothing
            return;
        }
        
        setCursorPosition(newSetIndex, newPillIndex, newPosition);
        
        // Handle selection if shift is pressed (but not for newset position)
        if (shiftKey && selectionAnchor && newPosition !== 'newset') {
            selectPillsBetweenPositions(selectionAnchor, { setIndex: newSetIndex, pillIndex: newPillIndex });
        }
    }
    
    // Event listeners setup
    function setupEventListeners() {
        // Container click to focus
        const tuneContainer = document.getElementById('tune-pills-container');
        tuneContainer.addEventListener('click', (e) => {
            
            // Don't handle clicks on tune pills or their children (they have their own handlers)
            if (e.target.closest('.tune-pill')) {
                return;
            }
            
            // Don't handle clicks on context menus
            if (e.target.closest('.tune-context-menu')) {
                return;
            }
            
            // Check if click is on a cursor position element (they handle themselves)
            if (e.target.classList.contains('cursor-position')) {
                return;
            }
            
            // Check if clicking on a tune-set - find the best cursor position
            if (e.target.classList.contains('tune-set')) {
                const setIndex = parseInt(e.target.dataset.setIndex);
                const rect = e.target.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const setWidth = rect.width;
                const setLength = tunePillsData[setIndex]?.length || 0;
                
                
                // Find the actual position of tune pills within the set
                const pillElements = e.target.querySelectorAll('.tune-pill');
                let bestPosition = null;
                let closestDistance = Infinity;
                
                // Check distance to each pill to find the closest cursor position
                pillElements.forEach((pill, pillIndex) => {
                    const pillRect = pill.getBoundingClientRect();
                    const pillCenterX = pillRect.left + pillRect.width / 2 - rect.left;
                    const pillEndX = pillRect.right - rect.left;
                    
                    // Distance to "before" position (left edge of pill)
                    const distanceToBefore = Math.abs(clickX - (pillRect.left - rect.left));
                    if (distanceToBefore < closestDistance) {
                        closestDistance = distanceToBefore;
                        bestPosition = { pillIndex, position: 'before' };
                    }
                    
                    // Distance to "after" position (right edge of pill)
                    const distanceToAfter = Math.abs(clickX - pillEndX);
                    if (distanceToAfter < closestDistance) {
                        closestDistance = distanceToAfter;
                        bestPosition = { pillIndex, position: 'after' };
                    }
                });
                
                // If click is beyond the last pill, always position at end
                if (pillElements.length > 0) {
                    const lastPillRect = pillElements[pillElements.length - 1].getBoundingClientRect();
                    const lastPillEnd = lastPillRect.right - rect.left;
                    if (clickX > lastPillEnd) {
                        bestPosition = { pillIndex: setLength - 1, position: 'after' };
                    }
                }
                
                // Fallback: if no pills or click is before first pill
                if (!bestPosition) {
                    bestPosition = { pillIndex: 0, position: 'before' };
                }
                
                
                // If user is typing, finish typing first
                if (isTyping) {
                    finishTyping();
                }
                
                // Clear selection and selection anchor when clicking to move cursor
                CursorManager.clearSelection();
                
                setCursorPosition(setIndex, bestPosition.pillIndex, bestPosition.position);
                return;
            }
            
            // For clicks in other empty space, set cursor at end
            
            // If user is typing, finish typing first
            if (isTyping) {
                finishTyping();
            }
            
            // Clear selection and selection anchor when clicking to move cursor
            CursorManager.clearSelection();
            
            setCursorPosition(tunePillsData.length, 0, 'newset');
        });
        
        // Mobile touch handling for container (cursor placement and scrolling)
        let containerTouchStart = null;
        let containerTouchMoved = false;
        
        tuneContainer.addEventListener('touchstart', (e) => {
            // Don't handle touches on tune pills (they have their own handlers)
            if (e.target.closest('.tune-pill')) {
                return;
            }
            
            // Don't handle touches on context menus or cursor positions
            if (e.target.closest('.tune-context-menu') || e.target.classList.contains('cursor-position')) {
                return;
            }
            
            containerTouchStart = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                time: Date.now(),
                target: e.target
            };
            containerTouchMoved = false;
        });
        
        tuneContainer.addEventListener('touchmove', (e) => {
            if (containerTouchStart) {
                containerTouchMoved = true;
                // Let browser handle scrolling
            }
        });
        
        tuneContainer.addEventListener('touchend', (e) => {
            if (!containerTouchStart) return;
            
            const touchDuration = Date.now() - containerTouchStart.time;
            
            // If it was a quick tap without movement, treat as cursor placement
            if (!containerTouchMoved && touchDuration < 500) {
                const touch = e.changedTouches[0];
                
                // Create a synthetic click event to reuse existing click logic
                const clickEvent = new MouseEvent('click', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true,
                    cancelable: true
                });
                
                // Set the target and trigger the existing click handler logic
                Object.defineProperty(clickEvent, 'target', { value: containerTouchStart.target });
                
                // Manually execute the cursor positioning logic
                if (containerTouchStart.target.classList.contains('tune-set')) {
                    const setIndex = parseInt(containerTouchStart.target.dataset.setIndex);
                    const rect = containerTouchStart.target.getBoundingClientRect();
                    const clickX = touch.clientX - rect.left;
                    const setWidth = rect.width;
                    const setLength = tunePillsData[setIndex]?.length || 0;
                    
                    // Find best cursor position (reusing click logic)
                    let bestPosition = null;
                    
                    if (setLength > 0) {
                        // Find position relative to pills
                        const relativePosition = clickX / setWidth;
                        const estimatedPillIndex = Math.floor(relativePosition * setLength);
                        const clampedIndex = Math.max(0, Math.min(setLength - 1, estimatedPillIndex));
                        
                        if (relativePosition < (clampedIndex + 0.5) / setLength) {
                            bestPosition = { pillIndex: clampedIndex, position: 'before' };
                        } else {
                            bestPosition = { pillIndex: clampedIndex, position: 'after' };
                        }
                        
                        if (relativePosition > 0.9) {
                            bestPosition = { pillIndex: setLength - 1, position: 'after' };
                        }
                    }
                    
                    if (!bestPosition) {
                        bestPosition = { pillIndex: 0, position: 'before' };
                    }
                    
                    // If user is typing, finish typing first
                    if (isTyping) {
                        finishTyping();
                    }
                    
                    // Clear selection when touching to move cursor
                    CursorManager.clearSelection();
                    
                    setCursorPosition(setIndex, bestPosition.pillIndex, bestPosition.position);
                } else {
                    // Touch in empty space - set cursor at end
                    if (isTyping) {
                        finishTyping();
                    }
                    
                    PillSelection.selectNone();
                    
                    setCursorPosition(tunePillsData.length, 0, 'newset');
                }
                
                e.preventDefault();
            }
            // If touch moved, allow normal scroll behavior (no preventDefault)
            
            containerTouchStart = null;
        });
        
        // Keyboard shortcuts and text input
        document.addEventListener('keydown', (e) => {
            if (e.target.closest('.modal-overlay')) return; // Don't handle if modal is open
            
            // Don't handle keyboard events if container is contentEditable (mobile typing mode)
            const container = document.getElementById('tune-pills-container');
            if (container && container.contentEditable === 'true') {
                return;
            }
            
            // Handle typing at cursor position
            if (!e.ctrlKey && !e.metaKey && CursorManager.getCursorPosition() && e.key.length === 1) {
                e.preventDefault();
                handleTextInput(e.key);
                return;
            }
            
            // Handle special keys for typing
            if (CursorManager.getCursorPosition() && !e.ctrlKey && !e.metaKey) {
                switch(e.key) {
                    case 'Backspace':
                        e.preventDefault();
                        handleBackspace();
                        return;
                    case 'Delete':
                        e.preventDefault();
                        handleDelete();
                        return;
                    case 'Enter':
                        e.preventDefault();
                        if (isTyping) {
                            finishTyping();
                        } else {
                            handleEnterKey();
                        }
                        return;
                    case 'Tab':
                    case ';':
                    case ',':
                        e.preventDefault();
                        finishTyping();
                        return;
                    case 'Escape':
                        e.preventDefault();
                        cancelTyping();
                        return;
                    case 'ArrowLeft':
                        e.preventDefault();
                        CursorManager.moveCursorLeft(e.shiftKey);
                        return;
                    case 'ArrowRight':
                        e.preventDefault();
                        CursorManager.moveCursorRight(e.shiftKey);
                        return;
                    case 'ArrowUp':
                        e.preventDefault();
                        CursorManager.moveCursorUp(e.shiftKey);
                        return;
                    case 'ArrowDown':
                        e.preventDefault();
                        CursorManager.moveCursorDown(e.shiftKey);
                        return;
                }
            }
            
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 'a':
                        e.preventDefault();
                        PillSelection.selectAll();
                        break;
                    case 'c':
                        e.preventDefault();
                        copySelectedPills();
                        break;
                    case 'x':
                        e.preventDefault();
                        cutSelectedPills();
                        break;
                    case 'v':
                        e.preventDefault();
                        pasteFromClipboard();
                        break;
                }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (PillSelection.hasSelection()) {
                    e.preventDefault();
                    PillSelection.deleteSelectedPills();
                }
            }
        });
        
        // Container drag and drop event listeners
        // (reusing container variable from above)
        
        tuneContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const position = findDropPosition(e.clientX, e.clientY);
            showDropIndicator(position);
        });
        
        tuneContainer.addEventListener('dragleave', (e) => {
            // Only clear if we're really leaving the container
            if (!tuneContainer.contains(e.relatedTarget)) {
                clearDropIndicators();
            }
        });
        
        tuneContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            clearDropIndicators();
            
            const position = findDropPosition(e.clientX, e.clientY);
            
            if (dragState) {
                // Internal drag and drop
                const draggedIds = Array.from(PillSelection.getSelectedPills());
                performDrop(position, draggedIds);
            } else {
                // External drag or paste
                try {
                    const dragData = JSON.parse(e.dataTransfer.getData('text/json'));
                    if (dragData && Array.isArray(dragData)) {
                        pasteAtPosition(dragData, position);
                    }
                } catch (err) {
                }
            }
        });
        
        // Modal event listeners
        document.getElementById('link-cancel-btn').addEventListener('click', hideLinkModal);
        document.getElementById('link-confirm-btn').addEventListener('click', confirmLink);
        document.getElementById('edit-tune-cancel-btn').addEventListener('click', hideEditModal);
        document.getElementById('edit-tune-save-btn').addEventListener('click', confirmEdit);
        
        // Close modals on escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideLinkModal();
                hideEditModal();
                hideSessionEditModal();
            }
        });
    }
    
    // Select all now directly calls PillSelection.selectAll()
    
    // Modal control functions
    function hideLinkModal() {
        document.getElementById('link-tune-modal').style.display = 'none';
        window.currentLinkingPill = null;
    }
    
    function hideEditModal() {
        document.getElementById('edit-tune-modal').style.display = 'none';
        window.currentEditingPill = null;
    }
    
    function confirmLink() {
        const input = document.getElementById('tune-link-input').value.trim();
        if (!input || !window.currentLinkingPill) return;
        
        // Extract tune ID from URL or use as is
        let tuneId = input;
        const urlMatch = input.match(/thesession\.org\/tunes\/(\d+)/);
        if (urlMatch) {
            tuneId = urlMatch[1];
        }
        
        if (!/^\d+$/.test(tuneId)) {
            showMessage('Please enter a valid tune ID or thesession.org URL', 'error');
            return;
        }
        
        saveToUndo();
        
        // Update the pill
        window.currentLinkingPill.tuneId = parseInt(tuneId);
        window.currentLinkingPill.state = 'linked';
        
        renderTunePills();
        hideLinkModal();
        
        showMessage('Tune linked successfully!', 'success');
    }
    
    function confirmEdit() {
        const newName = document.getElementById('edit-tune-name-input').value.trim();
        if (!newName || !window.currentEditingPill) return;
        
        saveToUndo();
        
        const pill = window.currentEditingPill;
        
        // Update the tune name
        pill.tuneName = newName;
        
        // Mark as dirty since we changed the pill
        AutoSaveManager.forceCheckChanges();
        
        // If the tune was linked, unlink it first and re-run matching
        if (pill.state === 'linked') {
            // Unlink the tune
            pill.tuneId = null;
            pill.setting = null;
            pill.tuneType = null;
            pill.state = 'loading';  // Show loading state while re-matching
            
            // Update the pill appearance immediately to show loading state
            updatePillAppearance(pill);
            
            // Re-run auto-matching with the new name
            autoMatchTune(pill);
        } else {
            // If it was unlinked, still try to match the new name
            pill.state = 'loading';
            updatePillAppearance(pill);
            autoMatchTune(pill);
        }
        
        hideEditModal();
        showMessage('Tune name updated!', 'success');
    }
    
    // Session edit functionality (reused from original)
    function setupSessionEditListeners() {
        document.getElementById('edit-date-btn').addEventListener('click', showEditSessionModal);
        document.getElementById('edit-session-cancel-btn').addEventListener('click', hideSessionEditModal);
        document.getElementById('edit-session-save-btn').addEventListener('click', saveSessionInstance);
    }
    
    function setupSaveListeners() {
        // Save button click
        document.getElementById('save-session-btn').addEventListener('click', () => AutoSaveManager.saveSession());
        
        // Auto-save checkbox change
        document.getElementById('auto-save-checkbox').addEventListener('change', () => AutoSaveManager.setupAutoSave());
        
        // Auto-save interval change
        document.getElementById('auto-save-interval').addEventListener('change', () => {
            if (document.getElementById('auto-save-checkbox').checked) {
                AutoSaveManager.setupAutoSave();
            }
        });
        
        // Cancel auto-save link
        document.getElementById('cancel-auto-save').addEventListener('click', (e) => {
            e.preventDefault();
            AutoSaveManager.cancelAutoSave();
        });
    }
    
    function showEditSessionModal() {
        const modal = document.getElementById('edit-session-instance-modal');
        const dateInput = document.getElementById('edit-session-date-input');
        const locationInput = document.getElementById('edit-session-location-input');
        const commentsInput = document.getElementById('edit-session-comments-input');
        const cancelledInput = document.getElementById('edit-session-cancelled-input');
        
        dateInput.value = sessionInstanceData.date;
        locationInput.value = sessionInstanceData.location_override || '';
        commentsInput.value = sessionInstanceData.comments || '';
        cancelledInput.checked = sessionInstanceData.is_cancelled;
        
        modal.style.display = 'flex';
        dateInput.focus();
    }
    
    function hideSessionEditModal() {
        document.getElementById('edit-session-instance-modal').style.display = 'none';
    }
    
    function saveSessionInstance() {
        const dateInput = document.getElementById('edit-session-date-input');
        const locationInput = document.getElementById('edit-session-location-input');
        const commentsInput = document.getElementById('edit-session-comments-input');
        const cancelledInput = document.getElementById('edit-session-cancelled-input');
        
        const date = dateInput.value.trim();
        const location = locationInput.value.trim();
        const comments = commentsInput.value.trim();
        const cancelled = cancelledInput.checked;
        
        if (!date) {
            showMessage('Please enter a session date', 'error');
            return;
        }
        
        const requestData = { 
            date: date,
            cancelled: cancelled
        };
        
        if (location) requestData.location = location;
        if (comments) requestData.comments = comments;
        
        fetch(`/api/sessions/${sessionPath}/${sessionDate}/update`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(data.message);
                hideSessionEditModal();
                if (date !== sessionDate) {
                    window.location.href = `/sessions/${sessionPath}/${date}/beta`;
                } else {
                    window.location.reload();
                }
            } else {
                showMessage(data.message, 'error');
            }
        })
        .catch(error => {
            showMessage('Failed to update session instance', 'error');
            console.error('Error:', error);
        });
    }
    
    // Message display function - uses the existing base template flash message system
    function showMessage(message, type = 'success') {
        // Remove any existing messages first
        const existingMessages = document.querySelectorAll('.message');
        existingMessages.forEach(msg => msg.remove());
        
        // Create message element using the base template's existing styles
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = message;
        
        // Add to body (the base template styles handle positioning)
        document.body.appendChild(messageDiv);
        
        // Trigger the slide-in animation using the base template's .show class
        setTimeout(() => {
            messageDiv.classList.add('show');
        }, 50);
        
        // Auto-hide after 4 seconds
        setTimeout(() => {
            messageDiv.classList.remove('show');
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 300);
        }, 4000);
    }
    
    // Mark complete link event listener (if link exists)
    const markCompleteLink = document.getElementById('mark-complete-link');
    if (markCompleteLink) {
        markCompleteLink.addEventListener('click', function(event) {
            event.preventDefault();
            markSessionLogComplete();
        });
    }
    
    // Mark incomplete link event listener (if link exists)
    const markIncompleteLink = document.getElementById('mark-incomplete-link');
    if (markIncompleteLink) {
        markIncompleteLink.addEventListener('click', function(event) {
            event.preventDefault();
            markSessionLogIncomplete();
        });
    }
    
    function markSessionLogComplete() {
        if (!confirm('Mark this session log as complete? This will switch to view mode and hide the edit button from non-admins.')) {
            return;
        }
        
        fetch(`/api/sessions/${sessionPath}/${sessionDate}/mark_complete`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(data.message);
                // Redirect to normal view after a short delay
                setTimeout(() => {
                    window.location.href = `/sessions/${sessionPath}/${sessionDate}`;
                }, 1500);
            } else {
                showMessage(data.message, 'error');
            }
        })
        .catch(error => {
            showMessage('Failed to mark session log complete', 'error');
            console.error('Error:', error);
        });
    }
    
    function markSessionLogIncomplete() {
        if (!confirm('Mark this session log as not complete? This will allow all users to edit it again.')) {
            return;
        }
        
        fetch(`/api/sessions/${sessionPath}/${sessionDate}/mark_incomplete`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(data.message);
                // Reload the page to show updated status
                setTimeout(() => {
                    window.location.href = `/sessions/${sessionPath}/${sessionDate}/beta`;
                }, 1500);
            } else {
                showMessage(data.message, 'error');
            }
        })
        .catch(error => {
            showMessage('Failed to mark session log as not complete', 'error');
            console.error('Error:', error);
        });
    }
</script>
{% endblock %}