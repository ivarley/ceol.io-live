{% extends "base.html" %}

{% block title %}{{ session_instance.session_name }} - {{ session_instance.date }} - Irish Music Session Details (Beta){% endblock %}

{% block extra_css %}
<style>
        .hidden {
            display: none;
        }
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .loading-ellipsis {
            display: inline-block;
            color: var(--disabled-text);
        }
        .loading-ellipsis:after {
            content: '...';
            animation: ellipsis 1.5s infinite;
            width: 1em;
            text-align: left;
            display: inline-block;
        }
        @keyframes ellipsis {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .cancelled-date {
            color: var(--danger, #dc3545);
            text-decoration: line-through;
        }
        .cancelled-message {
            padding: 20px;
            background-color: var(--light);
            border-left: 4px solid var(--danger, #dc3545);
            margin: 20px 0;
            color: var(--text-color);
            font-style: italic;
        }
        
        /* Force header to stay fixed even when contentEditable is active */
        .header.fixed-top {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 9999 !important;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        .edit-link {
            color: var(--primary);
            text-decoration: none;
            margin-left: 15px;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            cursor: pointer;
            vertical-align: middle;
        }
        .edit-link:hover {
            text-decoration: underline;
        }
        .editable-header:hover .edit-link {
            opacity: 1;
        }
        
        /* Beta Editor Styles */
        .tune-pills-container {
            min-height: 200px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
            background: var(--bg-color, white);
            line-height: 1.8;
            font-size: 16px;
            cursor: text;
            position: relative;
            transition: border-color 0.2s ease;
        }
        
        .tune-pills-container:hover {
            border-color: var(--primary);
        }
        
        .tune-pills-container:focus-within {
            border-color: var(--primary);
            outline: none;
        }
        
        .tune-set {
            margin-bottom: 2px;
            min-height: 18px;
        }
        
        .tune-set:last-child {
            margin-bottom: 0;
        }
        
        .tune-pill {
            display: inline-block;
            margin: 2px;
            padding: 0px 9px;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            user-select: none;
            vertical-align: middle;
            line-height: 21px;
        }
        
        .tune-pill.unlinked {
            background-color: var(--secondary, #6c757d);
            color: white;
            border: 1px solid var(--secondary, #6c757d);
        }
        
        .tune-pill.unmatched {
            background-color: var(--danger, #dc3545);
            color: white;
            border: 1px solid var(--danger, #dc3545);
        }
        
        .tune-pill.loading {
            background-color: #e9ecef;
            color: #6c757d;
            border: 1px solid #e9ecef;
        }
        
        .tune-pill.linked {
            background-color: var(--primary, #007bff);
            color: white;
            border: 1px solid var(--primary, #007bff);
        }
        
        .tune-pill.error {
            background-color: var(--warning, #ffc107);
            color: var(--dark, #212529);
            border: 1px solid var(--warning, #ffc107);
        }
        
        .tune-pill.selected {
            box-shadow: 0 0 0 2px var(--primary);
            background-color: rgba(0, 122, 255, 0.1);
        }
        
        .tune-pill.dragging {
            opacity: 0.5;
            box-shadow: 0 0 0 2px #007AFF;
            position: relative;
            z-index: 1000;
        }
        
        /* Drop indicators - color only, no size changes */
        .tune-pill.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.1) !important;
            position: relative;
        }
        
        /* Show drop position indicator on right side of pill */
        .tune-pill.mobile-drop-target.drop-after::after {
            content: '';
            position: absolute;
            right: -2px;
            top: 2px;
            bottom: 2px;
            width: 3px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 10;
        }
        
        /* Show drop position indicator on left side of pill */
        .tune-pill.mobile-drop-target.drop-before::before {
            content: '';
            position: absolute;
            left: -2px;
            top: 2px;
            bottom: 2px;
            width: 3px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 10;
        }
        
        .horizontal-drop-zone.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.3) !important;
        }
        
        .tune-set.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.05) !important;
        }
        
        /* Tune-set with blank space drop gets brighter highlighting */
        .tune-set.mobile-drop-target.drop-at-end {
            background-color: rgba(0, 122, 255, 0.3) !important;
            position: relative;
        }
        
        /* Position indicator for blank space drops in tune-sets - vertical bar at end of row */
        .tune-set.mobile-drop-target.drop-at-end::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 30px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 1000;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 4px rgba(0, 122, 255, 0.5);
        }
        
        /* Tune-set with gap drop gets brighter highlighting */
        .tune-set.mobile-drop-target.drop-in-gap {
            background-color: rgba(0, 122, 255, 0.3) !important;
            position: relative;
        }
        
        /* Position indicator for gap drops - vertical bar between pills */
        .tune-set.mobile-drop-target.drop-in-gap::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 30px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 1000;
            left: var(--gap-indicator-left, 12px);
            top: var(--gap-indicator-top, 8px);
            box-shadow: 0 0 4px rgba(0, 122, 255, 0.5);
        }
        
        #tune-pills-container.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.3) !important;
            position: relative;
        }
        
        /* Position indicator for blank space drops - vertical bar at insertion point */
        #tune-pills-container.mobile-drop-target.drop-at-end::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 60px;
            background-color: #007AFF;
            border-radius: 2px;
            z-index: 1000;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 4px rgba(0, 122, 255, 0.5);
        }
        
        /* Ensure dark mode doesn't override */
        [data-theme="dark"] #tune-pills-container.mobile-drop-target {
            background-color: rgba(0, 122, 255, 0.3) !important;
        }
        
        .tune-pill.just-landed {
            background-color: #ffc107 !important;
            border-color: #ffc107 !important;
            box-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
            animation: landingGlow 3s ease-out forwards;
        }
        
        /* Loading spinner for pills waiting for API response */
        .tune-pill .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(108, 117, 125, 0.3);
            border-top: 2px solid #6c757d;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes landingGlow {
            0% {
                background-color: #ffc107 !important;
                border-color: #ffc107 !important;
                box-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
            }
            100% {
                background-color: var(--primary, #007bff) !important;
                border-color: var(--primary, #007bff) !important;
                box-shadow: none;
            }
        }
        
        .tune-pill .chevron {
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            border-left: 5px solid currentColor;
            opacity: 0.7;
            transition: transform 0.2s ease;
        }
        
        .tune-pill .chevron.open {
            transform: translateY(-50%) rotate(90deg);
        }
        
        .tune-pill .text {
            margin-left: 10px;
        }
        
        /* Legacy drop-indicator - kept for backwards compatibility but hidden */
        .drop-indicator {
            display: none;
        }
        
        .horizontal-drop-zone {
            height: 12px;
            width: 100%;
            margin: 0px 0;
            position: relative;
            cursor: text;
            /* Removed transition to prevent flickering */
        }
        
        .horizontal-drop-zone:hover {
            background-color: rgba(0, 123, 255, 0.08);
        }
        
        .horizontal-drop-zone.drag-over {
            background-color: rgba(0, 123, 255, 0.15);
        }
        
        .horizontal-drop-zone.drag-over::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 2px;
            background-color: var(--primary);
            border-radius: 1px;
            transform: translateY(-50%);
        }
        
        .text-cursor {
            display: inline-block;
            width: 2px;
            height: 21px;
            background-color: var(--primary, #007bff);
            animation: blink 1s infinite;
            vertical-align: middle;
            margin: 0 1px;
            position: relative;
            top: -5px;
            z-index: 10;
            border-radius: 1px;
            box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .cursor-position {
            display: inline-block;
            width: 0;
            height: 21px;
            position: relative;
            vertical-align: middle;
            background-color: transparent;
            cursor: text;
            padding: 0 3px; /* Create hover area without affecting layout */
            margin: 0;
            overflow: visible; /* Allow content to extend beyond boundaries */
        }
        
        .cursor-position:hover::before {
            content: '';
            position: absolute;
            left: 3px;
            top: -5px;
            width: 2px;
            height: 21px;
            background-color: rgba(0, 123, 255, 0.4);
            border-radius: 1px;
        }
        
        /* Show drop indicator when dragging */
        .cursor-position.drop-active::before {
            content: '';
            position: absolute;
            left: 3px;
            top: -2px;
            width: 3px;
            height: 21px;
            background-color: var(--primary, #007AFF);
            border-radius: 1px;
            opacity: 1;
        }
        
        .text-input {
            display: inline-block;
            min-width: 200px;
            border: 2px solid var(--primary);
            outline: none;
            background: var(--bg-color, white);
            font-family: inherit;
            font-size: inherit;
            color: var(--text-color);
            vertical-align: middle;
            margin: 2px;
            padding: 4px 8px;
            border-radius: 4px;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        
        .tune-context-menu {
            position: absolute;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1500;
            font-size: 14px;
            color: var(--text-color);
            white-space: nowrap;
            display: none;
            min-width: 120px;
            pointer-events: auto;
            touch-action: manipulation;
        }
        
        .tune-context-menu a {
            display: block;
            padding: 8px 12px;
            text-decoration: none;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
        }
        
        .tune-context-menu a:hover {
            background-color: var(--hover-bg);
            color: var(--primary);
        }
        
        .tune-context-menu .menu-section {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 4px;
            padding-bottom: 4px;
        }
        
        .tune-context-menu .menu-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Dark mode adjustments */
        [data-theme="dark"] .tune-pills-container {
            background: var(--bg-color);
            border-color: var(--border-color);
        }
        
        [data-theme="dark"] .tune-context-menu {
            background: var(--dropdown-bg);
            border-color: var(--border-color);
            color: var(--text-color);
        }
        
        [data-theme="dark"] .tune-context-menu a {
            color: var(--text-color);
        }
        
        [data-theme="dark"] .tune-context-menu a:hover {
            background-color: var(--hover-bg);
            color: var(--primary);
        }
        
        /* Modals for linking and editing tunes */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--bg-color, white);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            color: var(--text-color);
        }
        
        .modal-header {
            margin-bottom: 16px;
        }
        
        .modal-header h3 {
            margin: 0;
            color: var(--text-color);
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .modal-body label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color);
        }
        
        .modal-body input, .modal-body textarea, .modal-body select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        .modal-footer {
            text-align: right;
        }
        
        .modal-footer button {
            margin-left: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .modal-footer .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        
        .modal-footer .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }
        
        .modal-footer button:hover {
            opacity: 0.9;
        }
        
        /* Save button disabled state */
        #save-session-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: var(--disabled-bg, #ccc) !important;
        }
        
        #save-session-btn:not(:disabled):hover {
            opacity: 0.9;
        }
        
        /* Auto-save countdown styling */
        #auto-save-countdown {
            color: #c3e6cb; /* Light green, subtle in light mode */
        }
        
        [data-theme="dark"] #auto-save-countdown {
            color: #3d4f42; /* Dark grey-green, subtle in dark mode */
        }
        
        /* Cancel link inherits color from parent countdown text */
        #cancel-auto-save {
            color: inherit;
            font-style: inherit;
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .save-controls-container {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 10px !important;
            }
            
            #save-session-btn .desktop-text {
                display: none;
            }
            #save-session-btn .mobile-text {
                display: inline;
            }
            
            
            .inactivity-text {
                display: none;
            }
            
            .countdown-desktop {
                display: none;
            }
            .countdown-mobile {
                display: inline;
            }
            
            .cancel-desktop {
                display: none;
            }
            .cancel-mobile {
                display: inline;
            }
            
            #auto-save-countdown {
                margin-left: 0 !important;
                margin-top: 5px;
                width: 100%;
            }
            
            /* Only force block display when countdown should be visible */
            #auto-save-countdown[style*="display: inline"] {
                display: block !important;
            }
        }
        
        /* Desktop default - hide mobile elements */
        @media (min-width: 769px) {
            #save-session-btn .mobile-text {
                display: none;
            }
            #save-session-btn .desktop-text {
                display: inline;
            }
            
            .auto-save-interval-mobile {
                display: none;
            }
            .auto-save-interval-desktop {
                display: block;
            }
            
            .countdown-mobile {
                display: none;
            }
            .countdown-desktop {
                display: inline;
            }
            
            .cancel-mobile {
                display: none;
            }
            .cancel-desktop {
                display: inline;
            }
        }
    </style>
{% endblock %}

{% block content %}
<div class="landing-page" style="display: block;">

    <h1>{{ session_instance.session_name }}</h1>
    <h2 class="editable-header{% if session_instance.is_cancelled %} cancelled-date{% endif %}">{{ session_instance.date }}<span class="edit-link" id="edit-date-btn">Edit</span></h2>
    
    {% if session_instance.location_override %}
    <p style="margin: 10px 0; color: var(--disabled-text); font-style: italic;">
        <strong>Note</strong> - actual location of this session: {{ session_instance.location_override }}
    </p>
    {% endif %}
    
    <div id="message-container">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
                <div class="message success">
                    {% for message in messages %}
                        <p>{{ message }}</p>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}
    </div>
    
    <!-- Beta Mode Indicator -->
    <div style="background-color: var(--warning-bg, #fff3cd); border: 1px solid var(--warning, #ffc107); border-radius: 4px; padding: 12px; margin: 20px 0; color: var(--text-color);">
        <strong>🧪 Beta Editor Mode</strong> - This is the experimental tune pill editor. <a href="/sessions/{{ session_instance.session_path }}/{{ session_instance.date }}">Switch to normal view</a>
    </div>
    
    <!-- Link Tune Modal -->
    <div id="link-tune-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Link Tune</h3>
            </div>
            <div class="modal-body">
                <p>Enter a URL or tune ID from thesession.org to link for this name:</p>
                <label for="tune-link-input">Tune ID or URL:</label>
                <input type="text" id="tune-link-input" placeholder="e.g. 1234 or https://thesession.org/tunes/1234">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="link-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="link-confirm-btn">Link</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Tune Modal -->
    <div id="edit-tune-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Tune</h3>
            </div>
            <div class="modal-body">
                <label for="edit-tune-name-input">Tune Name:</label>
                <input type="text" id="edit-tune-name-input" placeholder="Enter tune name">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="edit-tune-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="edit-tune-save-btn">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Session Instance Modal -->
    <div id="edit-session-instance-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Session Instance</h3>
            </div>
            <div class="modal-body">
                <label for="edit-session-date-input">Session Date:</label>
                <input type="date" id="edit-session-date-input" required>
                
                <label for="edit-session-location-input" style="margin-top: 16px;">Location:</label>
                <input type="text" id="edit-session-location-input" placeholder="The usual: {{ session_instance.session_name }}">
                
                <label for="edit-session-comments-input" style="margin-top: 16px;">Comments:</label>
                <textarea id="edit-session-comments-input" placeholder="Notes about this session" rows="3" style="resize: vertical;"></textarea>
                
                <div style="margin-top: 16px;">
                    <label style="display: flex; align-items: center; font-weight: normal;">
                        <input type="checkbox" id="edit-session-cancelled-input" style="margin-right: 8px; width: auto;">
                        Cancelled?
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="edit-session-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="edit-session-save-btn">Save</button>
            </div>
        </div>
    </div>
    
    {% if session_instance.comments %}
    <div class="session-instance-comments">
        <h3>Notes from this session:</h3>
        <p>{{ session_instance.comments }}</p>
    </div>
    {% endif %}
    
    {% if session_instance.is_cancelled %}
    <div class="cancelled-message">
        <strong>This session instance was cancelled.</strong>
    </div>
    {% else %}
    <div id="tunes-container">
        <h3>Tunes Played:</h3>
        <div id="tune-pills-container" class="tune-pills-container" tabindex="0" role="textbox" aria-label="Tune editor">
            <!-- Tune pills will be rendered here -->
        </div>
    </div>
    
    <!-- Save Controls -->
    <div class="save-controls-container" style="display: flex; align-items: center; gap: 15px; margin: 20px 0; padding: 15px; background-color: var(--light); border-radius: 4px;">
        <button id="save-session-btn" class="btn-primary" style="padding: 10px 20px; background-color: var(--primary); color: white; border: none; border-radius: 4px; cursor: pointer; transition: opacity 0.2s ease, background-color 0.2s ease;" disabled>
            <span class="desktop-text">Save Session</span>
            <span class="mobile-text">Save</span>
        </button>
        <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="auto-save-checkbox" style="cursor: pointer;">
            <label for="auto-save-checkbox" style="margin: 0; cursor: pointer;">Auto-save after</label>
            <select id="auto-save-interval" style="padding: 5px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--bg-color); color: var(--text-color);">
                <option value="10">10 seconds</option>
                <option value="30">30 seconds</option>
                <option value="60" selected>60 seconds</option>
            </select>
            <span style="margin: 0;" class="inactivity-text">of inactivity</span>
        </div>
        <span id="auto-save-countdown" style="font-style: italic; display: none; margin-left: 8px;">
            <span class="countdown-desktop">Saving in <span id="countdown-seconds" style="display: inline-block; width: 2ch; text-align: right;">60</span> seconds... </span>
            <span class="countdown-mobile">Saving in <span id="countdown-seconds-mobile" style="display: inline-block; width: 2ch; text-align: right;">60</span> seconds... </span>
            <a href="#" id="cancel-auto-save" style="text-decoration: underline; cursor: pointer;">
                <span class="cancel-desktop">Cancel</span>
                <span class="cancel-mobile">cancel</span>
            </a>
        </span>
        <span id="save-status" style="color: var(--success, #28a745); font-style: italic; display: none;"></span>
    </div>
    {% endif %}
    
    {% if session_instance.log_complete_date and is_session_admin %}
    <div style="margin-top: 20px;">
        <p style="color: var(--disabled-text); font-style: italic;">
            This session was marked complete on {{ session_instance.log_complete_date.strftime('%Y-%m-%d') if session_instance.log_complete_date else '' }}.
        </p>
        <a href="#" id="mark-incomplete-link" style="color: var(--warning, #ffc107); text-decoration: none; font-size: 14px;">Mark this session as not complete</a>
    </div>
    {% elif not session_instance.log_complete_date and is_session_admin %}
    <div style="margin-top: 20px;">
        <a href="#" id="mark-complete-link" style="color: var(--primary); text-decoration: none; font-size: 14px;">Mark this session log complete</a>
    </div>
    {% elif session_instance.log_complete_date and not is_session_admin %}
    <div style="margin-top: 20px;">
        <p style="color: var(--disabled-text); font-style: italic;">
            This session was marked complete on {{ session_instance.log_complete_date.strftime('%Y-%m-%d') if session_instance.log_complete_date else '' }}.
        </p>
    </div>
    {% endif %}
    
    <p><a href="/sessions/{{ session_instance.session_path }}">← Back to this session</a></p>
</div>
{% endblock %}

{% block extra_js %}
<script src="/static/js/components/autoSave.js"></script>
<script src="/static/js/components/stateManager.js"></script>
<script src="/static/js/components/cursorManager.js"></script>
<script src="/static/js/components/pillRenderer.js"></script>
<script src="/static/js/components/pillSelection.js"></script>
<script src="/static/js/components/pillInteraction.js"></script>
<script src="/static/js/components/dragDrop.js"></script>
<script src="/static/js/components/textInput.js"></script>
<script src="/static/js/components/modalManager.js"></script>
<script src="/static/js/components/keyboardHandler.js"></script>
<script src="/static/js/components/undoRedoManager.js"></script>
<script src="/static/js/components/clipboardManager.js"></script>
<script>
    const sessionPath = '{{ session_instance.session_path }}';
    const sessionDate = '{{ session_instance.date }}';
    const isCancelled = {{ 'true' if session_instance.is_cancelled else 'false' }};
    const isSessionAdmin = {{ 'true' if is_session_admin else 'false' }};
    const isLogComplete = {{ 'true' if session_instance.log_complete_date else 'false' }};
    
    // Session instance data for editing
    const sessionInstanceData = {
        date: '{{ session_instance.date }}',
        location_override: {{ session_instance.location_override|tojson if session_instance.location_override else 'null' }},
        default_location: {{ session_instance.default_location|tojson if session_instance.default_location else 'null' }},
        comments: {{ session_instance.comments|tojson if session_instance.comments else 'null' }},
        is_cancelled: {{ 'true' if session_instance.is_cancelled else 'false' }}
    };
    
    // Beta Editor State - core data now managed by StateManager
    // selectedPills now fully managed by PillSelection module
    // dragState now managed by DragDrop module
    // cursorPosition now managed by CursorManager - keep reference for backward compatibility
    let cursorPosition = null;
    
    // Core data array - will be replaced by StateManager calls
    let tunePillsData = [];
    
    // Save state tracking - now managed by AutoSaveManager
    
    // State change tracking now handled directly by AutoSaveManager
    
    // Text input handling now managed by TextInput module
    let textInput = null;
    
    // Global mobile drag ghost management now handled by DragDrop module
    
    // Drag ghost cleanup now handled by DragDrop module
    

    // Save functionality - now handled directly by AutoSaveManager
    
    // AutoSave functions now handled directly by AutoSaveManager module
    
    // Initialize the editor on page load
    document.addEventListener('DOMContentLoaded', function() {
        if (!isCancelled) {
            // Initialize StateManager with change callback
            StateManager.initialize(() => {
                tunePillsData = StateManager.getTunePillsData();
                AutoSaveManager.forceCheckChanges();
            });
            
            // Initialize CursorManager 
            CursorManager.initialize({
                getStateManager: () => StateManager,
                onCursorChange: (newPosition) => {
                    // Update global reference for backward compatibility
                    cursorPosition = newPosition;
                },
                onSelectionChange: () => {
                    PillSelection.updateSelectionDisplay();
                }
            });
            
            // Initialize TextInput module
            textInput = new TextInput();
            
            // Register callbacks that CursorManager needs
            CursorManager.registerCallbacks({
                finishTyping: (keepKeyboard) => textInput.finishTyping(keepKeyboard),
                removeTemporaryEmptySet: () => removeTemporaryEmptySet(),
                renderTunePills: () => PillRenderer.renderTunePills(),
                handleTextInput: (char) => textInput.handleTextInput(char),
                handleBackspace: () => textInput.handleBackspace()
            });
            
            // Set typing-related variables that CursorManager needs access to
            CursorManager.isTyping = () => textInput.typing;
            CursorManager.typingBuffer = () => textInput.buffer;
            CursorManager.isKeepingKeyboardOpen = () => textInput.keepingKeyboardOpen;
            
            // Initialize PillRenderer
            PillRenderer.initialize({
                getStateManager: () => StateManager,
                getCursorManager: () => CursorManager,
                getAutoSaveManager: () => AutoSaveManager
            });
            
            // Register callbacks that PillRenderer needs
            PillRenderer.registerCallbacks({
                cleanupDragGhosts: () => DragDrop.cleanupDragGhosts(),
                createHorizontalDropZone: (setIndex) => DragDrop.createHorizontalDropZone(setIndex),
                setupPillEventListeners: (pillElement, pillData) => DragDrop.setupPillEventListeners(pillElement, pillData),
                setCursorPosition: (setIndex, pillIndex, positionType, maintainKeyboard) => CursorManager.setCursorPosition(setIndex, pillIndex, positionType, maintainKeyboard),
                clearSelection: () => CursorManager.clearSelection()
            });
            
            // Initialize PillSelection
            PillSelection.initialize({
                getStateManager: () => StateManager,
                getAutoSaveManager: () => AutoSaveManager,
                onSelectionChange: () => {
                    PillSelection.updateSelectionDisplay();
                }
            });
            
            // Register callbacks that PillSelection needs
            PillSelection.registerCallbacks({
                renderTunePills: () => PillRenderer.renderTunePills(),
                saveToUndo: () => undoRedoManager.saveToUndo(),
                showMessage: (message, type) => showMessage(message, type)
            });
            
            // Initialize PillInteraction
            PillInteraction.initialize({
                getPillSelection: () => PillSelection,
                getStateManager: () => StateManager,
                getCursorManager: () => CursorManager,
                getDragDrop: () => DragDrop,
                showContextMenu: (e, pillData) => showContextMenu(e, pillData),
                hideContextMenu: (pillId) => hideContextMenu(pillId),
                isTyping: () => textInput.typing,
                finishTyping: () => textInput.finishTyping()
            });
            
            // Initialize DragDrop
            DragDrop.initialize({
                getPillSelection: () => PillSelection,
                getStateManager: () => StateManager,
                getCursorManager: () => CursorManager,
                getPillInteraction: () => PillInteraction
            });
            
            // Register callbacks that DragDrop needs
            DragDrop.registerCallbacks({
                performDrop: (position, draggedIds) => performDrop(position, draggedIds),
                dropStructuredSetsAtNewPosition: (dragData, targetSetIndex) => dropStructuredSetsAtNewPosition(dragData, targetSetIndex),
                pasteAtPosition: (dragData, position) => clipboardManager.pasteAtPosition(dragData, position),
                saveToUndo: () => undoRedoManager.saveToUndo(),
                showContextMenu: (e, pillData) => showContextMenu(e, pillData),
                hideContextMenu: (pillId) => hideContextMenu(pillId),
                applyLandingAnimation: (movedPillIds) => PillRenderer.applyLandingAnimation(movedPillIds),
                setCursorPosition: (setIndex, pillIndex, positionType, maintainKeyboard) => CursorManager.setCursorPosition(setIndex, pillIndex, positionType, maintainKeyboard),
                clearSelection: () => CursorManager.clearSelection()
            });
            
            // Initialize UndoRedoManager
            undoRedoManager.initialize({
                getStateManager: () => StateManager,
                getAutoSaveManager: () => AutoSaveManager
            });
            
            // Register callbacks that UndoRedoManager needs
            undoRedoManager.registerCallbacks({
                onUndoRedo: () => {
                    tunePillsData = StateManager.getTunePillsData();
                    PillRenderer.renderTunePills();
                }
            });
            
            // Initialize ClipboardManager
            clipboardManager.initialize({
                getPillSelection: () => PillSelection,
                getCursorManager: () => CursorManager,
                getStateManager: () => StateManager
            });
            
            // Register callbacks that ClipboardManager needs
            clipboardManager.registerCallbacks({
                saveToUndo: () => undoRedoManager.saveToUndo(),
                generateId: () => StateManager.generateId(),
                renderTunePills: () => PillRenderer.renderTunePills(),
                showMessage: (message, type) => showMessage(message, type),
                applyLandingAnimation: (pillIds) => PillRenderer.applyLandingAnimation(pillIds),
                autoMatchTune: (pill) => autoMatchTune(pill),
                updatePillAppearance: (pill) => PillRenderer.updatePillAppearance(pill),
                showMatchingResults: (pills) => showMatchingResults(pills)
            });
            
            // Initialize KeyboardHandler
            KeyboardHandler.initialize({
                getCursorManager: () => CursorManager,
                getPillSelection: () => PillSelection,
                isTyping: () => textInput.typing,
                getModalManager: () => ModalManager
            });
            
            // Register callbacks that KeyboardHandler needs
            KeyboardHandler.registerCallbacks({
                handleTextInput: (char) => textInput.handleTextInput(char),
                handleBackspace: () => textInput.handleBackspace(),
                handleDelete: () => textInput.handleDelete(),
                handleEnterKey: () => textInput.handleEnterKey(),
                finishTyping: () => textInput.finishTyping(),
                cancelTyping: () => textInput.cancelTyping(),
                undo: () => undoRedoManager.undo(),
                redo: () => undoRedoManager.redo(),
                copySelectedPills: () => clipboardManager.copySelectedPills(),
                cutSelectedPills: () => clipboardManager.cutSelectedPills(),
                pasteFromClipboard: () => clipboardManager.pasteFromClipboard(),
                hideLinkModal: () => hideLinkModal(),
                hideEditModal: () => hideEditModal(),
                hideSessionEditModal: () => hideSessionEditModal(),
                confirmLink: () => confirmLink(),
                confirmEdit: () => confirmEdit(),
                removeTypingMatchResults: () => removeTypingMatchResults()
            });
            
            // Convert server-side tune sets data to pills format
            const initialTuneSets = {{ tune_sets|tojson }};
            convertTuneSetsToPills(initialTuneSets, true); // Skip callback during initialization
            PillRenderer.renderTunePills();
            setupEventListeners();
            
            // Initialize AutoSaveManager after tunePillsData is created
            AutoSaveManager.initialize(sessionPath, sessionDate, () => StateManager.getTunePillsData(), {
                isUserLoggedIn: {{ 'true' if current_user.is_authenticated else 'false' }},
                userAutoSave: {{ 'true' if current_user.auto_save_tunes else 'false' }}
            });
            
            // Initialize save state - mark as clean since we just loaded
            const currentData = StateManager.getTunePillsData();
            AutoSaveManager.lastSavedData = JSON.parse(JSON.stringify(currentData));
            AutoSaveManager.lastCheckedData = JSON.parse(JSON.stringify(currentData));
            AutoSaveManager.isDirty = false;
            
            // Ensure save button is disabled on initial load
            const saveBtn = document.getElementById('save-session-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
            }
        }
        
        setupSessionEditListeners();
        setupSaveListeners();
        
        // Initialize auto-save preference
        AutoSaveManager.initializeAutoSavePreference();
        
        // Set up responsive option text
        AutoSaveManager.updateOptionText();
        window.addEventListener('resize', AutoSaveManager.updateOptionText);
    });
    
    // Convert tune sets to pills data format - delegated to StateManager
    function convertTuneSetsToPills(tuneSets, skipCallback = false) {
        StateManager.convertTuneSetsToPills(tuneSets, skipCallback);
        tunePillsData = StateManager.getTunePillsData();
    }
    
    // Module functions are now called directly
 
    
    // Specialized function for dropping structured sets at a new position (horizontal zones)
    function dropStructuredSetsAtNewPosition(dragData, targetSetIndex) {
        if (!dragData || dragData.length === 0) return;
        
        // Filter out any empty sets from drag data
        dragData = dragData.filter(set => set && set.length > 0);
        
        if (dragData.length === 0) {
            return;
        }
        
        undoRedoManager.saveToUndo();
        
        // Remove dragged pills from their current positions (same logic as performDrop)
        const draggedPillIds = Array.from(PillSelection.getSelectedPills());
        const setsToRemove = new Set();
        
        
        draggedPillIds.forEach(pillId => {
            for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
                const pillIndex = tunePillsData[setIndex].findIndex(p => p.id === pillId);
                if (pillIndex !== -1) {
                    tunePillsData[setIndex].splice(pillIndex, 1);
                    if (tunePillsData[setIndex].length === 0) {
                        setsToRemove.add(setIndex);
                    }
                    break;
                }
            }
        });
        
        // Clean up empty sets BEFORE calculating target position
        tunePillsData = tunePillsData.filter(set => set.length > 0);
        
        // Calculate adjusted target index AFTER cleanup
        let adjustedTargetIndex = targetSetIndex;
        for (let i = 0; i < targetSetIndex; i++) {
            if (setsToRemove.has(i)) {
                adjustedTargetIndex--;
            }
        }
        
        
        // Create new sets with new IDs
        const newSets = dragData.map(set => 
            set.map(pill => ({
                ...pill,
                id: StateManager.generateId(),
                orderNumber: null
            }))
        );
        
        // Insert the new sets at the adjusted position
        if (adjustedTargetIndex >= tunePillsData.length) {
            tunePillsData.push(...newSets);
        } else {
            tunePillsData.splice(adjustedTargetIndex, 0, ...newSets);
        }
        
        // Update StateManager with the modified data
        StateManager.setTunePillsData(tunePillsData);
        
        PillRenderer.renderTunePills();
        
        // Apply landing animation
        const movedPillIds = newSets.flat().map(pill => pill.id);
        setTimeout(() => {
            PillRenderer.applyLandingAnimation(movedPillIds);
        }, 50);
    }
    
    function performDrop(position, draggedPillIds) {
        if (!draggedPillIds || draggedPillIds.length === 0) return;
        
        undoRedoManager.saveToUndo();
        
        // Track which sets will become empty after removal
        const originalSetCount = tunePillsData.length;
        const setsToRemove = new Set();
        
        // Remove dragged pills from their current positions
        const draggedPills = [];
        draggedPillIds.forEach(pillId => {
            for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
                const pillIndex = tunePillsData[setIndex].findIndex(p => p.id === pillId);
                if (pillIndex !== -1) {
                    draggedPills.push(tunePillsData[setIndex].splice(pillIndex, 1)[0]);
                    if (tunePillsData[setIndex].length === 0) {
                        setsToRemove.add(setIndex);
                    }
                    break;
                }
            }
        });
        
        // Calculate how many sets before target position will be removed
        let adjustedTargetIndex = position.setIndex;
        for (let i = 0; i < position.setIndex; i++) {
            if (setsToRemove.has(i)) {
                adjustedTargetIndex--;
            }
        }
        
        // Clean up empty sets
        tunePillsData = tunePillsData.filter(set => set.length > 0);
        
        // Insert at new position
        if (position.position === 'newset') {
            if (adjustedTargetIndex >= tunePillsData.length) {
                // Create new set at end
                tunePillsData.push(draggedPills);
            } else {
                // Create new set at specific index (insert between existing sets)
                tunePillsData.splice(adjustedTargetIndex, 0, draggedPills);
            }
        } else {
            // Use the adjusted target index for existing sets too
            if (adjustedTargetIndex >= tunePillsData.length) {
                // Create new set at end
                tunePillsData.push(draggedPills);
            } else {
                // Insert into existing set
                const targetSet = tunePillsData[adjustedTargetIndex];
                let insertIndex;
                
                if (position.position === 'before') {
                    insertIndex = position.pillIndex;
                } else { // 'after'
                    insertIndex = position.pillIndex;
                }
                
                // Insert pills into target set at the specified position
                targetSet.splice(insertIndex, 0, ...draggedPills);
            }
        }
        
        // Update StateManager with the modified data
        StateManager.setTunePillsData(tunePillsData);
        
        PillRenderer.renderTunePills();
        
        // Apply landing animation to moved pills
        const movedPillIds = draggedPills.map(pill => pill.id);
        setTimeout(() => {
            PillRenderer.applyLandingAnimation(movedPillIds);
        }, 50); // Small delay to ensure pills are rendered
    }
    
    // Drag and drop support functions
    function findPillById(pillId) {
        for (const set of tunePillsData) {
            for (const pill of set) {
                if (pill.id === pillId) {
                    return pill;
                }
            }
        }
        return null;
    }
    
    // Context menu functions
    function hideContextMenu(pillId) {
        // Remove all context menus and reset chevron states
        document.querySelectorAll('.tune-context-menu').forEach(menu => menu.remove());
        document.querySelectorAll('.chevron.open').forEach(chevron => chevron.classList.remove('open'));
    }
    
    function hideMatchResultsMenu(pillId) {
        // Remove match results menu for specific pill
        const menu = document.querySelector(`.match-results-menu[data-pill-id="${pillId}"]`);
        if (menu) {
            menu.remove();
        }
    }
    
    function showMatchResultsMenu(pill) {
        // Remove any existing match results menu for this pill
        hideMatchResultsMenu(pill.id);
        
        if (!pill.matchResults || pill.matchResults.length === 0) {
            return;
        }
        
        // Find the pill element
        const pillElement = document.querySelector(`[data-pill-id="${pill.id}"]`);
        if (!pillElement) {
            console.error(`Could not find pill element for ID: ${pill.id}`);
            return;
        }
        
        const menu = document.createElement('div');
        menu.className = 'tune-context-menu match-results-menu';
        menu.style.display = 'block';
        menu.dataset.pillId = pill.id;
        
        const rect = pillElement.getBoundingClientRect();
        
        // Position menu below the pill
        menu.style.position = 'fixed';
        menu.style.left = rect.left + 'px';
        menu.style.top = (rect.bottom + 5) + 'px';
        menu.style.width = 'auto';
        menu.style.minWidth = Math.max(200, rect.width) + 'px';
        menu.style.maxWidth = Math.min(600, window.innerWidth - rect.left - 20) + 'px';
        
        // Use a neutral background for the menu
        menu.style.backgroundColor = 'white';
        menu.style.color = '#212529';
        menu.style.border = '1px solid #dee2e6';
        menu.style.borderRadius = '4px';
        menu.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        
        // Add match results as menu items
        pill.matchResults.forEach(result => {
            const item = document.createElement('a');
            item.style.display = 'block';
            item.style.padding = '8px 12px';
            item.style.cursor = 'pointer';
            item.style.borderBottom = '1px solid #f0f0f0';
            item.style.color = '#212529';
            item.style.textDecoration = 'none';
            
            // Show tune name and type
            const nameSpan = document.createElement('span');
            nameSpan.textContent = result.tune_name;
            nameSpan.style.fontWeight = '500';
            item.appendChild(nameSpan);
            
            if (result.tune_type) {
                const typeSpan = document.createElement('span');
                typeSpan.textContent = ` (${result.tune_type})`;
                typeSpan.style.color = '#6c757d';
                typeSpan.style.fontSize = '0.9em';
                item.appendChild(typeSpan);
            }
            
            // Hover effect
            item.addEventListener('mouseenter', () => {
                item.style.backgroundColor = '#f8f9fa';
            });
            item.addEventListener('mouseleave', () => {
                item.style.backgroundColor = 'transparent';
            });
            
            // Click to select this match
            item.addEventListener('click', () => {
                // Apply the selected match
                pill.tuneId = result.tune_id;
                pill.tuneName = result.tune_name;
                pill.tuneType = result.tune_type;
                pill.state = 'linked';
                pill.matchResults = null;
                
                // Update the pill appearance
                PillRenderer.updatePillAppearance(pill);
                
                // Force check for changes (includes timer reset and dirty state)
                AutoSaveManager.forceCheckChanges();
                
                // Hide the menu
                hideMatchResultsMenu(pill.id);
                
                // If we're still typing, maintain typing state
                if (textInput && textInput.typing) {
                    // Move cursor after this pill
                    const pillPosition = findPillPosition(pill.id);
                    if (pillPosition) {
                        CursorManager.setCursorPosition(pillPosition.setIndex, pillPosition.pillIndex, 'after');
                    }
                }
            });
            
            menu.appendChild(item);
        });
        
        // Remove last border
        if (menu.lastChild) {
            menu.lastChild.style.borderBottom = 'none';
        }
        
        document.body.appendChild(menu);
        
        // Don't auto-hide this menu when clicking elsewhere while typing
        // But do hide it when the pill state changes or user navigates away
    }
    
    function findPillPosition(pillId) {
        for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
            const set = tunePillsData[setIndex];
            const pillIndex = set.findIndex(p => p.id === pillId);
            if (pillIndex !== -1) {
                return { setIndex, pillIndex };
            }
        }
        return null;
    }
    
    function showContextMenu(event, pillData) {
        // Remove existing context menus and reset all chevrons
        hideContextMenu();
        
        const menu = document.createElement('div');
        menu.className = 'tune-context-menu';
        menu.style.display = 'block';
        menu.dataset.pillId = pillData.id; // Track which pill this menu belongs to
        
        // Find the pill element to match its dimensions and color
        const pillElement = event.target.closest('.tune-pill');
        const rect = pillElement.getBoundingClientRect();
        
        // Set chevron to open state
        const chevron = pillElement.querySelector('.chevron');
        chevron.classList.add('open');
        
        // Position menu
        menu.style.position = 'fixed';
        menu.style.left = rect.left + 'px';
        menu.style.top = (rect.bottom + 5) + 'px';
        
        // For unmatched pills with results, make menu wider to accommodate tune names
        if (pillData.state === 'unmatched' && pillData.matchResults && pillData.matchResults.length > 0) {
            menu.style.width = 'auto';
            menu.style.minWidth = Math.max(250, rect.width) + 'px';
            menu.style.maxWidth = Math.min(500, window.innerWidth - rect.left - 20) + 'px';
        } else {
            // Match pill width for other states
            menu.style.width = rect.width + 'px';
            menu.style.minWidth = 'unset';
        }
        
        // Match pill background color based on state
        const computedStyle = window.getComputedStyle(pillElement);
        menu.style.backgroundColor = computedStyle.backgroundColor;
        menu.style.color = computedStyle.color;
        menu.style.borderColor = computedStyle.borderColor;
        
        // Create menu items based on pill state
        if (pillData.state === 'linked') {
            // Linked tune options
            addMenuItem(menu, 'Dots', () => {
                const url = `https://thesession.org/tunes/${pillData.tuneId}${pillData.setting ? '#setting' + pillData.setting : ''}`;
                window.open(url, '_blank');
                hideContextMenu();
            });
            
            addMenuItem(menu, 'Relink', () => {
                showLinkModal(pillData);
                hideContextMenu();
            });
        } else if (pillData.state === 'unmatched' && pillData.matchResults && pillData.matchResults.length > 0) {
            // Show match results first if available
            pillData.matchResults.forEach(result => {
                const item = document.createElement('a');
                item.style.display = 'block';
                item.style.padding = '8px 12px';
                item.style.cursor = 'pointer';
                item.style.borderBottom = '1px solid rgba(255,255,255,0.2)';
                
                // Show tune name and type
                const nameSpan = document.createElement('span');
                nameSpan.textContent = result.tune_name;
                nameSpan.style.fontWeight = '500';
                item.appendChild(nameSpan);
                
                if (result.tune_type) {
                    const typeSpan = document.createElement('span');
                    typeSpan.textContent = ` (${result.tune_type})`;
                    typeSpan.style.opacity = '0.8';
                    typeSpan.style.fontSize = '0.9em';
                    item.appendChild(typeSpan);
                }
                
                // Click to select this match
                item.addEventListener('click', () => {
                    // Apply the selected match
                    pillData.tuneId = result.tune_id;
                    pillData.tuneName = result.tune_name;
                    pillData.tuneType = result.tune_type;
                    pillData.state = 'linked';
                    pillData.matchResults = null;
                    
                    // Update the pill appearance
                    PillRenderer.updatePillAppearance(pillData);
                    
                    // Force check for changes (includes timer reset and dirty state)
                    AutoSaveManager.forceCheckChanges();
                    hideContextMenu();
                });
                
                menu.appendChild(item);
            });
            
            // Add separator
            const separator = document.createElement('div');
            separator.style.borderTop = '1px solid rgba(255,255,255,0.3)';
            separator.style.margin = '4px 0';
            menu.appendChild(separator);
            
            // Add manual link option
            addMenuItem(menu, 'Manual Link...', () => {
                showLinkModal(pillData);
                hideContextMenu();
            });
        } else {
            // Unlinked tune options
            addMenuItem(menu, 'Link', () => {
                showLinkModal(pillData);
                hideContextMenu();
            });
        }
        
        // Common options
        addMenuItem(menu, 'Edit Text', () => {
            showEditModal(pillData);
            hideContextMenu();
        });
        
        if (PillSelection.getSelectionCount() <= 1) {
            addMenuItem(menu, 'Delete', () => {
                deletePill(pillData.id);
                hideContextMenu();
            });
        } else {
            addMenuItem(menu, `Delete Selected (${PillSelection.getSelectionCount()})`, () => {
                PillSelection.deleteSelectedPills();
                hideContextMenu();
            });
        }
        
        document.body.appendChild(menu);
        
        // Hide menu when clicking elsewhere
        setTimeout(() => {
            const hideMenu = (e) => {
                if (!menu.contains(e.target)) {
                    hideContextMenu();
                    document.removeEventListener('click', hideMenu);
                }
            };
            document.addEventListener('click', hideMenu);
        }, 0);
    }
    
    function addMenuItem(menu, text, callback) {
        const item = document.createElement('a');
        item.textContent = text;
        item.addEventListener('click', callback);
        menu.appendChild(item);
    }
    
    // Modal functions - using generic ModalManager methods
    function showLinkModal(pillData) {
        const inputValue = pillData.tuneId ? `https://thesession.org/tunes/${pillData.tuneId}` : '';
        ModalManager.showModalWithInput('link-tune-modal', '#tune-link-input', inputValue, false);
        // Store current pill for linking (backward compatibility)
        window.currentLinkingPill = pillData;
    }
    
    function showEditModal(pillData) {
        ModalManager.showModalWithInput('edit-tune-modal', '#edit-tune-name-input', pillData.tuneName, true);
        // Store current pill for editing (backward compatibility)
        window.currentEditingPill = pillData;
    }
    
    // Delete functions
    function deletePill(pillId) {
        // Find and remove the pill
        for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
            const pillIndex = tunePillsData[setIndex].findIndex(p => p.id === pillId);
            if (pillIndex !== -1) {
                undoRedoManager.saveToUndo();
                tunePillsData[setIndex].splice(pillIndex, 1);
                
                // Remove empty sets
                if (tunePillsData[setIndex].length === 0) {
                    tunePillsData.splice(setIndex, 1);
                }
                
                // Update StateManager with the modified data
                StateManager.setTunePillsData(tunePillsData);
                
                PillRenderer.renderTunePills();
                break;
            }
        }
    }
    
    // All clipboard and undo/redo functions now use modules directly
    
    function removeTemporaryEmptySet() {
        if (temporaryEmptySet !== null && temporaryEmptySet < tunePillsData.length && tunePillsData[temporaryEmptySet].length === 0) {
            tunePillsData.splice(temporaryEmptySet, 1);
            temporaryEmptySet = null;
            
            // Update StateManager with the modified data
            StateManager.setTunePillsData(tunePillsData);
            
            return true;
        }
        temporaryEmptySet = null;
        return false;
    }
    
    // Track selection anchor for shift+arrow selection  
    let selectionAnchor = null;
    
    // Track temporary empty line
    let temporaryEmptySet = null;
    
    
    function selectPillsBetweenPositions(startPos, endPos) {
        // Convert positions to cursor format and use PillSelection method
        const startCursor = { setIndex: startPos.setIndex, pillIndex: startPos.pillIndex, position: 'after' };
        const endCursor = { setIndex: endPos.setIndex, pillIndex: endPos.pillIndex, position: 'after' };
        PillSelection.selectFromCursorRange(startCursor, endCursor);
    }
    
    function selectPillsBetweenCursorPositions(startCursorPos, endCursorPos) {
        // Use PillSelection method directly
        PillSelection.selectFromCursorRange(startCursorPos, endCursorPos);
    }
    
    
    function findPillIndex(allPills, pillPos) {
        if (!pillPos) return -1;
        
        for (let i = 0; i < allPills.length; i++) {
            if (allPills[i].setIndex === pillPos.setIndex && allPills[i].pillIndex === pillPos.pillIndex) {
                return i;
            }
        }
        return -1;
    }
    
    // Show results after all tune matching completes
    function showMatchingResults(pills) {
        const linkedCount = pills.filter(pill => pill.state === 'linked').length;
        const unlinkedCount = pills.filter(pill => pill.state === 'unlinked').length;
        const totalCount = pills.length;
        
        let message, type;
        
        if (linkedCount === totalCount) {
            // All tunes matched
            message = totalCount === 1 ? 'Tune matched' : `All ${totalCount} tunes matched`;
            type = 'success';
        } else if (linkedCount === 0) {
            // No tunes matched
            message = totalCount === 1 ? 'Tune not matched' : `${totalCount} tunes not matched`;
            type = 'error';
        } else {
            // Some matched, some didn't
            message = `${linkedCount} of ${totalCount} tunes matched`;
            type = 'success';
        }
        
        showMessage(message, type);
    }
    
    // Auto-match a tune against the database without saving
    async function autoMatchTune(pill, stillTyping = false) {
        try {
            // Find the previous tune type if this pill is in a set
            let previousTuneType = null;
            
            // Check if the pill already has a previousTuneType set (for typing pills)
            if (pill.previousTuneType !== undefined) {
                previousTuneType = pill.previousTuneType;
                console.log(`Using pre-calculated previous tune type: ${previousTuneType}`);
            } else {
                // Find which set this pill belongs to
                for (let setIndex = 0; setIndex < tunePillsData.length; setIndex++) {
                    const set = tunePillsData[setIndex];
                    const pillIndex = set.findIndex(p => p.id === pill.id);
                    
                    if (pillIndex > 0) {
                        // This pill is not the first in the set, check previous pills for tune type
                        for (let i = pillIndex - 1; i >= 0; i--) {
                            if (set[i].tuneType) {
                                previousTuneType = set[i].tuneType;
                                break;
                            }
                        }
                        break;
                    }
                }
            }
            
            console.log(`Making API request to match tune: "${pill.tuneName}" (previous type: ${previousTuneType || 'none'})`);
            const response = await fetch(`/api/sessions/{{ session_instance.session_path }}/{{ session_instance.date }}/match_tune`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    tune_name: pill.tuneName,
                    previous_tune_type: previousTuneType
                })
            });
            
            console.log(`API response status for "${pill.tuneName}": ${response.status}`);
            
            if (!response.ok) {
                console.warn(`Failed to match tune "${pill.tuneName}": ${response.status}`);
                const errorText = await response.text();
                console.warn('Error response:', errorText);
                return;
            }
            
            const result = await response.json();
            console.log(`API result for "${pill.tuneName}":`, result);
            
            if (result.success && result.results) {
                // Store the results on the pill for later use
                pill.matchResults = result.results;
                
                if (result.results.length === 1 && result.exact_match) {
                    // Single exact match - automatically apply it
                    const match = result.results[0];
                    pill.tuneId = match.tune_id;
                    pill.tuneName = match.tune_name;
                    pill.tuneType = match.tune_type;
                    pill.state = 'linked';
                    pill.matchResults = null; // Clear stored results
                    console.log(`Successfully matched "${pill.tuneName}" -> "${match.tune_name}" (ID: ${match.tune_id})`);
                    
                    // Mark as dirty since we changed the pill
                    AutoSaveManager.forceCheckChanges();
                    
                } else if (result.results.length > 1) {
                    // Multiple matches - mark as unmatched and store results
                    pill.state = 'unmatched';
                    console.log(`Multiple matches found for "${pill.tuneName}": ${result.results.length} results`);
                    
                    // Mark as dirty since we changed the pill state
                    AutoSaveManager.forceCheckChanges();
                    
                    // Show context menu with results if still typing/editing
                    if (stillTyping) {
                        showMatchResultsMenu(pill);
                    } else {
                        // User has exited text entry - hide any existing menu
                        hideMatchResultsMenu(pill.id);
                    }
                    
                } else if (result.results.length === 1 && !result.exact_match) {
                    // Single wildcard match
                    if (stillTyping) {
                        // While typing, just show the option but don't auto-apply
                        pill.state = 'unmatched';
                        AutoSaveManager.forceCheckChanges();
                        showMatchResultsMenu(pill);
                    } else {
                        // When finished typing, auto-apply single wildcard match
                        const match = result.results[0];
                        pill.tuneId = match.tune_id;
                        pill.tuneName = match.tune_name;
                        pill.tuneType = match.tune_type;
                        pill.state = 'linked';
                        pill.matchResults = null;
                        console.log(`Auto-applied single wildcard match: "${pill.tuneName}" -> "${match.tune_name}" (ID: ${match.tune_id})`);
                        
                        // Mark as dirty since we changed the pill
                        AutoSaveManager.forceCheckChanges();
                    }
                    
                } else {
                    // No matches at all
                    pill.state = 'unlinked';
                    pill.matchResults = null;
                    console.log(`No match found for "${pill.tuneName}"`);
                    
                    // Mark as dirty since we changed the pill state
                    AutoSaveManager.forceCheckChanges();
                }
            } else {
                // Error or unexpected response format
                pill.state = 'unlinked';
                pill.matchResults = null;
                console.warn(`Unexpected response format for "${pill.tuneName}"`);
                
                // Mark as dirty since we changed the pill state
                AutoSaveManager.markDirty();
            }
            
            // Update just this pill instead of re-rendering everything
            PillRenderer.updatePillAppearance(pill);
        } catch (error) {
            console.error(`Network error matching tune "${pill.tuneName}":`, error);
            // Network error - pill becomes unlinked
            pill.state = 'unlinked';
            pill.matchResults = null;
            
            // Mark as dirty since we changed the pill state
            AutoSaveManager.markDirty();
            
            PillRenderer.updatePillAppearance(pill);
        }
    }
    
    
    function deleteTuneAtCursor() {
        const cursorPosition = CursorManager.getCursorPosition();
        if (!cursorPosition) return;
        
        const { setIndex, pillIndex, position } = cursorPosition;
        
        // Always delete the pill immediately to the left of the cursor (backspace behavior)
        let tuneToDelete = null;
        let newCursorPosition = null;
        
        if (position === 'after') {
            // Cursor is after a pill - delete that pill
            tuneToDelete = { setIndex, pillIndex };
            // After deletion, if there's a pill to the left, position after it
            if (pillIndex > 0) {
                newCursorPosition = { setIndex, pillIndex: pillIndex - 1, position: 'after' };
            } else {
                // Deleting first pill of the set - check if it's the only pill
                if (tunePillsData[setIndex].length === 1) {
                    // This is the only pill in the set - set should become a temporary empty line
                    newCursorPosition = { setIndex, pillIndex: 0, position: 'before' };
                } else {
                    // There are other pills in the set, position before the next pill
                    newCursorPosition = { setIndex, pillIndex: 0, position: 'before' };
                }
            }
        } else if (position === 'before' && pillIndex > 0) {
            // Cursor is before a pill - delete the previous pill
            tuneToDelete = { setIndex, pillIndex: pillIndex - 1 };
            // After deletion, cursor stays before the same pill (which now has a lower index)
            newCursorPosition = { setIndex, pillIndex: pillIndex - 1, position: 'before' };
        } else if (position === 'before' && pillIndex === 0) {
            // Cursor is at the beginning of a set - for backspace, we don't delete anything here
            // This case should be handled by the caller (e.g., merge with previous line if empty)
            return;
        } else if (position === 'newset' && setIndex > 0 && tunePillsData[setIndex - 1].length > 0) {
            // Cursor is at a new set position - delete the last pill of the previous set
            const prevSetIndex = setIndex - 1;
            const prevSetLength = tunePillsData[prevSetIndex].length;
            tuneToDelete = { setIndex: prevSetIndex, pillIndex: prevSetLength - 1 };
            newCursorPosition = { setIndex: prevSetIndex, pillIndex: prevSetLength - 1, position: 'after' };
        }
        
        if (tuneToDelete) {
            undoRedoManager.saveToUndo();
            const targetSet = tunePillsData[tuneToDelete.setIndex];
            const wasLastPillInSet = targetSet.length === 1; // Check before deletion
            targetSet.splice(tuneToDelete.pillIndex, 1);
            
            // Check if this deletion creates a temporary empty set
            // This happens when deleting the only pill in a set and cursor stays in that set
            const shouldCreateTemporaryEmpty = (targetSet.length === 0 && 
                                              wasLastPillInSet &&
                                              newCursorPosition && 
                                              newCursorPosition.setIndex === tuneToDelete.setIndex &&
                                              newCursorPosition.position === 'before');
            
            // Handle empty sets
            const setWasRemoved = targetSet.length === 0 && !shouldCreateTemporaryEmpty;
            if (setWasRemoved) {
                tunePillsData.splice(tuneToDelete.setIndex, 1);
            } else if (shouldCreateTemporaryEmpty) {
                // Mark this as a temporary empty set
                temporaryEmptySet = tuneToDelete.setIndex;
            }
            
            // Update StateManager with the modified data
            StateManager.setTunePillsData(tunePillsData);
            
            // Render first, then set cursor position
            PillRenderer.renderTunePills();
            
            // Apply the cursor position after rendering when cursor position elements exist
            if (setWasRemoved) {
                // Set was removed - use the stored cursor position but adjust for removed set
                if (newCursorPosition.setIndex < tuneToDelete.setIndex) {
                    // Cursor position is in a set before the deleted one, no adjustment needed
                    CursorManager.setCursorPosition(newCursorPosition.setIndex, newCursorPosition.pillIndex, newCursorPosition.position);
                } else if (newCursorPosition.setIndex === tuneToDelete.setIndex) {
                    // Cursor was in the deleted set, position at the beginning of next set or end
                    if (tuneToDelete.setIndex < tunePillsData.length) {
                        CursorManager.setCursorPosition(tuneToDelete.setIndex, 0, 'before');
                    } else if (tuneToDelete.setIndex > 0) {
                        // No next set, go to end of previous set
                        CursorManager.setCursorPosition(tuneToDelete.setIndex - 1, tunePillsData[tuneToDelete.setIndex - 1].length - 1, 'after');
                    } else {
                        // No sets left
                        CursorManager.setCursorPosition(0, 0, 'newset');
                    }
                } else {
                    // Cursor position is after deleted set, adjust index
                    CursorManager.setCursorPosition(newCursorPosition.setIndex - 1, newCursorPosition.pillIndex, newCursorPosition.position);
                }
            } else if (shouldCreateTemporaryEmpty) {
                // Set exists but is now empty (temporary empty set)
                // Position cursor at the beginning of the empty set
                CursorManager.setCursorPosition(newCursorPosition.setIndex, 0, 'before');
            } else {
                // Set still exists and has pills, use the calculated new cursor position
                if (newCursorPosition.pillIndex >= targetSet.length) {
                    // Position is beyond the end of the set, position after last pill
                    CursorManager.setCursorPosition(newCursorPosition.setIndex, targetSet.length - 1, 'after');
                } else if (newCursorPosition.pillIndex < 0) {
                    // Position is before the beginning, position before first pill
                    CursorManager.setCursorPosition(newCursorPosition.setIndex, 0, 'before');
                } else {
                    // Position is valid
                    CursorManager.setCursorPosition(newCursorPosition.setIndex, newCursorPosition.pillIndex, newCursorPosition.position);
                }
            }
        }
    }
    
    // Cursor movement functions
    // Cursor movement functions now handled directly by CursorManager
    
    // Event listeners setup
    function setupEventListeners() {
        // Container click to focus
        const tuneContainer = document.getElementById('tune-pills-container');
        tuneContainer.addEventListener('click', (e) => {
            
            // Don't handle clicks on tune pills or their children (they have their own handlers)
            if (e.target.closest('.tune-pill')) {
                return;
            }
            
            // Don't handle clicks on context menus
            if (e.target.closest('.tune-context-menu')) {
                return;
            }
            
            // Check if click is on a cursor position element (they handle themselves)
            if (e.target.classList.contains('cursor-position')) {
                return;
            }
            
            // Check if clicking on a tune-set - find the best cursor position
            if (e.target.classList.contains('tune-set')) {
                const setIndex = parseInt(e.target.dataset.setIndex);
                const rect = e.target.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const setWidth = rect.width;
                const setLength = tunePillsData[setIndex]?.length || 0;
                
                
                // Find the actual position of tune pills within the set
                const pillElements = e.target.querySelectorAll('.tune-pill');
                let bestPosition = null;
                let closestDistance = Infinity;
                
                // Check distance to each pill to find the closest cursor position
                pillElements.forEach((pill, pillIndex) => {
                    const pillRect = pill.getBoundingClientRect();
                    const pillCenterX = pillRect.left + pillRect.width / 2 - rect.left;
                    const pillEndX = pillRect.right - rect.left;
                    
                    // Distance to "before" position (left edge of pill)
                    const distanceToBefore = Math.abs(clickX - (pillRect.left - rect.left));
                    if (distanceToBefore < closestDistance) {
                        closestDistance = distanceToBefore;
                        bestPosition = { pillIndex, position: 'before' };
                    }
                    
                    // Distance to "after" position (right edge of pill)
                    const distanceToAfter = Math.abs(clickX - pillEndX);
                    if (distanceToAfter < closestDistance) {
                        closestDistance = distanceToAfter;
                        bestPosition = { pillIndex, position: 'after' };
                    }
                });
                
                // If click is beyond the last pill, always position at end
                if (pillElements.length > 0) {
                    const lastPillRect = pillElements[pillElements.length - 1].getBoundingClientRect();
                    const lastPillEnd = lastPillRect.right - rect.left;
                    if (clickX > lastPillEnd) {
                        bestPosition = { pillIndex: setLength - 1, position: 'after' };
                    }
                }
                
                // Fallback: if no pills or click is before first pill
                if (!bestPosition) {
                    bestPosition = { pillIndex: 0, position: 'before' };
                }
                
                
                // If user is typing, finish typing first
                if (textInput && textInput.typing) {
                    finishTyping();
                }
                
                // Clear selection and selection anchor when clicking to move cursor
                CursorManager.clearSelection();
                
                CursorManager.setCursorPosition(setIndex, bestPosition.pillIndex, bestPosition.position);
                return;
            }
            
            // For clicks in other empty space, set cursor at end
            
            // If user is typing, finish typing first
            if (textInput && textInput.typing) {
                finishTyping();
            }
            
            // Clear selection and selection anchor when clicking to move cursor
            CursorManager.clearSelection();
            
            CursorManager.setCursorPosition(tunePillsData.length, 0, 'newset');
        });
        
        // Mobile touch handling for container (cursor placement and scrolling)
        let containerTouchStart = null;
        let containerTouchMoved = false;
        
        tuneContainer.addEventListener('touchstart', (e) => {
            // Don't handle touches on tune pills (they have their own handlers)
            if (e.target.closest('.tune-pill')) {
                return;
            }
            
            // Don't handle touches on context menus or cursor positions
            if (e.target.closest('.tune-context-menu') || e.target.classList.contains('cursor-position')) {
                return;
            }
            
            containerTouchStart = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                time: Date.now(),
                target: e.target
            };
            containerTouchMoved = false;
        });
        
        tuneContainer.addEventListener('touchmove', (e) => {
            if (containerTouchStart) {
                containerTouchMoved = true;
                // Let browser handle scrolling
            }
        });
        
        tuneContainer.addEventListener('touchend', (e) => {
            if (!containerTouchStart) return;
            
            const touchDuration = Date.now() - containerTouchStart.time;
            
            // If it was a quick tap without movement, treat as cursor placement
            if (!containerTouchMoved && touchDuration < 500) {
                const touch = e.changedTouches[0];
                
                // Create a synthetic click event to reuse existing click logic
                const clickEvent = new MouseEvent('click', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true,
                    cancelable: true
                });
                
                // Set the target and trigger the existing click handler logic
                Object.defineProperty(clickEvent, 'target', { value: containerTouchStart.target });
                
                // Manually execute the cursor positioning logic
                if (containerTouchStart.target.classList.contains('tune-set')) {
                    const setIndex = parseInt(containerTouchStart.target.dataset.setIndex);
                    const rect = containerTouchStart.target.getBoundingClientRect();
                    const clickX = touch.clientX - rect.left;
                    const setWidth = rect.width;
                    const setLength = tunePillsData[setIndex]?.length || 0;
                    
                    // Find best cursor position (reusing click logic)
                    let bestPosition = null;
                    
                    if (setLength > 0) {
                        // Find position relative to pills
                        const relativePosition = clickX / setWidth;
                        const estimatedPillIndex = Math.floor(relativePosition * setLength);
                        const clampedIndex = Math.max(0, Math.min(setLength - 1, estimatedPillIndex));
                        
                        if (relativePosition < (clampedIndex + 0.5) / setLength) {
                            bestPosition = { pillIndex: clampedIndex, position: 'before' };
                        } else {
                            bestPosition = { pillIndex: clampedIndex, position: 'after' };
                        }
                        
                        if (relativePosition > 0.9) {
                            bestPosition = { pillIndex: setLength - 1, position: 'after' };
                        }
                    }
                    
                    if (!bestPosition) {
                        bestPosition = { pillIndex: 0, position: 'before' };
                    }
                    
                    // If user is typing, finish typing first
                    if (textInput && textInput.typing) {
                        finishTyping();
                    }
                    
                    // Clear selection when touching to move cursor
                    CursorManager.clearSelection();
                    
                    CursorManager.setCursorPosition(setIndex, bestPosition.pillIndex, bestPosition.position);
                } else {
                    // Touch in empty space - set cursor at end
                    if (textInput && textInput.typing) {
                        finishTyping();
                    }
                    
                    PillSelection.selectNone();
                    
                    CursorManager.setCursorPosition(tunePillsData.length, 0, 'newset');
                }
                
                e.preventDefault();
            }
            // If touch moved, allow normal scroll behavior (no preventDefault)
            
            containerTouchStart = null;
        });
        
        // Keyboard shortcuts and text input - handled by KeyboardHandler module
        KeyboardHandler.setupKeyboardListeners();
        
        // Container drag and drop event listeners
        DragDrop.setupContainerDragListeners();
        
        // Modal event listeners
        document.getElementById('link-cancel-btn').addEventListener('click', hideLinkModal);
        document.getElementById('link-confirm-btn').addEventListener('click', confirmLink);
        document.getElementById('edit-tune-cancel-btn').addEventListener('click', hideEditModal);
        document.getElementById('edit-tune-save-btn').addEventListener('click', confirmEdit);
    }
    
    // Modal control functions
    function hideLinkModal() {
        ModalManager.hideModal('link-tune-modal');
        window.currentLinkingPill = null;
    }
    
    function hideEditModal() {
        ModalManager.hideModal('edit-tune-modal');
        window.currentEditingPill = null;
    }
    
    function confirmLink() {
        const input = document.getElementById('tune-link-input').value.trim();
        if (!input || !window.currentLinkingPill) return;
        
        // Extract tune ID from URL or use as is
        let tuneId = input;
        const urlMatch = input.match(/thesession\.org\/tunes\/(\d+)/);
        if (urlMatch) {
            tuneId = urlMatch[1];
        }
        
        if (!/^\d+$/.test(tuneId)) {
            showMessage('Please enter a valid tune ID or thesession.org URL', 'error');
            return;
        }
        
        undoRedoManager.saveToUndo();
        
        // Update the pill
        window.currentLinkingPill.tuneId = parseInt(tuneId);
        window.currentLinkingPill.state = 'linked';
        
        PillRenderer.renderTunePills();
        hideLinkModal();
        
        showMessage('Tune linked successfully!', 'success');
    }
    
    function confirmEdit() {
        const newName = document.getElementById('edit-tune-name-input').value.trim();
        if (!newName || !window.currentEditingPill) return;
        
        undoRedoManager.saveToUndo();
        
        const pill = window.currentEditingPill;
        
        // Update the tune name
        pill.tuneName = newName;
        
        // Mark as dirty since we changed the pill
        AutoSaveManager.forceCheckChanges();
        
        // If the tune was linked, unlink it first and re-run matching
        if (pill.state === 'linked') {
            // Unlink the tune
            pill.tuneId = null;
            pill.setting = null;
            pill.tuneType = null;
            pill.state = 'loading';  // Show loading state while re-matching
            
            // Update the pill appearance immediately to show loading state
            PillRenderer.updatePillAppearance(pill);
            
            // Re-run auto-matching with the new name
            autoMatchTune(pill);
        } else {
            // If it was unlinked, still try to match the new name
            pill.state = 'loading';
            PillRenderer.updatePillAppearance(pill);
            autoMatchTune(pill);
        }
        
        hideEditModal();
        showMessage('Tune name updated!', 'success');
    }
    
    // Session edit functionality (reused from original)
    function setupSessionEditListeners() {
        document.getElementById('edit-date-btn').addEventListener('click', showEditSessionModal);
        document.getElementById('edit-session-cancel-btn').addEventListener('click', hideSessionEditModal);
        document.getElementById('edit-session-save-btn').addEventListener('click', saveSessionInstance);
    }
    
    function setupSaveListeners() {
        // Save button click
        document.getElementById('save-session-btn').addEventListener('click', () => AutoSaveManager.saveSession());
        
        // Auto-save checkbox change
        document.getElementById('auto-save-checkbox').addEventListener('change', () => AutoSaveManager.setupAutoSave());
        
        // Auto-save interval change
        document.getElementById('auto-save-interval').addEventListener('change', () => {
            if (document.getElementById('auto-save-checkbox').checked) {
                AutoSaveManager.setupAutoSave();
            }
        });
        
        // Cancel auto-save link
        document.getElementById('cancel-auto-save').addEventListener('click', (e) => {
            e.preventDefault();
            AutoSaveManager.cancelAutoSave();
        });
    }
    
    function showEditSessionModal() {
        // Populate form data first (page-specific business logic)
        const dateInput = document.getElementById('edit-session-date-input');
        const locationInput = document.getElementById('edit-session-location-input');
        const commentsInput = document.getElementById('edit-session-comments-input');
        const cancelledInput = document.getElementById('edit-session-cancelled-input');
        
        dateInput.value = sessionInstanceData.date;
        locationInput.value = sessionInstanceData.location_override || '';
        commentsInput.value = sessionInstanceData.comments || '';
        cancelledInput.checked = sessionInstanceData.is_cancelled;
        
        // Show modal with generic ModalManager
        ModalManager.showModal('edit-session-instance-modal', {
            autoFocus: false // We'll focus manually
        });
        
        dateInput.focus();
    }
    
    function hideSessionEditModal() {
        ModalManager.hideModal('edit-session-instance-modal');
    }
    
    function saveSessionInstance() {
        const dateInput = document.getElementById('edit-session-date-input');
        const locationInput = document.getElementById('edit-session-location-input');
        const commentsInput = document.getElementById('edit-session-comments-input');
        const cancelledInput = document.getElementById('edit-session-cancelled-input');
        
        const date = dateInput.value.trim();
        const location = locationInput.value.trim();
        const comments = commentsInput.value.trim();
        const cancelled = cancelledInput.checked;
        
        if (!date) {
            showMessage('Please enter a session date', 'error');
            return;
        }
        
        const requestData = { 
            date: date,
            cancelled: cancelled
        };
        
        if (location) requestData.location = location;
        if (comments) requestData.comments = comments;
        
        fetch(`/api/sessions/${sessionPath}/${sessionDate}/update`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(data.message);
                hideSessionEditModal();
                if (date !== sessionDate) {
                    window.location.href = `/sessions/${sessionPath}/${date}/beta`;
                } else {
                    window.location.reload();
                }
            } else {
                showMessage(data.message, 'error');
            }
        })
        .catch(error => {
            showMessage('Failed to update session instance', 'error');
            console.error('Error:', error);
        });
    }
    
    // Message display function - uses the existing base template flash message system
    function showMessage(message, type = 'success') {
        return ModalManager.showMessage(message, type);
    }
    
    // Mark complete link event listener (if link exists)
    const markCompleteLink = document.getElementById('mark-complete-link');
    if (markCompleteLink) {
        markCompleteLink.addEventListener('click', function(event) {
            event.preventDefault();
            markSessionLogComplete();
        });
    }
    
    // Mark incomplete link event listener (if link exists)
    const markIncompleteLink = document.getElementById('mark-incomplete-link');
    if (markIncompleteLink) {
        markIncompleteLink.addEventListener('click', function(event) {
            event.preventDefault();
            markSessionLogIncomplete();
        });
    }
    
    function markSessionLogComplete() {
        if (!confirm('Mark this session log as complete? This will switch to view mode and hide the edit button from non-admins.')) {
            return;
        }
        
        fetch(`/api/sessions/${sessionPath}/${sessionDate}/mark_complete`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(data.message);
                // Redirect to normal view after a short delay
                setTimeout(() => {
                    window.location.href = `/sessions/${sessionPath}/${sessionDate}`;
                }, 1500);
            } else {
                showMessage(data.message, 'error');
            }
        })
        .catch(error => {
            showMessage('Failed to mark session log complete', 'error');
            console.error('Error:', error);
        });
    }
    
    function markSessionLogIncomplete() {
        if (!confirm('Mark this session log as not complete? This will allow all users to edit it again.')) {
            return;
        }
        
        fetch(`/api/sessions/${sessionPath}/${sessionDate}/mark_incomplete`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage(data.message);
                // Reload the page to show updated status
                setTimeout(() => {
                    window.location.href = `/sessions/${sessionPath}/${sessionDate}/beta`;
                }, 1500);
            } else {
                showMessage(data.message, 'error');
            }
        })
        .catch(error => {
            showMessage('Failed to mark session log as not complete', 'error');
            console.error('Error:', error);
        });
    }
</script>
{% endblock %}