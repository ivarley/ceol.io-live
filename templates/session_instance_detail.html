{% extends "base.html" %}

{% block title %}{{ session_instance.session_name }} - {{ session_instance.date }} - Irish Music Session Details{% endblock %}

{% block extra_css %}
<style>
        .message {
            position: fixed;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            border-radius: 6px;
            z-index: 1100;
            min-width: 300px;
            text-align: center;
            box-shadow: 0 4px 12px var(--dropdown-shadow);
            transition: top 0.3s ease-in-out;
        }
        .message.success {
            background-color: var(--success-bg, #d4edda);
            border: 1px solid var(--success-border, #c3e6cb);
            color: var(--success-text, #155724);
        }
        .message.error {
            background-color: var(--error-bg, #f8d7da);
            border: 1px solid var(--error-border, #f5c6cb);
            color: var(--error-text, #721c24);
        }
        .message.show {
            top: 20px;
        }
        .hidden {
            display: none;
        }
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .loading-ellipsis {
            display: inline-block;
            color: var(--disabled-text);
        }
        .loading-ellipsis:after {
            content: '...';
            animation: ellipsis 1.5s infinite;
            width: 1em;
            text-align: left;
            display: inline-block;
        }
        @keyframes ellipsis {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .cancelled-date {
            color: var(--danger, #dc3545);
            text-decoration: line-through;
        }
        .cancelled-message {
            padding: 20px;
            background-color: var(--light);
            border-left: 4px solid var(--danger, #dc3545);
            margin: 20px 0;
            color: var(--text-color);
            font-style: italic;
        }
        .edit-link {
            color: var(--primary);
            text-decoration: none;
            margin-left: 15px;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            cursor: pointer;
            vertical-align: middle;
        }
        .edit-link:hover {
            text-decoration: underline;
        }
        .editable-header:hover .edit-link {
            opacity: 1;
        }
        .delete-link {
            color: var(--danger, #dc3545);
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            display: block;
            text-align: center;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }
        .delete-link:hover {
            text-decoration: underline;
        }
        .tune-context-menu {
            position: absolute;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1500;
            font-size: 14px;
            color: var(--text-color);
            white-space: nowrap;
            display: none;
            min-width: 100px;
            pointer-events: auto;
            touch-action: manipulation;
        }
        .tune-context-menu a {
            display: block;
            padding: 6px 12px;
            text-decoration: none;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
        }
        .tune-context-menu a:hover {
            background-color: var(--hover-bg);
            color: var(--primary);
        }
        .tune-context-menu .menu-item-with-submenu {
            position: relative;
        }
        .tune-context-menu .menu-item-with-submenu:hover .submenu {
            display: block;
        }
        .tune-context-menu .submenu {
            position: absolute;
            left: 100%;
            top: 0;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1600;
            font-size: 14px;
            color: var(--text-color);
            white-space: nowrap;
            display: none;
            min-width: 120px;
        }
        .tune-context-menu .submenu a {
            display: block;
            padding: 6px 12px;
            text-decoration: none;
            color: var(--text-color);
            cursor: pointer;
        }
        .tune-context-menu .submenu a:hover {
            background-color: var(--hover-bg);
            color: var(--primary);
        }
        .tune-context-menu .submenu a.disabled {
            color: var(--disabled-text);
            cursor: not-allowed;
        }
        .tune-context-menu .submenu a.disabled:hover {
            background-color: transparent;
            color: var(--disabled-text);
        }
        .tune-name-wrapper {
            position: relative;
            display: inline;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: var(--bg-color, white);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            color: var(--text-color);
        }
        .modal-header {
            margin-bottom: 16px;
        }
        .modal-header h3 {
            margin: 0;
            color: var(--text-color);
        }
        .modal-body {
            margin-bottom: 20px;
        }
        .modal-body label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color);
        }
        .modal-body input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        /* Dark mode styles for modal form elements */
        [data-theme="dark"] .modal-body input,
        [data-theme="dark"] .modal-body textarea,
        [data-theme="dark"] .modal-body select {
            background-color: var(--dropdown-bg);
            border-color: var(--border-color);
            color: var(--text-color);
        }
        
        [data-theme="dark"] .modal-body input:focus,
        [data-theme="dark"] .modal-body textarea:focus,
        [data-theme="dark"] .modal-body select:focus {
            background-color: var(--dropdown-bg);
            border-color: var(--primary);
            color: var(--text-color);
        }
        
        [data-theme="dark"] .modal-body label {
            color: var(--text-color);
        }
        .modal-footer {
            text-align: right;
        }
        .modal-footer button {
            margin-left: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal-footer .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        .modal-footer .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }
        .modal-footer button:hover {
            opacity: 0.9;
        }
        .highlighted-tune {
            background-color: var(--warning-bg, #fff3cd) !important;
            padding: 2px 4px;
            border-radius: 3px;
            border-left: 3px solid var(--warning, #ffc107);
        }
        .tune-types {
            font-size: 0.8em;
            color: var(--disabled-text);
            font-style: italic;
        }
    </style>
{% endblock %}

{% block content %}
<div class="landing-page" style="display: block;">

    <h1 class="editable-header">{{ session_instance.session_name }}<span class="edit-link" id="edit-name-btn">Edit</span></h1>
    <h2 class="editable-header{% if session_instance.is_cancelled %} cancelled-date{% endif %}">{{ session_instance.date }}<span class="edit-link" id="edit-date-btn">Edit</span></h2>
    
    {% if session_instance.location_override %}
    <p style="margin: 10px 0; color: var(--disabled-text); font-style: italic;">
        <strong>Note</strong> - actual location of this session: {{ session_instance.location_override }}
    </p>
    {% endif %}
    
    <div id="message-container">
        {% with messages = get_flashed_messages() %}
            {% if messages %}
                <div class="message success">
                    {% for message in messages %}
                        <p>{{ message }}</p>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}
    </div>
    
    <!-- Link Tune Modal -->
    <div id="link-tune-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Link Tune</h3>
            </div>
            <div class="modal-body">
                <p>Enter a URL or tune ID from thesession.org to link for this name:</p>
                <label for="tune-link-input">Tune ID or URL:</label>
                <input type="text" id="tune-link-input" placeholder="e.g. 1234 or https://thesession.org/tunes/1234">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="link-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="link-confirm-btn">Link</button>
            </div>
        </div>
    </div>
    
    <!-- Add Tune to Set Modal -->
    <div id="add-tune-to-set-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add Tunes to Set</h3>
            </div>
            <div class="modal-body">
                <p>Enter comma-separated tune names to add to the end of this set:</p>
                <label for="add-tune-to-set-input">Tune names:</label>
                <input type="text" id="add-tune-to-set-input" placeholder="e.g. The Humours of Whiskey, Morrison's Jig" style="width: 100%; box-sizing: border-box;">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="add-to-set-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="add-to-set-confirm-btn">Add</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Tune Modal -->
    <div id="edit-tune-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Tune</h3>
            </div>
            <div class="modal-body">
                <label for="edit-tune-name-input">Tune Name:</label>
                <input type="text" id="edit-tune-name-input" placeholder="Enter tune name" style="width: 100%; box-sizing: border-box; margin-bottom: 16px;">
                
                <label for="edit-tune-url-display">TheSession.org URL:</label>
                <input type="text" id="edit-tune-url-display" readonly style="width: 100%; box-sizing: border-box; background-color: var(--light); color: var(--disabled-text);">
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="edit-tune-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="edit-tune-save-btn">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Edit Session Instance Modal -->
    <div id="edit-session-instance-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Session Instance</h3>
            </div>
            <div class="modal-body">
                <label for="edit-session-date-input">Session Date:</label>
                <input type="date" id="edit-session-date-input" required>
                
                <label for="edit-session-location-input" style="margin-top: 16px;">Location:</label>
                <input type="text" id="edit-session-location-input" placeholder="The usual: {{ session_instance.session_name }}">
                
                <label for="edit-session-comments-input" style="margin-top: 16px;">Comments:</label>
                <textarea id="edit-session-comments-input" placeholder="Notes about this session" rows="3" style="resize: vertical;"></textarea>
                
                <div style="margin-top: 16px;">
                    <label style="display: flex; align-items: center; font-weight: normal;">
                        <input type="checkbox" id="edit-session-cancelled-input" style="margin-right: 8px; width: auto;">
                        Cancelled?
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <a href="#" class="delete-link" id="delete-session-btn">Delete this session instance</a>
                <button type="button" class="btn-secondary" id="edit-session-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="edit-session-save-btn">Save</button>
            </div>
        </div>
    </div>
    
    {% if session_instance.comments %}
    <div class="session-instance-comments">
        <h3>Notes from this session:</h3>
        <p>{{ session_instance.comments }}</p>
    </div>
    {% endif %}
    
    {% if session_instance.is_cancelled %}
    <div class="cancelled-message">
        <strong>This session instance was cancelled.</strong>
    </div>
    {% else %}
    <div id="tunes-container">
        <h3>Tunes Played:</h3>
        <div id="tune-sets">
            <!-- Tunes will be rendered immediately from server-side data -->
        </div>
        
        <div id="add-tune-form" class="hidden" style="margin-top: 20px;">
            <form id="tune-form" style="display: flex; flex-wrap: wrap; align-items: center; gap: 10px;">
                <label for="tune_name_input">Add tune(s) by name:</label>
                <textarea id="tune_name_input" placeholder="Enter tune name(s)" required style="flex: 1; min-width: 200px; max-width: 400px; padding: 6px 8px; resize: none; overflow: hidden; min-height: 36px; font-family: inherit; font-size: inherit; line-height: 1.2; box-sizing: border-box; vertical-align: top;"></textarea>
                <button type="submit" id="add-tune-btn">Add</button>
                <span id="add-tune-spinner" class="loading-spinner" style="display: none; margin-left: 8px;">
                    <span style="display: inline-block; width: 16px; height: 16px; border: 2px solid var(--border-color); border-top: 2px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite;"></span>
                </span>
            </form>
        </div>
    </div>
    
    <div style="margin-top: 30px;">
        <button id="toggle-edit-btn" style="background-color: var(--success, #28a745); color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">Edit</button>
    </div>
    {% endif %}
    
    <p><a href="/sessions/{{ session_instance.session_path }}">← Back to this session</a></p>
{% endblock %}

{% block extra_js %}
<script>
        const sessionPath = '{{ session_instance.session_path }}';
        const sessionDate = '{{ session_instance.date }}';
        const isCancelled = {{ 'true' if session_instance.is_cancelled else 'false' }};
        
        // Session instance data for editing
        const sessionInstanceData = {
            date: '{{ session_instance.date }}',
            location_override: {{ session_instance.location_override|tojson if session_instance.location_override else 'null' }},
            default_location: {{ session_instance.default_location|tojson if session_instance.default_location else 'null' }},
            comments: {{ session_instance.comments|tojson if session_instance.comments else 'null' }},
            is_cancelled: {{ 'true' if session_instance.is_cancelled else 'false' }}
        };
        
        // Check if we should start in edit mode (for newly created instances)
        const urlParams = new URLSearchParams(window.location.search);
        let editMode = !isCancelled && urlParams.get('edit') === 'true';
        
        // Check if a specific tune should be highlighted
        const highlightTuneId = urlParams.get('highlight_tune');
        
        // Load tunes on page load
        document.addEventListener('DOMContentLoaded', function() {
            if (!isCancelled) {
                // Use server-side data instead of API call for initial load
                const initialTuneSets = {{ tune_sets|tojson }};
                renderTunes(initialTuneSets);
                updateUI();
                setupTextareaAutoExpand();
            }
            
            // Clean up URL by removing the edit or highlight_tune parameters if present
            if (urlParams.get('edit') === 'true' || urlParams.get('highlight_tune')) {
                const newUrl = window.location.pathname;
                window.history.replaceState({}, document.title, newUrl);
            }
        });
        
        // Toggle edit mode (only if not cancelled)
        if (!isCancelled) {
            document.getElementById('toggle-edit-btn').addEventListener('click', function() {
                editMode = !editMode;
                updateUI(true); // Pass true to reload tunes when toggling edit mode
            });
        }
        
        // Edit session instance event listeners (always available)
        document.getElementById('edit-name-btn').addEventListener('click', showEditSessionModal);
        document.getElementById('edit-date-btn').addEventListener('click', showEditSessionModal);
        document.getElementById('edit-session-cancel-btn').addEventListener('click', hideEditSessionModal);
        document.getElementById('edit-session-save-btn').addEventListener('click', saveSessionInstance);
        document.getElementById('delete-session-btn').addEventListener('click', confirmDeleteSession);
        
        // Close edit modal on escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                hideEditSessionModal();
            }
        });
        
        // Close edit modal when clicking outside
        document.getElementById('edit-session-instance-modal').addEventListener('click', (event) => {
            if (event.target === event.currentTarget) {
                hideEditSessionModal();
            }
        });
        
        // Handle enter key in edit session modal inputs
        document.getElementById('edit-session-date-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                saveSessionInstance();
            }
        });
        
        document.getElementById('edit-session-location-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                saveSessionInstance();
            }
        });
        
        document.getElementById('edit-session-comments-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent new line in textarea
                saveSessionInstance();
            }
            // Shift+Enter allows new lines in the comments textarea
        });
        
        // Handle add tune form submission (only if not cancelled)
        if (!isCancelled) {
            document.getElementById('tune-form').addEventListener('submit', function(e) {
                e.preventDefault();
                const tuneName = document.getElementById('tune_name_input').value.trim();
                if (tuneName) {
                    addTune(tuneName);
                }
            });
        }
        
        function updateUI(reloadTunes = false) {
            const toggleBtn = document.getElementById('toggle-edit-btn');
            const addForm = document.getElementById('add-tune-form');
            
            if (editMode) {
                toggleBtn.textContent = 'View';
                toggleBtn.style.backgroundColor = 'var(--primary)';
                addForm.classList.remove('hidden');
            } else {
                toggleBtn.textContent = 'Edit';
                toggleBtn.style.backgroundColor = 'var(--success, #28a745)';
                addForm.classList.add('hidden');
            }
            
            if (reloadTunes) {
                loadTunes(); // Only reload tunes when explicitly requested
            }
        }
        
        let adjustTextareaHeight; // Global reference to the adjust function
        
        function setupTextareaAutoExpand() {
            const textarea = document.getElementById('tune_name_input');
            
            function adjustHeight() {
                textarea.style.height = 'auto';
                textarea.style.height = Math.max(36, textarea.scrollHeight) + 'px';
            }
            
            // Make adjustHeight accessible globally
            adjustTextareaHeight = adjustHeight;
            
            // Auto-expand on input
            textarea.addEventListener('input', adjustHeight);
            
            // Auto-expand on paste
            textarea.addEventListener('paste', function() {
                setTimeout(adjustHeight, 0);
            });
            
            // Handle Shift+Enter for new lines, Enter for form submission
            textarea.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    if (event.shiftKey) {
                        // Shift+Enter: Allow new line and adjust height
                        setTimeout(adjustHeight, 0);
                    } else {
                        // Regular Enter: Submit form
                        event.preventDefault();
                        document.getElementById('tune-form').dispatchEvent(new Event('submit'));
                    }
                }
            });
            
            // Initial adjustment in case there's already content
            adjustHeight();
        }
        
        function showMessage(message, type = 'success') {
            const container = document.getElementById('message-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = message;
            
            container.innerHTML = '';
            container.appendChild(messageDiv);
            
            // Trigger animation by adding show class after a brief delay
            setTimeout(() => {
                messageDiv.classList.add('show');
            }, 10);
            
            // Auto-hide message after 3 seconds
            setTimeout(() => {
                messageDiv.classList.remove('show');
                // Remove from DOM after animation completes
                setTimeout(() => {
                    if (container.contains(messageDiv)) {
                        container.removeChild(messageDiv);
                    }
                }, 300);
            }, 3000);
        }
        
        function loadTunes() {
            const container = document.getElementById('tune-sets');
            container.classList.add('loading');
            
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/tunes`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        renderTunes(data.tune_sets);
                    } else {
                        showMessage(data.message, 'error');
                    }
                })
                .catch(error => {
                    showMessage('Failed to load tunes', 'error');
                    console.error('Error:', error);
                })
                .finally(() => {
                    container.classList.remove('loading');
                });
        }
        
        function renderTunes(tuneSets) {
            const container = document.getElementById('tune-sets');
            
            // Cache tune data for move operations
            cachedTuneData = tuneSets;
            
            if (!tuneSets || tuneSets.length === 0) {
                container.innerHTML = '<p>No tunes recorded for this session yet.</p>';
                cachedTuneData = [];
                return;
            }
            
            const ul = document.createElement('ul');
            
            tuneSets.forEach(tuneSet => {
                const li = document.createElement('li');
                
                tuneSet.forEach((tune, index) => {
                    const [orderNumber, continuesSet, tuneId, tuneName, setting, tuneType] = tune;
                    
                    // Create wrapper for tune name with context menu
                    const wrapper = document.createElement('span');
                    wrapper.className = 'tune-name-wrapper';
                    
                    // Check if this tune should be highlighted
                    if (highlightTuneId && tuneId && tuneId.toString() === highlightTuneId) {
                        wrapper.classList.add('highlighted-tune');
                    }
                    
                    if (tuneId) {
                        let link = `https://thesession.org/tunes/${tuneId}`;
                        if (setting) {
                            link += `#setting${setting}`;
                        }
                        
                        const a = document.createElement('a');
                        a.href = link;
                        a.target = '_blank';
                        a.textContent = tuneName;
                        wrapper.appendChild(a);
                    } else {
                        wrapper.appendChild(document.createTextNode(tuneName));
                    }
                    
                    // Add context menu functionality
                    setupTuneContextMenu(wrapper, tuneName, tuneId, setting, orderNumber);
                    
                    li.appendChild(wrapper);
                    
                    if (index < tuneSet.length - 1) {
                        li.appendChild(document.createTextNode(', '));
                    }
                });
                
                // Add tune types display (only in view mode)
                if (!editMode && tuneSet.some(tune => tune[5] !== null)) {
                    const tuneTypes = tuneSet.map(tune => tune[5]).filter(type => type !== null);
                    
                    if (tuneTypes.length > 0) {
                        // Function to pluralize tune types
                        function pluralizeTuneType(type) {
                            if (!type) return type;
                            // Handle special cases
                            if (type === 'Three-Two') return 'Three-Twos';
                            // For most types, just add 's'
                            return type + 's';
                        }
                        
                        let typeText;
                        const uniqueTypes = [...new Set(tuneTypes)];
                        
                        if (uniqueTypes.length === 1) {
                            // Single type: use singular if only one tune, plural if multiple tunes
                            const type = uniqueTypes[0];
                            typeText = tuneSet.length === 1 ? type : pluralizeTuneType(type);
                        } else {
                            // Multiple types: walk through in order and coalesce consecutive same types
                            const coalescedTypes = [];
                            let currentType = null;
                            let currentCount = 0;
                            
                            for (const type of tuneTypes) {
                                if (type === currentType) {
                                    currentCount++;
                                } else {
                                    // Output previous type if any
                                    if (currentType !== null) {
                                        const displayType = currentCount === 1 ? currentType : pluralizeTuneType(currentType);
                                        coalescedTypes.push(displayType);
                                    }
                                    // Start new type
                                    currentType = type;
                                    currentCount = 1;
                                }
                            }
                            
                            // Output final type
                            if (currentType !== null) {
                                const displayType = currentCount === 1 ? currentType : pluralizeTuneType(currentType);
                                coalescedTypes.push(displayType);
                            }
                            
                            typeText = coalescedTypes.join(', ');
                        }
                        
                        const typeSpan = document.createElement('span');
                        typeSpan.className = 'tune-types';
                        typeSpan.textContent = ` (${typeText})`;
                        li.appendChild(typeSpan);
                    }
                }
                
                ul.appendChild(li);
            });
            
            container.innerHTML = '';
            container.appendChild(ul);
        }
        
        function addTune(tuneName) {
            const form = document.getElementById('tune-form');
            const addButton = document.getElementById('add-tune-btn');
            const spinner = document.getElementById('add-tune-spinner');
            
            // Show spinner and disable button
            addButton.disabled = true;
            spinner.style.display = 'inline-block';
            form.classList.add('loading');
            
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/add_tune`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ tune_name: tuneName })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    const textarea = document.getElementById('tune_name_input');
                    textarea.value = '';
                    // Reset textarea height using the existing adjust function
                    if (adjustTextareaHeight) {
                        setTimeout(adjustTextareaHeight, 0);
                    }
                    loadTunes();
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to add tune', 'error');
                console.error('Error:', error);
            })
            .finally(() => {
                // Hide spinner and re-enable button
                addButton.disabled = false;
                spinner.style.display = 'none';
                form.classList.remove('loading');
            });
        }
        
        function deleteTune(orderNumber) {
            const container = document.getElementById('tune-sets');
            container.classList.add('loading');
            
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/delete_tune_by_order/${orderNumber}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    loadTunes();
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to delete tune', 'error');
                console.error('Error:', error);
            })
            .finally(() => {
                container.classList.remove('loading');
            });
        }
        
        // Global variable to cache tune data for move operations
        let cachedTuneData = null;
        
        function getCurrentTuneData(orderNumber) {
            if (!cachedTuneData) {
                return {
                    canMoveSetUp: false,
                    canMoveSetDown: false,
                    canMoveTuneLeft: false,
                    canMoveTuneRight: false
                };
            }
            
            // Find the tune with this order number
            const allTunes = [];
            cachedTuneData.forEach(tuneSet => {
                tuneSet.forEach(tune => {
                    allTunes.push(tune);
                });
            });
            
            const currentTuneIndex = allTunes.findIndex(tune => tune[0] === orderNumber);
            if (currentTuneIndex === -1) {
                return {
                    canMoveSetUp: false,
                    canMoveSetDown: false,
                    canMoveTuneLeft: false,
                    canMoveTuneRight: false
                };
            }
            
            const currentTune = allTunes[currentTuneIndex];
            const isFirstTuneInSet = !currentTune[1]; // continues_set is False
            
            // Find which set this tune belongs to
            let currentSetIndex = -1;
            let currentTuneIndexInSet = -1;
            for (let setIndex = 0; setIndex < cachedTuneData.length; setIndex++) {
                const tuneSet = cachedTuneData[setIndex];
                for (let tuneIndex = 0; tuneIndex < tuneSet.length; tuneIndex++) {
                    if (tuneSet[tuneIndex][0] === orderNumber) {
                        currentSetIndex = setIndex;
                        currentTuneIndexInSet = tuneIndex;
                        break;
                    }
                }
                if (currentSetIndex !== -1) break;
            }
            
            return {
                canMoveSetUp: currentSetIndex > 0,
                canMoveSetDown: currentSetIndex < cachedTuneData.length - 1,
                canMoveTuneLeft: currentTuneIndexInSet > 0,
                canMoveTuneRight: currentTuneIndexInSet < cachedTuneData[currentSetIndex].length - 1
            };
        }
        
        function moveSet(orderNumber, direction) {
            const container = document.getElementById('tune-sets');
            container.classList.add('loading');
            
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/move_set`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    order_number: orderNumber,
                    direction: direction
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    loadTunes();
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to move set', 'error');
                console.error('Error:', error);
            })
            .finally(() => {
                container.classList.remove('loading');
            });
        }
        
        function moveTune(orderNumber, direction) {
            const container = document.getElementById('tune-sets');
            container.classList.add('loading');
            
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/move_tune`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    order_number: orderNumber,
                    direction: direction
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    loadTunes();
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to move tune', 'error');
                console.error('Error:', error);
            })
            .finally(() => {
                container.classList.remove('loading');
            });
        }
        
        function setupTuneContextMenu(wrapper, tuneName, tuneId, setting, orderNumber) {
            let hoverTimeout;
            let hideTimeout;
            let autoHideTimeout;
            let touchStartTime;
            let contextMenu;
            let isMouseOverArea = false; // Track if mouse is over wrapper or menu
            
            // Create context menu element
            function createContextMenu() {
                if (contextMenu) {
                    contextMenu.remove();
                }
                contextMenu = document.createElement('div');
                contextMenu.className = 'tune-context-menu';
                
                // Only show options if we have a tuneId (linked tune)
                if (tuneId) {
                    // Dots option - link to thesession.org
                    const dotsLink = document.createElement('a');
                    dotsLink.textContent = 'Dots';
                    const dotsHandler = function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        window.open(`https://thesession.org/tunes/${tuneId}${setting ? '#setting' + setting : ''}`, '_blank');
                        contextMenu.style.display = 'none';
                    };
                    dotsLink.addEventListener('click', dotsHandler);
                    dotsLink.addEventListener('touchend', dotsHandler);
                    contextMenu.appendChild(dotsLink);
                    
                    // Info option - link to our tune info page
                    const infoLink = document.createElement('a');
                    infoLink.textContent = 'Info';
                    const infoHandler = function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        window.location.href = `/sessions/${sessionPath}/tunes/${tuneId}?from_date=${sessionDate}`;
                    };
                    infoLink.addEventListener('click', infoHandler);
                    infoLink.addEventListener('touchend', infoHandler);
                    contextMenu.appendChild(infoLink);
                    
                    // Relink option - relink to different URL
                    const relinkLink = document.createElement('a');
                    relinkLink.textContent = 'Relink';
                    relinkLink.style.color = 'var(--warning, #ffc107)';
                    const relinkHandler = function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        showLinkTuneModal(tuneName, orderNumber, tuneId, setting);
                        contextMenu.style.display = 'none';
                    };
                    relinkLink.addEventListener('click', relinkHandler);
                    relinkLink.addEventListener('touchend', relinkHandler);
                    contextMenu.appendChild(relinkLink);
                    
                    // Move options - only in edit mode
                    if (editMode) {
                        const moveContainer = document.createElement('div');
                        moveContainer.className = 'menu-item-with-submenu';
                        
                        const moveLink = document.createElement('a');
                        moveLink.textContent = 'Move ...';
                        moveLink.style.cursor = 'default'; // Don't show pointer since it's a submenu trigger
                        
                        const submenu = document.createElement('div');
                        submenu.className = 'submenu';
                        
                        // Get current tune data for move logic
                        const tuneData = getCurrentTuneData(orderNumber);
                        
                        // Move Set Up
                        const moveSetUpLink = document.createElement('a');
                        moveSetUpLink.textContent = 'Move Set Up';
                        if (tuneData.canMoveSetUp) {
                            const moveSetUpHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveSet(orderNumber, 'up');
                                contextMenu.style.display = 'none';
                            };
                            moveSetUpLink.addEventListener('click', moveSetUpHandler);
                            moveSetUpLink.addEventListener('touchend', moveSetUpHandler);
                        } else {
                            moveSetUpLink.className = 'disabled';
                        }
                        submenu.appendChild(moveSetUpLink);
                        
                        // Move Set Down
                        const moveSetDownLink = document.createElement('a');
                        moveSetDownLink.textContent = 'Move Set Down';
                        if (tuneData.canMoveSetDown) {
                            const moveSetDownHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveSet(orderNumber, 'down');
                                contextMenu.style.display = 'none';
                            };
                            moveSetDownLink.addEventListener('click', moveSetDownHandler);
                            moveSetDownLink.addEventListener('touchend', moveSetDownHandler);
                        } else {
                            moveSetDownLink.className = 'disabled';
                        }
                        submenu.appendChild(moveSetDownLink);
                        
                        // Move Tune Left
                        if (tuneData.canMoveTuneLeft) {
                            const moveTuneLeftLink = document.createElement('a');
                            moveTuneLeftLink.textContent = 'Move Tune Left';
                            const moveTuneLeftHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveTune(orderNumber, 'left');
                                contextMenu.style.display = 'none';
                            };
                            moveTuneLeftLink.addEventListener('click', moveTuneLeftHandler);
                            moveTuneLeftLink.addEventListener('touchend', moveTuneLeftHandler);
                            submenu.appendChild(moveTuneLeftLink);
                        }
                        
                        // Move Tune Right
                        if (tuneData.canMoveTuneRight) {
                            const moveTuneRightLink = document.createElement('a');
                            moveTuneRightLink.textContent = 'Move Tune Right';
                            const moveTuneRightHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveTune(orderNumber, 'right');
                                contextMenu.style.display = 'none';
                            };
                            moveTuneRightLink.addEventListener('click', moveTuneRightHandler);
                            moveTuneRightLink.addEventListener('touchend', moveTuneRightHandler);
                            submenu.appendChild(moveTuneRightLink);
                        }
                        
                        moveContainer.appendChild(moveLink);
                        moveContainer.appendChild(submenu);
                        contextMenu.appendChild(moveContainer);
                        
                        // Edit option - only in edit mode
                        const editLink = document.createElement('a');
                        editLink.textContent = 'Edit';
                        editLink.style.color = 'var(--primary)';
                        const editHandler = function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            showEditTuneModal(tuneName, tuneId, setting, orderNumber);
                            contextMenu.style.display = 'none';
                        };
                        editLink.addEventListener('click', editHandler);
                        editLink.addEventListener('touchend', editHandler);
                        contextMenu.appendChild(editLink);
                        
                        // Add option - only in edit mode
                        const addLink = document.createElement('a');
                        addLink.textContent = 'Add';
                        addLink.style.color = 'var(--success, #28a745)';
                        const addHandler = function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            showAddTuneToSetModal(orderNumber);
                            contextMenu.style.display = 'none';
                        };
                        addLink.addEventListener('click', addHandler);
                        addLink.addEventListener('touchend', addHandler);
                        contextMenu.appendChild(addLink);
                    }
                    
                    // Delete option - only in edit mode
                    if (editMode) {
                        const deleteLink = document.createElement('a');
                        deleteLink.textContent = 'Delete';
                        deleteLink.style.color = 'var(--danger, #dc3545)';
                        const deleteHandler = function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            if (confirm(`Delete ${tuneName}?`)) {
                                deleteTune(orderNumber);
                            }
                            contextMenu.style.display = 'none';
                        };
                        deleteLink.addEventListener('click', deleteHandler);
                        deleteLink.addEventListener('touchend', deleteHandler);
                        contextMenu.appendChild(deleteLink);
                    }
                } else {
                    // For tunes without tuneId, show limited options
                    if (editMode) {
                        // Link option for name-only tunes in edit mode
                        const linkLink = document.createElement('a');
                        linkLink.textContent = 'Link';
                        linkLink.style.color = 'var(--success, #28a745)';
                        const linkHandler = function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            showLinkTuneModal(tuneName, orderNumber);
                            contextMenu.style.display = 'none';
                        };
                        linkLink.addEventListener('click', linkHandler);
                        linkLink.addEventListener('touchend', linkHandler);
                        contextMenu.appendChild(linkLink);
                        
                        // Move options for name-only tunes
                        const moveContainer = document.createElement('div');
                        moveContainer.className = 'menu-item-with-submenu';
                        
                        const moveLink = document.createElement('a');
                        moveLink.textContent = 'Move ...';
                        moveLink.style.cursor = 'default'; // Don't show pointer since it's a submenu trigger
                        
                        const submenu = document.createElement('div');
                        submenu.className = 'submenu';
                        
                        // Get current tune data for move logic
                        const tuneData = getCurrentTuneData(orderNumber);
                        
                        // Move Set Up
                        const moveSetUpLink = document.createElement('a');
                        moveSetUpLink.textContent = 'Move Set Up';
                        if (tuneData.canMoveSetUp) {
                            const moveSetUpHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveSet(orderNumber, 'up');
                                contextMenu.style.display = 'none';
                            };
                            moveSetUpLink.addEventListener('click', moveSetUpHandler);
                            moveSetUpLink.addEventListener('touchend', moveSetUpHandler);
                        } else {
                            moveSetUpLink.className = 'disabled';
                        }
                        submenu.appendChild(moveSetUpLink);
                        
                        // Move Set Down
                        const moveSetDownLink = document.createElement('a');
                        moveSetDownLink.textContent = 'Move Set Down';
                        if (tuneData.canMoveSetDown) {
                            const moveSetDownHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveSet(orderNumber, 'down');
                                contextMenu.style.display = 'none';
                            };
                            moveSetDownLink.addEventListener('click', moveSetDownHandler);
                            moveSetDownLink.addEventListener('touchend', moveSetDownHandler);
                        } else {
                            moveSetDownLink.className = 'disabled';
                        }
                        submenu.appendChild(moveSetDownLink);
                        
                        // Move Tune Left
                        if (tuneData.canMoveTuneLeft) {
                            const moveTuneLeftLink = document.createElement('a');
                            moveTuneLeftLink.textContent = 'Move Tune Left';
                            const moveTuneLeftHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveTune(orderNumber, 'left');
                                contextMenu.style.display = 'none';
                            };
                            moveTuneLeftLink.addEventListener('click', moveTuneLeftHandler);
                            moveTuneLeftLink.addEventListener('touchend', moveTuneLeftHandler);
                            submenu.appendChild(moveTuneLeftLink);
                        }
                        
                        // Move Tune Right
                        if (tuneData.canMoveTuneRight) {
                            const moveTuneRightLink = document.createElement('a');
                            moveTuneRightLink.textContent = 'Move Tune Right';
                            const moveTuneRightHandler = function(event) {
                                event.preventDefault();
                                event.stopPropagation();
                                moveTune(orderNumber, 'right');
                                contextMenu.style.display = 'none';
                            };
                            moveTuneRightLink.addEventListener('click', moveTuneRightHandler);
                            moveTuneRightLink.addEventListener('touchend', moveTuneRightHandler);
                            submenu.appendChild(moveTuneRightLink);
                        }
                        
                        moveContainer.appendChild(moveLink);
                        moveContainer.appendChild(submenu);
                        contextMenu.appendChild(moveContainer);
                        
                        // Edit option for name-only tunes
                        const editLink = document.createElement('a');
                        editLink.textContent = 'Edit';
                        editLink.style.color = 'var(--primary)';
                        const editHandler = function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            showEditTuneModal(tuneName, tuneId, setting, orderNumber);
                            contextMenu.style.display = 'none';
                        };
                        editLink.addEventListener('click', editHandler);
                        editLink.addEventListener('touchend', editHandler);
                        contextMenu.appendChild(editLink);
                        
                        // Add option for name-only tunes
                        const addLink = document.createElement('a');
                        addLink.textContent = 'Add';
                        addLink.style.color = 'var(--success, #28a745)';
                        const addHandler = function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            showAddTuneToSetModal(orderNumber);
                            contextMenu.style.display = 'none';
                        };
                        addLink.addEventListener('click', addHandler);
                        addLink.addEventListener('touchend', addHandler);
                        contextMenu.appendChild(addLink);
                        
                        // Still allow delete for name-only tunes in edit mode
                        const deleteLink = document.createElement('a');
                        deleteLink.textContent = 'Delete';
                        deleteLink.style.color = 'var(--danger, #dc3545)';
                        const deleteHandler2 = function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            if (confirm(`Delete ${tuneName}?`)) {
                                deleteTune(orderNumber);
                            }
                            contextMenu.style.display = 'none';
                        };
                        deleteLink.addEventListener('click', deleteHandler2);
                        deleteLink.addEventListener('touchend', deleteHandler2);
                        contextMenu.appendChild(deleteLink);
                    } else {
                        // For non-edit mode, show info message
                        const nameDiv = document.createElement('div');
                        nameDiv.style.cssText = 'padding: 6px 12px; color: var(--disabled-text); font-style: italic;';
                        nameDiv.textContent = 'No tune data available';
                        contextMenu.appendChild(nameDiv);
                    }
                }
                
                // Prevent touch events on the menu from propagating to underlying elements
                contextMenu.addEventListener('touchstart', function(event) {
                    event.stopPropagation();
                });
                
                wrapper.appendChild(contextMenu);
                return contextMenu;
            }
            
            // Show context menu
            function showContextMenu(event) {
                const menu = createContextMenu();
                
                // Position menu below the tune name
                const rect = wrapper.getBoundingClientRect();
                menu.style.top = '100%';
                menu.style.left = '0';
                menu.style.display = 'block';
                
                // Add mouse event listeners to the menu
                addContextMenuListeners();
                
                // Hide menu after 3 seconds (but can be cancelled by mouse hover)
                autoHideTimeout = setTimeout(() => {
                    if (menu && menu.parentNode) {
                        menu.style.display = 'none';
                    }
                }, 3000);
            }
            
            // Hide context menu
            function hideContextMenu() {
                if (contextMenu) {
                    contextMenu.style.display = 'none';
                }
            }
            
            // Start hide timer - only hides if mouse is still away when timer expires
            function startHideTimer() {
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    // Only hide if mouse is not over the area
                    if (!isMouseOverArea) {
                        hideContextMenu();
                    }
                }, 500);
            }
            
            // Desktop: Hover for 3 seconds
            wrapper.addEventListener('mouseenter', () => {
                isMouseOverArea = true;
                clearTimeout(hideTimeout); // Cancel any pending hide
                clearTimeout(autoHideTimeout); // Cancel auto-hide when hovering
                hoverTimeout = setTimeout(() => {
                    showContextMenu();
                }, 3000);
            });
            
            wrapper.addEventListener('mouseleave', () => {
                isMouseOverArea = false;
                clearTimeout(hoverTimeout);
                startHideTimer(); // Start the conditional hide timer
            });
            
            // Add mouse events to context menu itself to prevent hiding
            function addContextMenuListeners() {
                if (contextMenu) {
                    contextMenu.addEventListener('mouseenter', () => {
                        isMouseOverArea = true;
                        clearTimeout(hideTimeout); // Cancel hide when entering menu
                        clearTimeout(autoHideTimeout); // Cancel auto-hide when entering menu
                    });
                    
                    contextMenu.addEventListener('mouseleave', () => {
                        isMouseOverArea = false;
                        startHideTimer(); // Start the conditional hide timer
                    });
                }
            }
            
            // Desktop: Right click - also suppresses mobile context menu
            wrapper.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                showContextMenu(event);
            });
            
            // Mobile: Long press (touch for 1 second)
            wrapper.addEventListener('touchstart', (event) => {
                touchStartTime = Date.now();
                hoverTimeout = setTimeout(() => {
                    showContextMenu(event);
                }, 1000);
            });
            
            wrapper.addEventListener('touchend', (event) => {
                clearTimeout(hoverTimeout);
                const touchDuration = Date.now() - touchStartTime;
                if (touchDuration < 1000) {
                    // Short tap, don't show menu, let normal behavior continue
                    hideContextMenu();
                }
            });
            
            wrapper.addEventListener('touchmove', () => {
                clearTimeout(hoverTimeout);
                hideContextMenu();
            });
        }
        
        // Hide context menus when clicking outside
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.tune-name-wrapper')) {
                document.querySelectorAll('.tune-context-menu').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
        });
        
        // Prevent OS context menu on tune wrappers (for mobile long press)
        document.addEventListener('contextmenu', (event) => {
            if (event.target.closest('.tune-name-wrapper')) {
                event.preventDefault();
            }
        });
        
        // Edit Tune Modal functionality
        let currentEditingTune = null;
        let currentEditingOrder = null;
        let currentEditingTuneId = null;
        let currentEditingSetting = null;
        
        function showEditTuneModal(tuneName, tuneId, setting, orderNumber) {
            currentEditingTune = tuneName;
            currentEditingOrder = orderNumber;
            currentEditingTuneId = tuneId;
            currentEditingSetting = setting;
            
            const modal = document.getElementById('edit-tune-modal');
            const nameInput = document.getElementById('edit-tune-name-input');
            const urlInput = document.getElementById('edit-tune-url-display');
            
            nameInput.value = tuneName;
            
            // Set URL field
            if (tuneId) {
                let url = `https://thesession.org/tunes/${tuneId}`;
                if (setting) {
                    url += `?setting=${setting}`;
                }
                urlInput.value = url;
            } else {
                urlInput.value = '';
            }
            
            modal.style.display = 'flex';
            nameInput.focus();
            nameInput.select();
        }
        
        function hideEditTuneModal() {
            const modal = document.getElementById('edit-tune-modal');
            modal.style.display = 'none';
            currentEditingTune = null;
            currentEditingOrder = null;
            currentEditingTuneId = null;
            currentEditingSetting = null;
        }
        
        function saveEditedTune() {
            const nameInput = document.getElementById('edit-tune-name-input');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                showMessage('Please enter a tune name', 'error');
                return;
            }
            
            // Call API to save the edited tune name
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/edit_tune`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    order_number: currentEditingOrder,
                    new_name: newName,
                    original_name: currentEditingTune,
                    tune_id: currentEditingTuneId,
                    setting_id: currentEditingSetting
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    hideEditTuneModal();
                    loadTunes(); // Reload to show the updated name
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to save tune edit', 'error');
                console.error('Error:', error);
            });
        }
        
        // Add to Set Modal functionality
        let currentAddToSetOrder = null;
        
        function showAddTuneToSetModal(orderNumber) {
            currentAddToSetOrder = orderNumber;
            
            const modal = document.getElementById('add-tune-to-set-modal');
            const input = document.getElementById('add-tune-to-set-input');
            
            input.value = '';
            modal.style.display = 'flex';
            input.focus();
        }
        
        function hideAddTuneToSetModal() {
            const modal = document.getElementById('add-tune-to-set-modal');
            modal.style.display = 'none';
            currentAddToSetOrder = null;
        }
        
        function addTunesToSet() {
            const input = document.getElementById('add-tune-to-set-input');
            const tuneNames = input.value.trim();
            
            if (!tuneNames) {
                showMessage('Please enter tune names', 'error');
                return;
            }
            
            if (!currentAddToSetOrder) {
                showMessage('Invalid set selection', 'error');
                return;
            }
            
            // Call API to add tunes to the specific set
            const container = document.getElementById('tune-sets');
            container.classList.add('loading');
            
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/add_tunes_to_set`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    tune_names: tuneNames,
                    reference_order_number: currentAddToSetOrder
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    hideAddTuneToSetModal();
                    loadTunes();
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to add tunes to set', 'error');
                console.error('Error:', error);
            })
            .finally(() => {
                container.classList.remove('loading');
            });
        }
        
        // Modal functionality
        let currentLinkingTune = null;
        let currentLinkingOrder = null;
        
        function showLinkTuneModal(tuneName, orderNumber, currentTuneId = null, currentSetting = null) {
            currentLinkingTune = tuneName;
            currentLinkingOrder = orderNumber;
            
            const modal = document.getElementById('link-tune-modal');
            const input = document.getElementById('tune-link-input');
            
            // Pre-populate with current URL if relinking
            if (currentTuneId) {
                let currentUrl = `https://thesession.org/tunes/${currentTuneId}`;
                if (currentSetting) {
                    currentUrl += `#setting${currentSetting}`;
                }
                input.value = currentUrl;
                
                // Update modal title to indicate relinking
                const modalTitle = modal.querySelector('h3');
                modalTitle.textContent = 'Relink Tune';
            } else {
                input.value = '';
                
                // Reset modal title to original
                const modalTitle = modal.querySelector('h3');
                modalTitle.textContent = 'Link Tune';
            }
            
            modal.style.display = 'flex';
            input.focus();
            input.select(); // Select all text for easy replacement
        }
        
        function hideLinkTuneModal() {
            const modal = document.getElementById('link-tune-modal');
            modal.style.display = 'none';
            currentLinkingTune = null;
            currentLinkingOrder = null;
        }
        
        function validateTuneInput(input) {
            // Validate input format - either a number or a thesession.org URL
            const urlPattern = /thesession\.org\/tunes\/\d+(?:#setting\d+)?/;
            const numberPattern = /^\d+$/;
            
            const trimmed = input.trim();
            
            if (urlPattern.test(trimmed) || numberPattern.test(trimmed)) {
                return trimmed;
            }
            
            return null;
        }
        
        function linkTune() {
            const input = document.getElementById('tune-link-input');
            const validatedInput = validateTuneInput(input.value);
            
            if (!validatedInput) {
                showMessage('Please enter a valid tune ID or thesession.org URL', 'error');
                return;
            }
            
            // Call API to link the tune (pass full input for backend parsing)
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/link_tune`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    tune_id: validatedInput,
                    tune_name: currentLinkingTune,
                    order_number: currentLinkingOrder
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    hideLinkTuneModal();
                    loadTunes(); // Reload the tunes to show the new link
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to link tune', 'error');
                console.error('Error:', error);
            });
        }
        
        // Modal event listeners
        document.getElementById('link-cancel-btn').addEventListener('click', hideLinkTuneModal);
        document.getElementById('link-confirm-btn').addEventListener('click', linkTune);
        
        // Edit Tune Modal event listeners
        document.getElementById('edit-tune-cancel-btn').addEventListener('click', hideEditTuneModal);
        document.getElementById('edit-tune-save-btn').addEventListener('click', saveEditedTune);
        
        // Add to Set Modal event listeners
        document.getElementById('add-to-set-cancel-btn').addEventListener('click', hideAddTuneToSetModal);
        document.getElementById('add-to-set-confirm-btn').addEventListener('click', addTunesToSet);
        
        // Close modal on escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                hideLinkTuneModal();
                hideAddTuneToSetModal();
                hideEditTuneModal();
            }
        });
        
        // Close modal when clicking outside
        document.getElementById('link-tune-modal').addEventListener('click', (event) => {
            if (event.target === event.currentTarget) {
                hideLinkTuneModal();
            }
        });
        
        document.getElementById('add-tune-to-set-modal').addEventListener('click', (event) => {
            if (event.target === event.currentTarget) {
                hideAddTuneToSetModal();
            }
        });
        
        document.getElementById('edit-tune-modal').addEventListener('click', (event) => {
            if (event.target === event.currentTarget) {
                hideEditTuneModal();
            }
        });
        
        // Handle enter key in input
        document.getElementById('tune-link-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                linkTune();
            }
        });
        
        document.getElementById('add-tune-to-set-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                addTunesToSet();
            }
        });
        
        document.getElementById('edit-tune-name-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                saveEditedTune();
            }
        });
        
        // Edit Session Instance Modal Functions
        function showEditSessionModal() {
            const modal = document.getElementById('edit-session-instance-modal');
            const dateInput = document.getElementById('edit-session-date-input');
            const locationInput = document.getElementById('edit-session-location-input');
            const commentsInput = document.getElementById('edit-session-comments-input');
            const cancelledInput = document.getElementById('edit-session-cancelled-input');
            
            // Populate fields with current values
            dateInput.value = sessionInstanceData.date;
            locationInput.value = sessionInstanceData.location_override || '';
            commentsInput.value = sessionInstanceData.comments || '';
            cancelledInput.checked = sessionInstanceData.is_cancelled;
            
            modal.style.display = 'flex';
            dateInput.focus();
        }
        
        function hideEditSessionModal() {
            const modal = document.getElementById('edit-session-instance-modal');
            modal.style.display = 'none';
        }
        
        function saveSessionInstance() {
            const dateInput = document.getElementById('edit-session-date-input');
            const locationInput = document.getElementById('edit-session-location-input');
            const commentsInput = document.getElementById('edit-session-comments-input');
            const cancelledInput = document.getElementById('edit-session-cancelled-input');
            
            const date = dateInput.value.trim();
            const location = locationInput.value.trim();
            const comments = commentsInput.value.trim();
            const cancelled = cancelledInput.checked;
            
            if (!date) {
                showMessage('Please enter a session date', 'error');
                return;
            }
            
            // Prepare request data
            const requestData = { 
                date: date,
                cancelled: cancelled
            };
            
            // Only include location if it's provided
            if (location) {
                requestData.location = location;
            }
            
            // Only include comments if provided
            if (comments) {
                requestData.comments = comments;
            }
            
            // Call API to update the session instance
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/update`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    hideEditSessionModal();
                    // If date changed, redirect to new URL, otherwise reload current page
                    if (date !== sessionDate) {
                        window.location.href = `/sessions/${sessionPath}/${date}`;
                    } else {
                        window.location.reload();
                    }
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to update session instance', 'error');
                console.error('Error:', error);
            });
        }
        
        function confirmDeleteSession() {
            // First get the tune count for this session instance
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/tune_count`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        let confirmMessage = `Delete the ${sessionDate} instance of this session?`;
                        if (data.tune_count > 0) {
                            confirmMessage += `\n\nThere are ${data.tune_count} tunes recorded for this session.`;
                        }
                        
                        if (confirm(confirmMessage)) {
                            deleteSessionInstance();
                        }
                    } else {
                        showMessage('Failed to get session info', 'error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    // Proceed with delete confirmation without tune count
                    if (confirm(`Delete the ${sessionDate} instance of this session?`)) {
                        deleteSessionInstance();
                    }
                });
        }
        
        function deleteSessionInstance() {
            fetch(`/api/sessions/${sessionPath}/${sessionDate}/delete`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message);
                    hideEditSessionModal();
                    // Redirect back to session detail page after a short delay
                    setTimeout(() => {
                        window.location.href = `/sessions/${sessionPath}`;
                    }, 1500);
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                showMessage('Failed to delete session instance', 'error');
                console.error('Error:', error);
            });
        }
    </script>
{% endblock %}