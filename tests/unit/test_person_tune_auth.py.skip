"""
Unit tests for person_tune authentication and authorization middleware.

Tests cover:
- Authentication requirements for personal tune endpoints
- Ownership verification for person_tune records
- System admin access privileges
- Authorization decorators
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from flask import Flask, jsonify
from person_tune_auth import (
    person_tune_login_required,
    verify_person_tune_ownership,
    require_person_tune_ownership,
    get_user_person_id,
    is_system_admin,
    can_access_person_tunes,
    filter_person_tunes_by_user,
)


@pytest.fixture
def app():
    """Create a Flask app for testing decorators."""
    app = Flask(__name__)
    app.config['TESTING'] = True
    return app


@pytest.fixture
def mock_authenticated_user():
    """Create a mock authenticated user."""
    user = Mock()
    user.is_authenticated = True
    user.person_id = 123
    user.user_id = 456
    user.is_system_admin = False
    return user


@pytest.fixture
def mock_admin_user():
    """Create a mock system admin user."""
    user = Mock()
    user.is_authenticated = True
    user.person_id = 999
    user.user_id = 888
    user.is_system_admin = True
    return user


@pytest.fixture
def mock_unauthenticated_user():
    """Create a mock unauthenticated user."""
    user = Mock()
    user.is_authenticated = False
    return user


class TestPersonTuneLoginRequired:
    """Test the person_tune_login_required decorator."""
    
    def test_authenticated_user_can_access(self, app, mock_authenticated_user):
        """Test that authenticated users can access protected endpoints."""
        with app.test_request_context():
            with patch('person_tune_auth.current_user', mock_authenticated_user):
                @person_tune_login_required
                def protected_route():
                    return jsonify({"success": True})
                
                response = protected_route()
                assert response.json['success'] is True
    
    def test_unauthenticated_user_denied(self, app, mock_unauthenticated_user):
        """Test that unauthenticated users receive 401 error."""
        with app.test_request_context():
            with patch('person_tune_auth.current_user', mock_unauthenticated_user):
                @person_tune_login_required
                def protected_route():
                    return jsonify({"success": True})
                
                response, status_code = protected_route()
                assert status_code == 401
                assert response.json['success'] is False
                assert 'Authentication required' in response.json['error']


class TestVerifyPersonTuneOwnership:
    """Test the verify_person_tune_ownership function."""
    
    def test_owner_can_access_own_tune(self, mock_authenticated_user):
        """Test that users can access their own tunes."""
        with patch('person_tune_auth.get_db_connection') as mock_db:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (123,)  # person_id matches user
            mock_conn.cursor.return_value = mock_cursor
            mock_db.return_value = mock_conn
            
            is_authorized, error = verify_person_tune_ownership(1, mock_authenticated_user)
            
            assert is_authorized is True
            assert error is None
            mock_cursor.execute.assert_called_once()
    
    def test_non_owner_denied_access(self, mock_authenticated_user):
        """Test that users cannot access other users' tunes."""
        with patch('person_tune_auth.get_db_connection') as mock_db:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (999,)  # Different person_id
            mock_conn.cursor.return_value = mock_cursor
            mock_db.return_value = mock_conn
            
            is_authorized, error = verify_person_tune_ownership(1, mock_authenticated_user)
            
            assert is_authorized is False
            assert error is not None
            assert 'permission' in error['error'].lower()
    
    def test_admin_can_access_any_tune(self, mock_admin_user):
        """Test that system admins can access any user's tunes."""
        # Admin access should return True without even checking the database
        is_authorized, error = verify_person_tune_ownership(1, mock_admin_user)
        
        assert is_authorized is True
        assert error is None
    
    def test_nonexistent_tune_returns_error(self, mock_authenticated_user):
        """Test that accessing non-existent tune returns appropriate error."""
        with patch('person_tune_auth.get_db_connection') as mock_db:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = None  # Tune not found
            mock_conn.cursor.return_value = mock_cursor
            mock_db.return_value = mock_conn
            
            is_authorized, error = verify_person_tune_ownership(999, mock_authenticated_user)
            
            assert is_authorized is False
            assert error is not None
            assert 'not found' in error['error'].lower()


class TestRequirePersonTuneOwnership:
    """Test the require_person_tune_ownership decorator."""
    
    def test_owner_can_access_endpoint(self, app, mock_authenticated_user):
        """Test that tune owners can access protected endpoints."""
        with app.test_request_context():
            with patch('person_tune_auth.current_user', mock_authenticated_user):
                with patch('person_tune_auth.verify_person_tune_ownership') as mock_verify:
                    mock_verify.return_value = (True, None)
                    
                    @require_person_tune_ownership
                    def protected_route(person_tune_id):
                        return jsonify({"success": True})
                    
                    response = protected_route(person_tune_id=1)
                    assert response.json['success'] is True
    
    def test_non_owner_receives_403(self, app, mock_authenticated_user):
        """Test that non-owners receive 403 Forbidden."""
        with app.test_request_context():
            with patch('person_tune_auth.current_user', mock_authenticated_user):
                with patch('person_tune_auth.verify_person_tune_ownership') as mock_verify:
                    mock_verify.return_value = (False, {"success": False, "error": "No permission"})
                    
                    @require_person_tune_ownership
                    def protected_route(person_tune_id):
                        return jsonify({"success": True})
                    
                    response, status_code = protected_route(person_tune_id=1)
                    assert status_code == 403
                    assert response.json['success'] is False
    
    def test_missing_person_tune_id_returns_400(self, app, mock_authenticated_user):
        """Test that missing person_tune_id returns 400 Bad Request."""
        with app.test_request_context():
            with patch('person_tune_auth.current_user', mock_authenticated_user):
                @require_person_tune_ownership
                def protected_route(person_tune_id=None):
                    return jsonify({"success": True})
                
                response, status_code = protected_route()
                assert status_code == 400
                assert 'person_tune_id required' in response.json['error']


class TestGetUserPersonId:
    """Test the get_user_person_id function."""
    
    def test_returns_person_id_for_authenticated_user(self, mock_authenticated_user):
        """Test that function returns person_id for authenticated users."""
        with patch('person_tune_auth.current_user', mock_authenticated_user):
            person_id = get_user_person_id()
            assert person_id == 123
    
    def test_raises_error_for_unauthenticated_user(self, mock_unauthenticated_user):
        """Test that function raises error for unauthenticated users."""
        with patch('person_tune_auth.current_user', mock_unauthenticated_user):
            with pytest.raises(AttributeError, match="not authenticated"):
                get_user_person_id()
    
    def test_raises_error_when_person_id_missing(self):
        """Test that function raises error when user lacks person_id."""
        user = Mock(spec=['is_authenticated'])
        user.is_authenticated = True
        # Don't set person_id attribute - spec prevents it from being auto-created
        
        with patch('person_tune_auth.current_user', user):
            with pytest.raises(AttributeError, match="does not have a person_id"):
                get_user_person_id()


class TestIsSystemAdmin:
    """Test the is_system_admin function."""
    
    def test_returns_true_for_admin(self, mock_admin_user):
        """Test that function returns True for system admins."""
        with patch('person_tune_auth.current_user', mock_admin_user):
            assert is_system_admin() is True
    
    def test_returns_false_for_regular_user(self, mock_authenticated_user):
        """Test that function returns False for regular users."""
        with patch('person_tune_auth.current_user', mock_authenticated_user):
            assert is_system_admin() is False
    
    def test_returns_false_for_unauthenticated_user(self, mock_unauthenticated_user):
        """Test that function returns False for unauthenticated users."""
        with patch('person_tune_auth.current_user', mock_unauthenticated_user):
            assert is_system_admin() is False


class TestCanAccessPersonTunes:
    """Test the can_access_person_tunes function."""
    
    def test_user_can_access_own_tunes(self, mock_authenticated_user):
        """Test that users can access their own tunes."""
        with patch('person_tune_auth.current_user', mock_authenticated_user):
            assert can_access_person_tunes(123) is True
    
    def test_user_cannot_access_other_tunes(self, mock_authenticated_user):
        """Test that users cannot access other users' tunes."""
        with patch('person_tune_auth.current_user', mock_authenticated_user):
            assert can_access_person_tunes(999) is False
    
    def test_admin_can_access_any_tunes(self, mock_admin_user):
        """Test that admins can access any user's tunes."""
        with patch('person_tune_auth.current_user', mock_admin_user):
            assert can_access_person_tunes(123) is True
            assert can_access_person_tunes(999) is True
    
    def test_unauthenticated_user_cannot_access(self, mock_unauthenticated_user):
        """Test that unauthenticated users cannot access any tunes."""
        with patch('person_tune_auth.current_user', mock_unauthenticated_user):
            assert can_access_person_tunes(123) is False


class TestFilterPersonTunesByUser:
    """Test the filter_person_tunes_by_user function."""
    
    def test_regular_user_gets_own_person_id(self, mock_authenticated_user):
        """Test that regular users get their own person_id for filtering."""
        with patch('person_tune_auth.current_user', mock_authenticated_user):
            result = filter_person_tunes_by_user()
            assert result == {'person_id': 123}
    
    def test_admin_without_params_gets_own_person_id(self, mock_admin_user):
        """Test that admins without query params get their own person_id."""
        with patch('person_tune_auth.current_user', mock_admin_user):
            result = filter_person_tunes_by_user()
            assert result == {'person_id': 999}
    
    def test_admin_with_person_id_param_gets_specified_id(self, mock_admin_user):
        """Test that admins can filter by specified person_id."""
        with patch('person_tune_auth.current_user', mock_admin_user):
            query_params = {'person_id': '456'}
            result = filter_person_tunes_by_user(query_params)
            assert result == {'person_id': 456}
    
    def test_regular_user_cannot_use_person_id_param(self, mock_authenticated_user):
        """Test that regular users cannot filter by other person_ids."""
        with patch('person_tune_auth.current_user', mock_authenticated_user):
            query_params = {'person_id': '999'}
            result = filter_person_tunes_by_user(query_params)
            # Should return their own person_id, not the requested one
            assert result == {'person_id': 123}
    
    def test_invalid_person_id_param_falls_back_to_user(self, mock_admin_user):
        """Test that invalid person_id param falls back to user's person_id."""
        with patch('person_tune_auth.current_user', mock_admin_user):
            query_params = {'person_id': 'invalid'}
            result = filter_person_tunes_by_user(query_params)
            assert result == {'person_id': 999}
